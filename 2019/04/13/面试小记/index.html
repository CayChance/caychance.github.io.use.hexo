<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="面试小记"><meta name="keywords" content><meta name="author" content="CayChance,chance17610999610@gmail.com"><meta name="copyright" content="CayChance"><title>面试小记 | ChanceのBlog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS部分"><span class="toc-number">1.</span> <span class="toc-text">CSS部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#css三列布局，两边固定宽度，中间自适应"><span class="toc-number">1.1.</span> <span class="toc-text">css三列布局，两边固定宽度，中间自适应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css水平垂直居中"><span class="toc-number">1.2.</span> <span class="toc-text">css水平垂直居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-align-item-align-content的区别"><span class="toc-number">1.3.</span> <span class="toc-text">flex align-item align-content的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#和-代表啥"><span class="toc-number">1.4.</span> <span class="toc-text">:和::代表啥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS部分"><span class="toc-number">2.</span> <span class="toc-text">JS部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本类型和引用类型在内存中是如何存储的"><span class="toc-number">2.1.</span> <span class="toc-text">基本类型和引用类型在内存中是如何存储的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#es6中Object的方法-Object-assign-合并对象是浅拷贝，深拷贝"><span class="toc-number">2.2.</span> <span class="toc-text">es6中Object的方法 Object.assign()合并对象是浅拷贝，深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#箭头函数和普通函数的区别"><span class="toc-number">2.3.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承-原型-原型链"><span class="toc-number">2.4.</span> <span class="toc-text">继承 原型 原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组去重"><span class="toc-number">2.5.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的方法"><span class="toc-number">2.6.</span> <span class="toc-text">数组的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性"><span class="toc-number">2.7.</span> <span class="toc-text">for in,for of,for 遍历对象 缺点 只能遍历原型的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何判断一个数组"><span class="toc-number">2.8.</span> <span class="toc-text">如何判断一个数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何判断一个对象是否为空对象"><span class="toc-number">2.9.</span> <span class="toc-text">如何判断一个对象是否为空对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何判断一个类数组对象"><span class="toc-number">2.10.</span> <span class="toc-text">如何判断一个类数组对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步的处理方式都有哪些"><span class="toc-number">2.11.</span> <span class="toc-text">异步的处理方式都有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise、async-await"><span class="toc-number">2.12.</span> <span class="toc-text">Promise、async/await</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise原理"><span class="toc-number">2.13.</span> <span class="toc-text">Promise原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise封装setTimeOut"><span class="toc-number">2.14.</span> <span class="toc-text">Promise封装setTimeOut</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-Loop"><span class="toc-number">2.15.</span> <span class="toc-text">Event Loop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浏览器中的Event-Loop"><span class="toc-number">2.16.</span> <span class="toc-text">浏览器中的Event Loop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node中的Event-Loop"><span class="toc-number">2.17.</span> <span class="toc-text">Node中的Event Loop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#宏任务和微任务的执行顺序"><span class="toc-number">2.18.</span> <span class="toc-text">宏任务和微任务的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node的执行顺序"><span class="toc-number">2.19.</span> <span class="toc-text">Node的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步任务和异步任务的定义"><span class="toc-number">2.20.</span> <span class="toc-text">同步任务和异步任务的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node属于多线程还是单线程"><span class="toc-number">2.21.</span> <span class="toc-text">node属于多线程还是单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node的前端模板"><span class="toc-number">2.22.</span> <span class="toc-text">node的前端模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#process"><span class="toc-number">2.23.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-apply-bind的区别-手写？"><span class="toc-number">2.24.</span> <span class="toc-text">call apply bind的区别 手写？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new发生了什么"><span class="toc-number">2.25.</span> <span class="toc-text">new发生了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数递归-f-n-返回1到n的累加和"><span class="toc-number">2.26.</span> <span class="toc-text">函数递归 f(n) 返回1到n的累加和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSR-Nuxt-Next"><span class="toc-number">2.27.</span> <span class="toc-text">SSR Nuxt Next</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue部分"><span class="toc-number">3.</span> <span class="toc-text">Vue部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue提倡的是单向数据流，但是v-model是双向数据流，为什么"><span class="toc-number">3.1.</span> <span class="toc-text">Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-use"><span class="toc-number">3.2.</span> <span class="toc-text">vue.use()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue双向绑定"><span class="toc-number">3.3.</span> <span class="toc-text">Vue双向绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-router"><span class="toc-number">3.4.</span> <span class="toc-text">Vue router</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vuex数据周期"><span class="toc-number">3.5.</span> <span class="toc-text">Vuex数据周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-nextTick的原理-如何找到dom-依赖收集过程"><span class="toc-number">3.6.</span> <span class="toc-text">vue.nextTick的原理 如何找到dom 依赖收集过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#virtual-dom-diff算法具体实现过程"><span class="toc-number">3.7.</span> <span class="toc-text">virtual-dom diff算法具体实现过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#patch方法详解"><span class="toc-number">3.8.</span> <span class="toc-text">patch方法详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#patchVnode方法详解"><span class="toc-number">3.9.</span> <span class="toc-text">patchVnode方法详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateChildren方法详解"><span class="toc-number">3.10.</span> <span class="toc-text">updateChildren方法详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要使用key？"><span class="toc-number">3.11.</span> <span class="toc-text">为什么要使用key？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM"><span class="toc-number">3.12.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#axios-拦截器"><span class="toc-number">3.13.</span> <span class="toc-text">axios 拦截器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wepack以及项目优化"><span class="toc-number">4.</span> <span class="toc-text">Wepack以及项目优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack热更新的模块"><span class="toc-number">4.1.</span> <span class="toc-text">webpack热更新的模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack配置压缩一个js如何配置"><span class="toc-number">4.2.</span> <span class="toc-text">webpack配置压缩一个js如何配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack编译后图片名为什么会改变"><span class="toc-number">4.3.</span> <span class="toc-text">webpack编译后图片名为什么会改变</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器及安全"><span class="toc-number">5.</span> <span class="toc-text">浏览器及安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#浏览器中支持最大的请求并发数"><span class="toc-number">5.1.</span> <span class="toc-text">浏览器中支持最大的请求并发数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻止冒泡"><span class="toc-number">5.2.</span> <span class="toc-text">阻止冒泡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xss"><span class="toc-number">5.3.</span> <span class="toc-text">xss</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chrome跨标签通信"><span class="toc-number">5.4.</span> <span class="toc-text">chrome跨标签通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跨域"><span class="toc-number">5.5.</span> <span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浏览器缓存机制"><span class="toc-number">5.6.</span> <span class="toc-text">浏览器缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程和线程"><span class="toc-number">5.7.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http状态码"><span class="toc-number">5.8.</span> <span class="toc-text">http状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP常见请求方法以及简单描述"><span class="toc-number">5.9.</span> <span class="toc-text">HTTP常见请求方法以及简单描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Http-header中都有哪些信息"><span class="toc-number">5.10.</span> <span class="toc-text">Http header中都有哪些信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie"><span class="toc-number">5.11.</span> <span class="toc-text">cookie</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">6.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归的复杂度"><span class="toc-number">6.1.</span> <span class="toc-text">递归的复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快排的时间复杂度和空间复杂度"><span class="toc-number">6.2.</span> <span class="toc-text">快排的时间复杂度和空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-number">6.3.</span> <span class="toc-text">冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">7.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#项目优化的点"><span class="toc-number">7.1.</span> <span class="toc-text">项目优化的点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#项目中做过比较复杂的东西如何解决"><span class="toc-number">7.2.</span> <span class="toc-text">项目中做过比较复杂的东西如何解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL"><span class="toc-number">7.3.</span> <span class="toc-text">MySQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#鸡兔同笼-70脚-20头"><span class="toc-number">7.4.</span> <span class="toc-text">鸡兔同笼 70脚 20头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个村庄-A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了-这俩村庄的男女比例"><span class="toc-number">7.5.</span> <span class="toc-text">两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g26nanhp7uj305k05k0so.jpg"></div><div class="author-info__name text-center">CayChance</div><div class="author-info__description text-center">记录一些学习中遇到的问题，以及收获</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">27</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">ChanceのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">面试小记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-12</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><h4 id="css三列布局，两边固定宽度，中间自适应"><a href="#css三列布局，两边固定宽度，中间自适应" class="headerlink" title="css三列布局，两边固定宽度，中间自适应"></a>css三列布局，两边固定宽度，中间自适应</h4><h4 id="css水平垂直居中"><a href="#css水平垂直居中" class="headerlink" title="css水平垂直居中"></a>css水平垂直居中</h4><ul><li>table-cell</li><li>absolute</li><li>transform:translate</li><li>flex</li><li>grid</li></ul><h4 id="flex-align-item-align-content的区别"><a href="#flex-align-item-align-content的区别" class="headerlink" title="flex  align-item align-content的区别"></a>flex align-item align-content的区别</h4><ul><li>容器属性<ul><li>flex-direction 主轴的方向</li><li>flex-wrap 主轴一行展示不下，如何换行</li><li>justify-content 项目在主轴上的对齐方式</li><li>align-items 项目在交叉轴上的对齐方式</li><li>align-content 多根轴线如何对齐</li></ul></li><li>项目属性<ul><li>order 项目的排列顺序 越小越靠前 默认0</li><li>flex-grow 项目的放大比例<br>默认为0 等于0不会放大。大于0，如果有剩余空间的情况下，项目1为x1，项目2为x2，则项目1占剩余空间的x1/(x1+x2)</li><li>flex-shrink 项目的缩小比例<br>默认为1 等于0不参与缩小。ul width 100px。两个li宽100px，默认每个li都会被缩小1/(1+1)=1/2。第一个li 2，第二个li 3，则第一个li被缩小2/(2+3)=2/5，被缩小的实际宽度为2/5*100=40，剩余宽度为60。第一个li 为0，如果第二个li为0，那么两者都不缩小，第二个li 大于0，那么li实际宽度，第一个li不缩小。</li><li>flex-basis 项目的占据主轴的空间 默认auto</li><li>flex-self 该项目单独的对齐方式</li></ul></li></ul><h4 id="和-代表啥"><a href="#和-代表啥" class="headerlink" title=":和::代表啥"></a>:和::代表啥</h4><ul><li>:伪类</li><li>::伪元素</li></ul><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><h4 id="基本类型和引用类型在内存中是如何存储的"><a href="#基本类型和引用类型在内存中是如何存储的" class="headerlink" title="基本类型和引用类型在内存中是如何存储的"></a>基本类型和引用类型在内存中是如何存储的</h4><ul><li>基本类型存储在栈内存</li><li>引用类型存储在堆内存 栈内存中存的是引用类型在堆内存中的地址 或者说存的是引用类型的引用</li></ul><h4 id="es6中Object的方法-Object-assign-合并对象是浅拷贝，深拷贝"><a href="#es6中Object的方法-Object-assign-合并对象是浅拷贝，深拷贝" class="headerlink" title="es6中Object的方法  Object.assign()合并对象是浅拷贝，深拷贝"></a>es6中Object的方法 Object.assign()合并对象是浅拷贝，深拷贝</h4><ul><li>浅拷贝<br>Object.assign()</li><li>深拷贝<ul><li>JSON.parse(JSON.stringify(obj))</li><li>手写一个深拷贝</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'object'</span>)&#123;</span><br><span class="line">    result = obj.constructor === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      result[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span> ? deepClone(obj[i]) : obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> result = obj;</span><br><span class="line">  <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h4><ul><li>箭头函数声明时绑定this。</li><li>普通函数执行时绑定this</li><li>箭头函数不能用于构造函数，不能使用new，不能call,apply,bind，不能当作generator函数，不能使用yield，没有arguments，没有prototype。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;</span><br><span class="line">  func:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b=a.func; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  func:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> d=c.func</span><br><span class="line"><span class="comment">//a.func 输出a本身 	b(),c.func(),c()输出window</span></span><br></pre></td></tr></table></figure><h4 id="继承-原型-原型链"><a href="#继承-原型-原型链" class="headerlink" title="继承 原型 原型链"></a>继承 原型 原型链</h4><ul><li>使用ES5实现一个继承 <strong>核心是用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'parent name:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, parentName</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, parentName);  </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = proto;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = create(Parent.prototype);</span><br><span class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'child name:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</span><br><span class="line">parent.sayName();    <span class="comment">// parent name: father</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>, <span class="string">'father'</span>);</span><br></pre></td></tr></table></figure><ul><li>ES6继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parentName,age)&#123;</span><br><span class="line">    <span class="keyword">super</span>(parentName);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><ul><li><code>new Set([1,2,3,3,4,4])</code></li></ul><h4 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h4><ul><li><code>forEach</code> <code>map</code> <code>reduce</code> <code>filter</code> <code>some</code> <code>every</code> <code>concat</code> <code>push</code> <code>pop</code> <code>unshift</code> <code>shift</code></li></ul><h4 id="for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性"><a href="#for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性" class="headerlink" title="for in,for of,for 遍历对象 缺点 只能遍历原型的属性"></a>for in,for of,for 遍历对象 缺点 只能遍历原型的属性</h4><blockquote><p>for…in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。</p></blockquote><blockquote><p>for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p></blockquote><ul><li>for in 可以遍历数组和对象。可以获取key和value。</li><li>for of 可以遍历数组，<strong>不可遍历对象</strong>。只能获取value</li><li>for循环就是遍历数组的方法。</li></ul><h4 id="如何判断一个数组"><a href="#如何判断一个数组" class="headerlink" title="如何判断一个数组"></a>如何判断一个数组</h4><ul><li><code>arr instanceof Array</code></li><li><code>arr.constructor === Array</code></li><li><code>Object.prototype.toString.call(arr)</code></li><li><code>Array.isArray(arr)</code></li></ul><h4 id="如何判断一个对象是否为空对象"><a href="#如何判断一个对象是否为空对象" class="headerlink" title="如何判断一个对象是否为空对象"></a>如何判断一个对象是否为空对象</h4><ul><li><code>for in</code></li><li><code>Object.keys()</code></li></ul><h4 id="如何判断一个类数组对象"><a href="#如何判断一个类数组对象" class="headerlink" title="如何判断一个类数组对象"></a>如何判断一个类数组对象</h4><ul><li>本质还是一个对象</li><li>有一个length属性</li></ul><h4 id="异步的处理方式都有哪些"><a href="#异步的处理方式都有哪些" class="headerlink" title="异步的处理方式都有哪些"></a>异步的处理方式都有哪些</h4><ul><li>回调函数</li><li>promise</li><li>generator</li><li>async/await</li></ul><h4 id="Promise、async-await"><a href="#Promise、async-await" class="headerlink" title="Promise、async/await"></a>Promise、async/await</h4><h4 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h4><ul><li>Promise中存在三个状态 等待态pending 执行态fullfilled 拒绝态rejected</li><li>Promise状态不可逆 pending=&gt;fullfied pending=&gt;rejected</li><li>Promise.then()方法返回一个Promise对象，因此可以链式调用</li><li>Promise接受的函数参数是同步执行的，但then方法中的回调函数则是异步的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//promise声明</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>()&#123;<span class="comment">//成功</span></span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//promise调用</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// succ</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise封装setTimeOut"><a href="#Promise封装setTimeOut" class="headerlink" title="Promise封装setTimeOut"></a>Promise封装setTimeOut</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait=<span class="function"><span class="params">time</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">y</span>=&gt;</span>setTimeout(y,time))</span><br></pre></td></tr></table></figure><h4 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h4><p>Event Loop分为<strong>浏览器中的Event Loop</strong>和<strong>Node中的Event Loop</strong></p><h4 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h4><blockquote><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p></blockquote><h4 id="Node中的Event-Loop"><a href="#Node中的Event-Loop" class="headerlink" title="Node中的Event Loop"></a>Node中的Event Loop</h4><blockquote><p>（1）V8引擎解析JavaScript脚本。<br>（2）解析后的代码，调用Node API。<br>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），任务的执行结果会以异步的方式返回给V8引擎。<br>（4）V8引擎再将结果返回给用户。</p></blockquote><h4 id="宏任务和微任务的执行顺序"><a href="#宏任务和微任务的执行顺序" class="headerlink" title="宏任务和微任务的执行顺序"></a>宏任务和微任务的执行顺序</h4><blockquote><p>（1）先执行宏任务，执行完后，查看是否有微任务队列<br>（2）如果有微任务队列，则执行微任务<br>（3）如果没有，则读取宏任务中排在最前列的任务<br>（4）执行宏任务的过程中遇到微任务，则加入微任务队列<br>（5）执行完宏任务后，查看是否有微任务队列</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">	resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 1 2 3 6 8 4 7 5</span></span><br></pre></td></tr></table></figure><h4 id="Node的执行顺序"><a href="#Node的执行顺序" class="headerlink" title="Node的执行顺序"></a>Node的执行顺序</h4><p>数据输入 =&gt; poll轮询 =&gt; check检查 =&gt; close callbacks关闭事件回调 =&gt; timers定时器 =&gt; I/O callbacks I/O事件回调 =&gt; idle prepare 闲置 =&gt; 轮询</p><h4 id="同步任务和异步任务的定义"><a href="#同步任务和异步任务的定义" class="headerlink" title="同步任务和异步任务的定义"></a>同步任务和异步任务的定义</h4><h4 id="node属于多线程还是单线程"><a href="#node属于多线程还是单线程" class="headerlink" title="node属于多线程还是单线程"></a>node属于多线程还是单线程</h4><ul><li>单线程</li></ul><h4 id="node的前端模板"><a href="#node的前端模板" class="headerlink" title="node的前端模板"></a>node的前端模板</h4><ul><li>ejs pug</li></ul><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><h4 id="call-apply-bind的区别-手写？"><a href="#call-apply-bind的区别-手写？" class="headerlink" title="call apply bind的区别 手写？"></a>call apply bind的区别 手写？</h4><ul><li>三者都是改变this的指向。</li><li>区别call，apply返回函数执行的结果，bind则返回一个函数</li><li>其中call的参数是展开的数据，apply的参数是数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">let</span> arfs = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> bindFn ? <span class="keyword">this</span> : context,args.concat(...arguments));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tem</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  tem.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFn.prototype = <span class="keyword">new</span> tem();</span><br><span class="line">  <span class="keyword">return</span> bindFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="new发生了什么"><a href="#new发生了什么" class="headerlink" title="new发生了什么"></a>new发生了什么</h4><ul><li>新建一个新对象</li><li>this指向新对象</li><li>为新对象添加属性</li><li>返回新对象</li></ul><h4 id="函数递归-f-n-返回1到n的累加和"><a href="#函数递归-f-n-返回1到n的累加和" class="headerlink" title="函数递归 f(n) 返回1到n的累加和"></a>函数递归 f(n) 返回1到n的累加和</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        result = n+sum(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        result = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">n</span>=&gt;</span>n&gt;<span class="number">1</span> ? n+sum(n<span class="number">-1</span>) : n;</span><br></pre></td></tr></table></figure><h4 id="SSR-Nuxt-Next"><a href="#SSR-Nuxt-Next" class="headerlink" title="SSR Nuxt Next"></a>SSR Nuxt Next</h4><ul><li>服务器端渲染</li></ul><h3 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h3><h4 id="Vue提倡的是单向数据流，但是v-model是双向数据流，为什么"><a href="#Vue提倡的是单向数据流，但是v-model是双向数据流，为什么" class="headerlink" title="Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?"></a>Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?</h4><ul><li>v-model只是一个语法糖，本质还是单向数据流</li></ul><h4 id="vue-use"><a href="#vue-use" class="headerlink" title="vue.use()"></a>vue.use()</h4><p>全局注入一个插件</p><h4 id="Vue双向绑定"><a href="#Vue双向绑定" class="headerlink" title="Vue双向绑定"></a>Vue双向绑定</h4><p>object.defineproperty()修改get和set+发布订阅模式</p><h4 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue router"></a>Vue router</h4><ul><li>主要有两种模式 <strong>hash模式</strong> <strong>history模式</strong></li><li><strong>本质</strong>就是监听url的变化，然后匹配路由规则，显示相应的页面，并且无需刷新</li><li>hash模式 点击跳转通过hashchange事件来监听到url的变化 手动刷新通过load事件</li><li>history模式 点击跳转通过pushState 浏览器动作 回退等 popState 刷新或者输入url 会向服务器发送请求 <strong>需要后端配合重定向</strong></li></ul><h4 id="Vuex数据周期"><a href="#Vuex数据周期" class="headerlink" title="Vuex数据周期"></a>Vuex数据周期</h4><p>state – dispatch –&gt; actions – commit –&gt; mutations</p><h4 id="vue-nextTick的原理-如何找到dom-依赖收集过程"><a href="#vue-nextTick的原理-如何找到dom-依赖收集过程" class="headerlink" title="vue.nextTick的原理 如何找到dom 依赖收集过程"></a>vue.nextTick的原理 如何找到dom 依赖收集过程</h4><ul><li>nextTick是Vue的一个全局函数，用于处理dom更新操作。Vue里面有一个watcher，用于观察数据的变化，然后更新dom。Vue里面并不是每次数据变化都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom操作。</li><li>watch的实现，当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</li><li>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</li><li>Vue是异步执行dom更新的</li><li>Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</li></ul><h4 id="virtual-dom-diff算法具体实现过程"><a href="#virtual-dom-diff算法具体实现过程" class="headerlink" title="virtual-dom    diff算法具体实现过程"></a>virtual-dom diff算法具体实现过程</h4><ul><li>diff算法源于snabbdom，复杂度为O(n)</li><li>只会在同层级比较，不会跨层级比较</li><li>重点是patch方法</li></ul><h4 id="patch方法详解"><a href="#patch方法详解" class="headerlink" title="patch方法详解"></a>patch方法详解</h4><p>注释：vnode：新的虚拟节点 oldVnode：旧的虚拟节点</p><blockquote><blockquote></blockquote><ul><li>vnode不存在但是oldVnode存在，需要销毁oldVnode</li><li>oldVnode不存在但是vnode存在，创建新节点</li><li>oldVnode和vnode都存在<br>3.1 oldVnode和vnode是同一个节点 执行patchVnode方法<br>3.2 vnode创建真实dom并替换oldVnode.elm</li></ul></blockquote><h4 id="patchVnode方法详解"><a href="#patchVnode方法详解" class="headerlink" title="patchVnode方法详解"></a>patchVnode方法详解</h4><blockquote><blockquote></blockquote><ul><li>oldVnode和vnode完全一致，则不需要做任何事情</li><li>oldVnode和vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上即可</li><li>vnode不是文本节点或注释节点<br>3.1 如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行updateChildren方法<br>3.2 只有oldVnode有子节点，那就把这些节点都删除<br>3.3 如果只有vnode有子节点，那就创建这些子节点<br>3.4 如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串</li><li>vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</li></ul></blockquote><h4 id="updateChildren方法详解"><a href="#updateChildren方法详解" class="headerlink" title="updateChildren方法详解"></a>updateChildren方法详解</h4><blockquote><blockquote></blockquote><ul><li>oldStartIdx&gt;oldEndIdx<br>oldCh已经遍历完了，但是newCh还没有，把newStartIdx-newEndIdx之间的vnode都是新增的，把这些vnode添加到oldCh末尾</li><li>newStartIdx&gt;newEndIdx<br>newCh已经遍历完了，但是oldCh还没有，把oldCh中oldStartIdx-oldEndIdx之间的vnode删除</li><li>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx<br>3.1 oldVnode第一个child不存在，oldStart索引右移<br>3.2 oldVnode最后一个child不存在，oldEnd索引左移<br>3.3 oldStartVnode和newStartVnode是同一个节点，patchVnode两个节点，索引右移<br>3.4 oldEndVnode和newEndVnode是同一个节点，patchVnode两个节点，索引左移<br>3.5 oldStartVnode和newEndVnode是同一个节点，移动oldStartVnode到oldEndVnode节点后面<br>3.6 oldEndVnode和newStartVnode是同一个节点，移动oldEndVnode到oldStartVnode前面<br>3.7 oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点<br>3.8 如果找到了相同key的节点，比较两个节点是否属于同一个节点，如果属于同一节点，就patchVnode，否则新创建节点</li></ul></blockquote><h4 id="为什么要使用key？"><a href="#为什么要使用key？" class="headerlink" title="为什么要使用key？"></a>为什么要使用key？</h4><p>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><h4 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h4><ul><li>axios.interceptors.request.use</li><li>axios.interceptors.response.use</li><li>axios.default.header</li></ul><h3 id="Wepack以及项目优化"><a href="#Wepack以及项目优化" class="headerlink" title="Wepack以及项目优化"></a>Wepack以及项目优化</h3><h4 id="webpack热更新的模块"><a href="#webpack热更新的模块" class="headerlink" title="webpack热更新的模块"></a>webpack热更新的模块</h4><ul><li>HotModuleReplacementPlugin</li></ul><h4 id="webpack配置压缩一个js如何配置"><a href="#webpack配置压缩一个js如何配置" class="headerlink" title="webpack配置压缩一个js如何配置"></a>webpack配置压缩一个js如何配置</h4><ul><li>webpack.base.conf.js entry output module loaders</li></ul><h4 id="webpack编译后图片名为什么会改变"><a href="#webpack编译后图片名为什么会改变" class="headerlink" title="webpack编译后图片名为什么会改变"></a>webpack编译后图片名为什么会改变</h4><h3 id="浏览器及安全"><a href="#浏览器及安全" class="headerlink" title="浏览器及安全"></a>浏览器及安全</h3><h4 id="浏览器中支持最大的请求并发数"><a href="#浏览器中支持最大的请求并发数" class="headerlink" title="浏览器中支持最大的请求并发数"></a>浏览器中支持最大的请求并发数</h4><h4 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h4><ul><li>stopPropagation</li><li>cancelBubble</li></ul><h4 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h4><h4 id="chrome跨标签通信"><a href="#chrome跨标签通信" class="headerlink" title="chrome跨标签通信"></a>chrome跨标签通信</h4><ul><li>获取句柄 postMessage</li><li>localStorage</li></ul><h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><ul><li>jsonp</li><li>CORS</li><li>WebSocket</li><li>Nginx代理</li><li>Node中间件代理 <code>http-proxy-middleware</code> <code>proxy-middleware</code></li></ul><h4 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h4><ul><li>强制缓存</li><li>协商缓存</li><li>先判断是否命中强缓存，如果命中，则不请求服务器，直接从缓存中返回数据；</li><li>如果未命中，则向服务器发送一个请求，再判断是否命中协商缓存，如果命中，更新缓存，然后缓存中返回数据</li><li>如果均未命中，则向服务器发送请求，服务器返回数据。</li></ul><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><ul><li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li><li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li><li>进程是一个工厂，拥有独立的资源（独立的一块内存），进程之间相互独立，工厂中有一个或者多个工人（一个进程由一个或者多个线程组成）。</li><li>线程是工厂中的工人，工人共享空间（同一进程下的各个线程之间共享程序的内存空间）</li></ul><h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><ul><li>1** 信息类</li><li>2** 成功</li><li>3** 重定向类 301永久重定向 302临时重定向</li><li>4** 客户端出错</li><li>5** 服务器出错</li></ul><h4 id="HTTP常见请求方法以及简单描述"><a href="#HTTP常见请求方法以及简单描述" class="headerlink" title="HTTP常见请求方法以及简单描述"></a>HTTP常见请求方法以及简单描述</h4><h4 id="Http-header中都有哪些信息"><a href="#Http-header中都有哪些信息" class="headerlink" title="Http header中都有哪些信息"></a>Http header中都有哪些信息</h4><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul><li>expires 过期时间</li><li>domain 域名</li><li>path 路径</li><li>security 安全情况下才传输给服务器 https</li><li>httponly js是否可以操作</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h4><h4 id="快排的时间复杂度和空间复杂度"><a href="#快排的时间复杂度和空间复杂度" class="headerlink" title="快排的时间复杂度和空间复杂度"></a>快排的时间复杂度和空间复杂度</h4><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;a.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;a.length-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">      [a[j],a[j+<span class="number">1</span>]] = [a[j+<span class="number">1</span>],a[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="项目优化的点"><a href="#项目优化的点" class="headerlink" title="项目优化的点"></a>项目优化的点</h4><ul><li>html标签语义化</li><li>高效的css</li><li>图片压缩，尽可能不用图片</li><li>js等代码优化</li><li>减少http请求</li><li>打包后的代码压缩</li><li>PWA</li><li>webpack按需加载</li><li>cdn</li><li>骨架屏</li></ul><h4 id="项目中做过比较复杂的东西如何解决"><a href="#项目中做过比较复杂的东西如何解决" class="headerlink" title="项目中做过比较复杂的东西如何解决"></a>项目中做过比较复杂的东西如何解决</h4><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><h4 id="鸡兔同笼-70脚-20头"><a href="#鸡兔同笼-70脚-20头" class="headerlink" title="鸡兔同笼 70脚 20头"></a>鸡兔同笼 70脚 20头</h4><ul><li>20只动物都收起两只脚，这个时候，就剩下了30只脚</li><li>30只脚全是兔子的，这个时候每只兔子只有2只脚，所以有15个兔子</li></ul><h4 id="两个村庄-A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了-这俩村庄的男女比例"><a href="#两个村庄-A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了-这俩村庄的男女比例" class="headerlink" title="两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例"></a>两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例</h4></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:chance17610999610@gmail.com">CayChance</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://caychance.github.io/2019/04/13/面试小记/">https://caychance.github.io/2019/04/13/面试小记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://caychance.github.io">ChanceのBlog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/04/03/diff算法/"><span>diff算法</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By CayChance</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script></body></html>