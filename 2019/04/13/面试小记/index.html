<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="面试小记"><meta name="keywords" content><meta name="author" content="CayChance,chance17610999610@gmail.com"><meta name="copyright" content="CayChance"><title>面试小记 | ChanceのBlog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS部分"><span class="toc-number">1.</span> <span class="toc-text">CSS部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css三列布局，两边固定宽度，中间自适应"><span class="toc-number">1.1.</span> <span class="toc-text">css三列布局，两边固定宽度，中间自适应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两栏布局-至少三种，float-absolute-flex"><span class="toc-number">1.2.</span> <span class="toc-text">两栏布局(至少三种，float/absolute/flex)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三栏布局-双飞翼-圣杯-flex"><span class="toc-number">1.3.</span> <span class="toc-text">三栏布局(双飞翼/圣杯/flex)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC-产生条件、用途"><span class="toc-number">1.4.</span> <span class="toc-text">BFC(产生条件、用途)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用border画一个半圆-三角形"><span class="toc-number">1.5.</span> <span class="toc-text">用border画一个半圆/三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#弹出框"><span class="toc-number">1.6.</span> <span class="toc-text">弹出框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现向内旋转的效果-transform-rotateY"><span class="toc-number">1.7.</span> <span class="toc-text">实现向内旋转的效果(transform: rotateY)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css3如何开启动画的GPU加速-translate3d-0-0-0"><span class="toc-number">1.8.</span> <span class="toc-text">css3如何开启动画的GPU加速(translate3d(0, 0, 0))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行内元素padding-margin有用吗"><span class="toc-number">1.9.</span> <span class="toc-text">行内元素padding margin有用吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#盒模型有哪两种，区别是啥"><span class="toc-number">1.10.</span> <span class="toc-text">盒模型有哪两种，区别是啥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用移动端适配方案，border-1px在dpr比较大的手机上咋解决"><span class="toc-number">1.11.</span> <span class="toc-text">常用移动端适配方案，border 1px在dpr比较大的手机上咋解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css水平垂直居中"><span class="toc-number">1.12.</span> <span class="toc-text">css水平垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex-align-item-align-content的区别"><span class="toc-number">1.13.</span> <span class="toc-text">flex align-item align-content的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单行，多行文本超出省略号"><span class="toc-number">1.14.</span> <span class="toc-text">单行，多行文本超出省略号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和-代表啥"><span class="toc-number">1.15.</span> <span class="toc-text">:和::代表啥</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS部分"><span class="toc-number">2.</span> <span class="toc-text">JS部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型和引用类型在内存中是如何存储的"><span class="toc-number">2.1.</span> <span class="toc-text">基本类型和引用类型在内存中是如何存储的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件委托和事件代理"><span class="toc-number">2.2.</span> <span class="toc-text">事件委托和事件代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包-会导致的问题-如何解决"><span class="toc-number">2.3.</span> <span class="toc-text">闭包 会导致的问题 如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js的垃圾回收机制"><span class="toc-number">2.4.</span> <span class="toc-text">js的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原生的ajax"><span class="toc-number">2.5.</span> <span class="toc-text">原生的ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-onload和document-onload的区别"><span class="toc-number">2.6.</span> <span class="toc-text">window.onload和document.onload的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#match方法实现，支持-和-通配符"><span class="toc-number">2.7.</span> <span class="toc-text">match方法实现，支持?和*通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6模块和CommonJs模块的区别"><span class="toc-number">2.8.</span> <span class="toc-text">ES6模块和CommonJs模块的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6新特性列举几个"><span class="toc-number">2.9.</span> <span class="toc-text">es6新特性列举几个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var-let-const-区别"><span class="toc-number">2.10.</span> <span class="toc-text">var/let/const 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6中Object的方法-Object-assign-合并对象是浅拷贝，深拷贝"><span class="toc-number">2.11.</span> <span class="toc-text">es6中Object的方法 Object.assign()合并对象是浅拷贝，深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6模板字符串如何实现"><span class="toc-number">2.12.</span> <span class="toc-text">es6模板字符串如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#箭头函数和普通函数的区别"><span class="toc-number">2.13.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承-原型-原型链"><span class="toc-number">2.14.</span> <span class="toc-text">继承 原型 原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组去重"><span class="toc-number">2.15.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的方法"><span class="toc-number">2.16.</span> <span class="toc-text">数组的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性"><span class="toc-number">2.17.</span> <span class="toc-text">for in/for of/for 遍历对象 缺点 只能遍历原型的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断一个数组"><span class="toc-number">2.18.</span> <span class="toc-text">如何判断一个数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断一个对象是否为空对象"><span class="toc-number">2.19.</span> <span class="toc-text">如何判断一个对象是否为空对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断一个类数组对象"><span class="toc-number">2.20.</span> <span class="toc-text">如何判断一个类数组对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步的处理方式都有哪些"><span class="toc-number">2.21.</span> <span class="toc-text">异步的处理方式都有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise和async-await"><span class="toc-number">2.22.</span> <span class="toc-text">Promise和async/await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise原理-手写"><span class="toc-number">2.23.</span> <span class="toc-text">Promise原理 手写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise封装setTimeOut"><span class="toc-number">2.24.</span> <span class="toc-text">Promise封装setTimeOut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await"><span class="toc-number">2.25.</span> <span class="toc-text">async/await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-Loop"><span class="toc-number">2.26.</span> <span class="toc-text">Event Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器中的Event-Loop"><span class="toc-number">2.27.</span> <span class="toc-text">浏览器中的Event Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node中的Event-Loop"><span class="toc-number">2.28.</span> <span class="toc-text">Node中的Event Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宏任务和微任务的执行顺序"><span class="toc-number">2.29.</span> <span class="toc-text">宏任务和微任务的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的宏任务和微任务"><span class="toc-number">2.30.</span> <span class="toc-text">常见的宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node的执行顺序"><span class="toc-number">2.31.</span> <span class="toc-text">Node的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步任务和异步任务的定义"><span class="toc-number">2.32.</span> <span class="toc-text">同步任务和异步任务的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node属于多线程还是单线程"><span class="toc-number">2.33.</span> <span class="toc-text">node属于多线程还是单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node的前端模板"><span class="toc-number">2.34.</span> <span class="toc-text">node的前端模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#process"><span class="toc-number">2.35.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-apply-bind的区别-手写？"><span class="toc-number">2.36.</span> <span class="toc-text">call apply bind的区别 手写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new发生了什么"><span class="toc-number">2.37.</span> <span class="toc-text">new发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数递归-f-n-返回1到n的累加和"><span class="toc-number">2.38.</span> <span class="toc-text">函数递归 f(n) 返回1到n的累加和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSR-Nuxt-Next"><span class="toc-number">2.39.</span> <span class="toc-text">SSR Nuxt Next</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则"><span class="toc-number">2.40.</span> <span class="toc-text">正则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceOf-Object-create-new的实现原理"><span class="toc-number">2.41.</span> <span class="toc-text">instanceOf/Object.create/new的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#已知"><span class="toc-number">2.42.</span> <span class="toc-text">已知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求以下输出"><span class="toc-number">2.43.</span> <span class="toc-text">求以下输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手写一个div的拖拽功能"><span class="toc-number">2.44.</span> <span class="toc-text">手写一个div的拖拽功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写一个工厂函数用于生成对象"><span class="toc-number">2.45.</span> <span class="toc-text">写一个工厂函数用于生成对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的手写"><span class="toc-number">2.46.</span> <span class="toc-text">常用的手写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue部分"><span class="toc-number">3.</span> <span class="toc-text">Vue部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-number">3.1.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单向数据流"><span class="toc-number">3.2.</span> <span class="toc-text">单向数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue提倡的是单向数据流，但是v-model是双向数据流，为什么"><span class="toc-number">3.3.</span> <span class="toc-text">Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-use"><span class="toc-number">3.4.</span> <span class="toc-text">vue.use()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue双向绑定实现原理-数据响应系统原理"><span class="toc-number">3.5.</span> <span class="toc-text">Vue双向绑定实现原理/数据响应系统原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue中，数组的操作是如何实现数据响应的-push等原型函数以及为什么用-set"><span class="toc-number">3.6.</span> <span class="toc-text">Vue中，数组的操作是如何实现数据响应的(push等原型函数以及为什么用$set)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信"><span class="toc-number">3.7.</span> <span class="toc-text">Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-3有哪些新的东西知道吗"><span class="toc-number">3.8.</span> <span class="toc-text">vue 3有哪些新的东西知道吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以下代码经过模板渲染后变成了什么样子简单讲一下"><span class="toc-number">3.9.</span> <span class="toc-text">以下代码经过模板渲染后变成了什么样子简单讲一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#provide-inject能解决什么问题"><span class="toc-number">3.10.</span> <span class="toc-text">provide/inject能解决什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed和props-data的区别，其实现原理是什么"><span class="toc-number">3.11.</span> <span class="toc-text">computed和props/data的区别，其实现原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-Router"><span class="toc-number">3.12.</span> <span class="toc-text">Vue Router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-Router中query和param的区别"><span class="toc-number">3.13.</span> <span class="toc-text">Vue Router中query和param的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex数据周期-如何使用-有什么好处"><span class="toc-number">3.14.</span> <span class="toc-text">Vuex数据周期 如何使用 有什么好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-nextTick的原理-如何找到dom-依赖收集过程"><span class="toc-number">3.15.</span> <span class="toc-text">vue.nextTick的原理 如何找到dom 依赖收集过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual-dom-diff算法具体实现过程"><span class="toc-number">3.16.</span> <span class="toc-text">virtual-dom diff算法具体实现过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch方法详解"><span class="toc-number">3.17.</span> <span class="toc-text">patch方法详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patchVnode方法详解"><span class="toc-number">3.18.</span> <span class="toc-text">patchVnode方法详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updateChildren方法详解"><span class="toc-number">3.19.</span> <span class="toc-text">updateChildren方法详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用key？"><span class="toc-number">3.20.</span> <span class="toc-text">为什么要使用key？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-React-Angular区别"><span class="toc-number">3.21.</span> <span class="toc-text">Vue,React,Angular区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue多端框架"><span class="toc-number">3.22.</span> <span class="toc-text">Vue多端框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios-拦截器"><span class="toc-number">3.23.</span> <span class="toc-text">axios 拦截器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wepack以及项目优化"><span class="toc-number">4.</span> <span class="toc-text">Wepack以及项目优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack打包原理"><span class="toc-number">4.1.</span> <span class="toc-text">webpack打包原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#module和chunk的区别"><span class="toc-number">4.2.</span> <span class="toc-text">module和chunk的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loader和plugin的区别"><span class="toc-number">4.3.</span> <span class="toc-text">loader和plugin的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-4相比3有什么变化"><span class="toc-number">4.4.</span> <span class="toc-text">webpack 4相比3有什么变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack构建速度优化有哪些方式-这个能扯半个小时"><span class="toc-number">4.5.</span> <span class="toc-text">webpack构建速度优化有哪些方式(这个能扯半个小时)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tree-shaking-scope-hoisting-code-spliting-都有什么作用"><span class="toc-number">4.6.</span> <span class="toc-text">tree-shaking/scope-hoisting/code-spliting 都有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack热更新的模块"><span class="toc-number">4.7.</span> <span class="toc-text">webpack热更新的模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack配置压缩一个js如何配置"><span class="toc-number">4.8.</span> <span class="toc-text">webpack配置压缩一个js如何配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack编译后图片名为什么会改变"><span class="toc-number">4.9.</span> <span class="toc-text">webpack编译后图片名为什么会改变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器及安全"><span class="toc-number">5.</span> <span class="toc-text">浏览器及安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器中支持最大的请求并发数"><span class="toc-number">5.1.</span> <span class="toc-text">浏览器中支持最大的请求并发数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻止冒泡"><span class="toc-number">5.2.</span> <span class="toc-text">阻止冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的浏览器安全问题"><span class="toc-number">5.3.</span> <span class="toc-text">常见的浏览器安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chrome跨标签通信"><span class="toc-number">5.4.</span> <span class="toc-text">chrome跨标签通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨域"><span class="toc-number">5.5.</span> <span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入网址回车之后浏览器做了什么"><span class="toc-number">5.6.</span> <span class="toc-text">输入网址回车之后浏览器做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程"><span class="toc-number">5.7.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome是多进程吗，为什么是多进程而不是多线程，包括哪些进程"><span class="toc-number">5.8.</span> <span class="toc-text">Chrome是多进程吗，为什么是多进程而不是多线程，包括哪些进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器多进程的优势"><span class="toc-number">5.9.</span> <span class="toc-text">浏览器多进程的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome-渲染-render-进程包含哪些线程"><span class="toc-number">5.10.</span> <span class="toc-text">Chrome 渲染(render)进程包含哪些线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome是如何实现setTimout的"><span class="toc-number">5.11.</span> <span class="toc-text">Chrome是如何实现setTimout的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何监控前端性能"><span class="toc-number">5.12.</span> <span class="toc-text">如何监控前端性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前端性能优化"><span class="toc-number">5.13.</span> <span class="toc-text">前端性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器缓存机制"><span class="toc-number">5.14.</span> <span class="toc-text">浏览器缓存机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络相关"><span class="toc-number">6.</span> <span class="toc-text">网络相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Http状态码"><span class="toc-number">6.1.</span> <span class="toc-text">Http状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http常见请求方法以及简单描述"><span class="toc-number">6.2.</span> <span class="toc-text">Http常见请求方法以及简单描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http-header中都有哪些信息"><span class="toc-number">6.3.</span> <span class="toc-text">Http header中都有哪些信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http和Https的区别"><span class="toc-number">6.4.</span> <span class="toc-text">Http和Https的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP三次握手过程"><span class="toc-number">6.5.</span> <span class="toc-text">TCP三次握手过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP三次握手-四次挥手区别"><span class="toc-number">6.6.</span> <span class="toc-text">TCP三次握手/四次挥手区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么TCP建立连接是三次而关闭连接要多一次"><span class="toc-number">6.7.</span> <span class="toc-text">为什么TCP建立连接是三次而关闭连接要多一次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Https认证过程"><span class="toc-number">6.8.</span> <span class="toc-text">Https认证过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP2相比HTTP1多了什么"><span class="toc-number">6.9.</span> <span class="toc-text">HTTP2相比HTTP1多了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP2的多路复用和HTTP-1-1的keep-alive有什么区别"><span class="toc-number">6.10.</span> <span class="toc-text">HTTP2的多路复用和HTTP 1.1的keep-alive有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">6.11.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket是如何建立连接的"><span class="toc-number">6.12.</span> <span class="toc-text">websocket是如何建立连接的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-number">7.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#递归的复杂度"><span class="toc-number">7.1.</span> <span class="toc-text">递归的复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快排的时间复杂度和空间复杂度"><span class="toc-number">7.2.</span> <span class="toc-text">快排的时间复杂度和空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">7.3.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给个数组和n，找到数组里的三个数相加是n，复杂度要求O-n-2-logn"><span class="toc-number">7.4.</span> <span class="toc-text">给个数组和n，找到数组里的三个数相加是n，复杂度要求O(n^2*logn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对数组-2-3-3-2-5-进行多重相邻去重-第一次去重后结果-2-2-5-，然后得到-5-，复杂度要求O-n"><span class="toc-number">7.5.</span> <span class="toc-text">对数组[2, 3, 3, 2, 5]进行多重相邻去重(第一次去重后结果[2, 2, 5]，然后得到[ 5 ])，复杂度要求O(n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n"><span class="toc-number">7.6.</span> <span class="toc-text">给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层"><span class="toc-number">7.7.</span> <span class="toc-text">给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树广度优先遍历"><span class="toc-number">7.8.</span> <span class="toc-text">二叉树广度优先遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止"><span class="toc-number">7.9.</span> <span class="toc-text">给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个二维数组，如-0-0-0-1-0-0-0-1-0-，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径"><span class="toc-number">7.10.</span> <span class="toc-text">给一个二维数组，如[[0, 0, 0], [1, 0, 0], [0, 1, 0]]，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反转链表"><span class="toc-number">7.11.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组类"><span class="toc-number">7.12.</span> <span class="toc-text">数组类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">8.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#项目优化的点"><span class="toc-number">8.1.</span> <span class="toc-text">项目优化的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#项目中做过比较复杂的东西如何解决"><span class="toc-number">8.2.</span> <span class="toc-text">项目中做过比较复杂的东西如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL"><span class="toc-number">8.3.</span> <span class="toc-text">MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#鸡兔同笼-70脚-20头"><span class="toc-number">8.4.</span> <span class="toc-text">鸡兔同笼 70脚 20头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个村庄-A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了-这俩村庄的男女比例"><span class="toc-number">8.5.</span> <span class="toc-text">两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#推荐几个链接"><span class="toc-number">8.6.</span> <span class="toc-text">推荐几个链接</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g26nanhp7uj305k05k0so.jpg"></div><div class="author-info__name text-center">CayChance</div><div class="author-info__description text-center">记录一些学习中遇到的问题，以及收获</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">28</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://ws2.sinaimg.cn/large/006tNc79ly1g289wvlhyej31hc0u0q7i.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">ChanceのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">面试小记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-12</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="css三列布局，两边固定宽度，中间自适应"><a href="#css三列布局，两边固定宽度，中间自适应" class="headerlink" title="css三列布局，两边固定宽度，中间自适应"></a>css三列布局，两边固定宽度，中间自适应</h3><h3 id="两栏布局-至少三种，float-absolute-flex"><a href="#两栏布局-至少三种，float-absolute-flex" class="headerlink" title="两栏布局(至少三种，float/absolute/flex)"></a>两栏布局(至少三种，float/absolute/flex)</h3><h3 id="三栏布局-双飞翼-圣杯-flex"><a href="#三栏布局-双飞翼-圣杯-flex" class="headerlink" title="三栏布局(双飞翼/圣杯/flex)"></a>三栏布局(双飞翼/圣杯/flex)</h3><h3 id="BFC-产生条件、用途"><a href="#BFC-产生条件、用途" class="headerlink" title="BFC(产生条件、用途)"></a>BFC(产生条件、用途)</h3><p>产生条件：</p><ul><li>body根元素</li><li>float元素 float不等于none</li><li>绝对定位 absolute fixed</li><li>display等于inline-block、table-cells、flex</li><li>overflow除了visible以外的值hidden、auto、scroll</li></ul><p>BFC的用途/特性：</p><ul><li>同一个BFC中的margin会重叠</li><li>浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。</li><li>BFC可以阻止元素被浮动元素覆盖。</li></ul><h3 id="用border画一个半圆-三角形"><a href="#用border画一个半圆-三角形" class="headerlink" title="用border画一个半圆/三角形"></a>用border画一个半圆/三角形</h3><ul><li>三角形</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">border-top</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">blue</span>;</span><br><span class="line"><span class="selector-tag">border-right</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line"><span class="selector-tag">border-bottom</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">green</span>;</span><br><span class="line"><span class="selector-tag">border-left</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">yellow</span>;</span><br></pre></td></tr></table></figure><ul><li>半圆</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-radius</span>: 50<span class="selector-tag">px</span> 50<span class="selector-tag">px</span> 0 0;</span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">pink</span>;</span><br></pre></td></tr></table></figure><h3 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h3><h3 id="实现向内旋转的效果-transform-rotateY"><a href="#实现向内旋转的效果-transform-rotateY" class="headerlink" title="实现向内旋转的效果(transform: rotateY)"></a>实现向内旋转的效果(transform: rotateY)</h3><h3 id="css3如何开启动画的GPU加速-translate3d-0-0-0"><a href="#css3如何开启动画的GPU加速-translate3d-0-0-0" class="headerlink" title="css3如何开启动画的GPU加速(translate3d(0, 0, 0))"></a>css3如何开启动画的GPU加速(translate3d(0, 0, 0))</h3><h3 id="行内元素padding-margin有用吗"><a href="#行内元素padding-margin有用吗" class="headerlink" title="行内元素padding margin有用吗"></a>行内元素padding margin有用吗</h3><ul><li>padding有用</li><li>margin左右有用，上下无效。</li></ul><h3 id="盒模型有哪两种，区别是啥"><a href="#盒模型有哪两种，区别是啥" class="headerlink" title="盒模型有哪两种，区别是啥"></a>盒模型有哪两种，区别是啥</h3><ul><li>IE盒模型 border-box<br>width = content宽度+padding+border</li><li>W3C盒模型 content-box<br>width = content宽度</li></ul><h3 id="常用移动端适配方案，border-1px在dpr比较大的手机上咋解决"><a href="#常用移动端适配方案，border-1px在dpr比较大的手机上咋解决" class="headerlink" title="常用移动端适配方案，border 1px在dpr比较大的手机上咋解决"></a>常用移动端适配方案，border 1px在dpr比较大的手机上咋解决</h3><ul><li><a href="https://juejin.im/post/5c0dd7ac6fb9a049c43d7edc" target="_blank" rel="noopener">掘金-移动端适配总结</a> 感觉这篇文章里的适配代码是个无敌的答案</li></ul><h3 id="css水平垂直居中"><a href="#css水平垂直居中" class="headerlink" title="css水平垂直居中"></a>css水平垂直居中</h3><ul><li>table-cell</li><li>absolute</li><li>transform:translate</li><li>flex</li><li>grid</li></ul><h3 id="flex-align-item-align-content的区别"><a href="#flex-align-item-align-content的区别" class="headerlink" title="flex  align-item align-content的区别"></a>flex align-item align-content的区别</h3><ul><li>容器属性<ul><li>flex-direction 主轴的方向</li><li>flex-wrap 主轴一行展示不下，如何换行</li><li>justify-content 项目在主轴上的对齐方式</li><li>align-items 项目在交叉轴上的对齐方式</li><li>align-content 多根轴线如何对齐</li></ul></li><li>项目属性<ul><li>order 项目的排列顺序 越小越靠前 默认0</li><li>flex-grow 项目的放大比例<br>默认为0 等于0不会放大。大于0，如果有剩余空间的情况下，项目1为x1，项目2为x2，则项目1占剩余空间的x1/(x1+x2)</li><li>flex-shrink 项目的缩小比例<br>默认为1 等于0不参与缩小。ul width 100px。两个li宽100px，默认每个li都会被缩小1/(1+1)=1/2。第一个li 2，第二个li 3，则第一个li被缩小2/(2+3)=2/5，被缩小的实际宽度为2/5*100=40，剩余宽度为60。第一个li 为0，如果第二个li为0，那么两者都不缩小，第二个li 大于0，那么li实际宽度，第一个li不缩小。</li><li>flex-basis 项目的占据主轴的空间 默认auto</li><li>flex-self 该项目单独的对齐方式</li></ul></li></ul><h3 id="单行，多行文本超出省略号"><a href="#单行，多行文本超出省略号" class="headerlink" title="单行，多行文本超出省略号"></a>单行，多行文本超出省略号</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><h3 id="和-代表啥"><a href="#和-代表啥" class="headerlink" title=":和::代表啥"></a>:和::代表啥</h3><ul><li>:伪类</li><li>::伪元素</li></ul><h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><h3 id="基本类型和引用类型在内存中是如何存储的"><a href="#基本类型和引用类型在内存中是如何存储的" class="headerlink" title="基本类型和引用类型在内存中是如何存储的"></a>基本类型和引用类型在内存中是如何存储的</h3><ul><li>基本类型存储在栈内存</li><li>引用类型存储在堆内存 栈内存中存的是引用类型在堆内存中的地址 或者说存的是引用类型的引用</li></ul><h3 id="事件委托和事件代理"><a href="#事件委托和事件代理" class="headerlink" title="事件委托和事件代理"></a>事件委托和事件代理</h3><p>一个ul里面有很多个li的时候，如果想让每个li都有一个点击事件，不需要给每个li都去添加，只需要给ul添加一个就行了。</p><p>利用事件冒泡的原理。</p><h3 id="闭包-会导致的问题-如何解决"><a href="#闭包-会导致的问题-如何解决" class="headerlink" title="闭包 会导致的问题 如何解决"></a>闭包 会导致的问题 如何解决</h3><p>闭包使用不当会导致内存溢出。因此，在退出函数之前，将不使用的局部变量全部删除。</p><h3 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a>js的垃圾回收机制</h3><ul><li>引用计数垃圾收集<br>概念：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放；<br>缺点：该算法有一个限制——循环引用。</li><li>标记-清除垃圾回收算法<br>2012年起，所有现代浏览器都是用了该算法</li></ul><h3 id="原生的ajax"><a href="#原生的ajax" class="headerlink" title="原生的ajax"></a>原生的ajax</h3><p>XMLHttp​Request</p><h3 id="window-onload和document-onload的区别"><a href="#window-onload和document-onload的区别" class="headerlink" title="window.onload和document.onload的区别"></a>window.onload和document.onload的区别</h3><h3 id="match方法实现，支持-和-通配符"><a href="#match方法实现，支持-和-通配符" class="headerlink" title="match方法实现，支持?和*通配符"></a>match方法实现，支持?和*通配符</h3><h3 id="ES6模块和CommonJs模块的区别"><a href="#ES6模块和CommonJs模块的区别" class="headerlink" title="ES6模块和CommonJs模块的区别"></a>ES6模块和CommonJs模块的区别</h3><ul><li>commonJs是被加载的时候运行，es6是编译的时候运行</li><li>commonJs输出的是值的浅拷贝，es6输出值的引用</li><li>commentJs具有缓存。在第一次被加载时，会完整运行整个文件并输出一个对象，拷贝（浅拷贝）在内存中。下次加载文件时，直接从内存中取值</li><li>参考链接<br><a href="https://juejin.im/post/5ae04fba6fb9a07acb3c8ac5" target="_blank" rel="noopener">掘金-CommonJs 和 ESModule 的 区别整理</a><br><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html" target="_blank" rel="noopener">JavaScript 模块的循环加载</a></li></ul><h3 id="es6新特性列举几个"><a href="#es6新特性列举几个" class="headerlink" title="es6新特性列举几个"></a>es6新特性列举几个</h3><p><code>let/const</code>，<code>箭头函数</code>，<code>解构</code>，<code>模板字符串</code>，<code>Promise</code>，<code>Class</code></p><h3 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var/let/const 区别"></a>var/let/const 区别</h3><table><thead><tr><th style="text-align:center">声明方式</th><th style="text-align:center">变量提升</th><th style="text-align:center">重复声明</th><th style="text-align:center">暂时性死区</th><th style="text-align:center">初始值</th><th style="text-align:center">作用域</th></tr></thead><tbody><tr><td style="text-align:center">var</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">不存在</td><td style="text-align:center">不需要</td><td style="text-align:center">除块级</td></tr><tr><td style="text-align:center">let</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">存在</td><td style="text-align:center">需要</td><td style="text-align:center">块级</td></tr><tr><td style="text-align:center">const</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">存在</td><td style="text-align:center">需要</td><td style="text-align:center">块级</td></tr></tbody></table><p>const实际上保证的，并<strong>不是变量的值不得改动</strong>，而是<strong>变量指向的那个内存地址所保存的数据不得改动</strong>。</p><h3 id="es6中Object的方法-Object-assign-合并对象是浅拷贝，深拷贝"><a href="#es6中Object的方法-Object-assign-合并对象是浅拷贝，深拷贝" class="headerlink" title="es6中Object的方法  Object.assign()合并对象是浅拷贝，深拷贝"></a>es6中Object的方法 Object.assign()合并对象是浅拷贝，深拷贝</h3><ul><li>浅拷贝<br>Object.assign()</li><li>深拷贝<ul><li>JSON.parse(JSON.stringify(obj))</li><li>手写一个深拷贝</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'object'</span>)&#123;</span><br><span class="line">    result = obj.constructor === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      result[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span> ? deepClone(obj[i]) : obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> result = obj;</span><br><span class="line">  <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="es6模板字符串如何实现"><a href="#es6模板字符串如何实现" class="headerlink" title="es6模板字符串如何实现"></a>es6模板字符串如何实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">content</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> content.replace(<span class="regexp">/\$\&#123;([^&#125;]+)\&#125;/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">matched,childItem</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(childItem);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//   /\$\&#123;([^&#125;]+)\&#125;/g</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个正则匹配的内容就是$&#123;&#125;，括号里面是除了&#125;以外所有的字符，并且若干个</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ul><li>箭头函数声明时绑定this。</li><li>普通函数执行时绑定this</li><li>箭头函数不能用于构造函数，不能使用new，不能call,apply,bind，不能当作generator函数，不能使用yield，没有arguments，没有prototype。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;</span><br><span class="line">  func:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b=a.func; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  func:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> d=c.func</span><br><span class="line"><span class="comment">//a.func 输出a本身 	b(),c.func(),c()输出window</span></span><br></pre></td></tr></table></figure><h3 id="继承-原型-原型链"><a href="#继承-原型-原型链" class="headerlink" title="继承 原型 原型链"></a>继承 原型 原型链</h3><ul><li>使用ES5实现一个继承 <strong>核心是用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'parent name:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, parentName</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, parentName);  </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = proto;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = create(Parent.prototype);</span><br><span class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'child name:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</span><br><span class="line">parent.sayName();    <span class="comment">// parent name: father</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>, <span class="string">'father'</span>);</span><br></pre></td></tr></table></figure><ul><li>ES6继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parentName,age)&#123;</span><br><span class="line">    <span class="keyword">super</span>(parentName);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">handle = <span class="function"><span class="params">array</span>=&gt;</span>array.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>&#123;</span><br><span class="line">  !p.includes(c) &amp;&amp; p.push(c);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><ul><li>遍历</li></ul><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><ul><li><code>forEach</code> <code>map</code> <code>reduce</code> <code>filter</code> <code>some</code> <code>every</code> <code>concat</code> <code>push</code> <code>pop</code> <code>unshift</code> <code>shift</code></li><li>用reduce实现map</li><li>用reduce计算[2, [3, 4], [4, [5, 6]]]里所有的值的和</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="function"><span class="params">array</span>=&gt;</span>array.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p+(<span class="built_in">Array</span>.isArray(c) ? sum(c) : c),<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>使用reduce实现flap方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flap = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">p,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.concat(<span class="built_in">Array</span>.isArray(c) ? myFlap(c) : c);</span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFlap = <span class="function"><span class="params">array</span>=&gt;</span>array.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p.concat(<span class="built_in">Array</span>.isArray(c) ? myFlap(c) : c),[])</span><br></pre></td></tr></table></figure><h3 id="for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性"><a href="#for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性" class="headerlink" title="for in/for of/for 遍历对象 缺点 只能遍历原型的属性"></a>for in/for of/for 遍历对象 缺点 只能遍历原型的属性</h3><blockquote><p>for…in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。</p></blockquote><blockquote><p>for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p></blockquote><ul><li>for in 可以遍历数组和对象。可以获取key和value。</li><li>for of 可以遍历数组，<strong>不可遍历对象</strong>。只能获取value</li><li>for循环就是遍历数组的方法。</li></ul><h3 id="如何判断一个数组"><a href="#如何判断一个数组" class="headerlink" title="如何判断一个数组"></a>如何判断一个数组</h3><ul><li><code>arr instanceof Array</code></li><li><code>arr.constructor === Array</code></li><li><code>Object.prototype.toString.call(arr)</code></li><li><code>Array.isArray(arr)</code></li></ul><h3 id="如何判断一个对象是否为空对象"><a href="#如何判断一个对象是否为空对象" class="headerlink" title="如何判断一个对象是否为空对象"></a>如何判断一个对象是否为空对象</h3><ul><li><code>for in</code></li><li><code>Object.keys()</code></li></ul><h3 id="如何判断一个类数组对象"><a href="#如何判断一个类数组对象" class="headerlink" title="如何判断一个类数组对象"></a>如何判断一个类数组对象</h3><ul><li>本质还是一个对象</li><li>有一个length属性</li></ul><h3 id="异步的处理方式都有哪些"><a href="#异步的处理方式都有哪些" class="headerlink" title="异步的处理方式都有哪些"></a>异步的处理方式都有哪些</h3><ul><li>回调函数</li><li>promise</li><li>generator</li><li>async/await</li></ul><p><a href="https://caychance.github.io/2018/11/28/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A/#more">关于js中的异步</a></p><h3 id="Promise和async-await"><a href="#Promise和async-await" class="headerlink" title="Promise和async/await"></a>Promise和async/await</h3><h3 id="Promise原理-手写"><a href="#Promise原理-手写" class="headerlink" title="Promise原理 手写"></a>Promise原理 手写</h3><ul><li>Promise中存在三个状态 等待态pending 执行态fullfilled 拒绝态rejected</li><li>Promise状态不可逆 pending=&gt;fullfied pending=&gt;rejected</li><li>Promise.then()方法返回一个Promise对象，因此可以链式调用</li><li>Promise接受的函数参数是同步执行的，但then方法中的回调函数则是异步的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//promise声明</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>()&#123;<span class="comment">//成功</span></span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//promise调用</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// succ</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise封装setTimeOut"><a href="#Promise封装setTimeOut" class="headerlink" title="Promise封装setTimeOut"></a>Promise封装setTimeOut</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait=<span class="function"><span class="params">time</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">y</span>=&gt;</span>setTimeout(y,time))</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>async/await是generator的语法糖。</p><p>async/await对generator的改进有以下几点：</p><ul><li>内置执行器<br>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li><li>更好的语义<br>async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性<br>co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。所以，async函数的实现，就是把Generator函数和自动执行器包装在一个函数里。</li><li>返回值是Promise<br>async函数的返回值是 Promise 对象。</li></ul><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>Event Loop分为<strong>浏览器中的Event Loop</strong>和<strong>Node中的Event Loop</strong></p><h3 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h3><blockquote><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p></blockquote><h3 id="Node中的Event-Loop"><a href="#Node中的Event-Loop" class="headerlink" title="Node中的Event Loop"></a>Node中的Event Loop</h3><blockquote><p>（1）V8引擎解析JavaScript脚本。<br>（2）解析后的代码，调用Node API。<br>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），任务的执行结果会以异步的方式返回给V8引擎。<br>（4）V8引擎再将结果返回给用户。</p></blockquote><h3 id="宏任务和微任务的执行顺序"><a href="#宏任务和微任务的执行顺序" class="headerlink" title="宏任务和微任务的执行顺序"></a>宏任务和微任务的执行顺序</h3><blockquote><p>（1）先执行宏任务，执行完后，查看是否有微任务队列<br>（2）如果有微任务队列，则执行微任务<br>（3）如果没有，则读取宏任务中排在最前列的任务<br>（4）执行宏任务的过程中遇到微任务，则加入微任务队列<br>（5）执行完宏任务后，查看是否有微任务队列</p></blockquote><h3 id="常见的宏任务和微任务"><a href="#常见的宏任务和微任务" class="headerlink" title="常见的宏任务和微任务"></a>常见的宏任务和微任务</h3><ul><li>宏任务<br>script、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI Rendering</li><li>微任务<br>new Promise().then(回调)、Process.nextTick、Object.observe、MutationObserver</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 1 2 3 6 9 8 4 7 5</span></span><br></pre></td></tr></table></figure><h3 id="Node的执行顺序"><a href="#Node的执行顺序" class="headerlink" title="Node的执行顺序"></a>Node的执行顺序</h3><p>数据输入 =&gt; poll轮询 =&gt; check检查 =&gt; close callbacks关闭事件回调 =&gt; timers定时器 =&gt; I/O callbacks I/O事件回调 =&gt; idle prepare 闲置 =&gt; 轮询</p><h3 id="同步任务和异步任务的定义"><a href="#同步任务和异步任务的定义" class="headerlink" title="同步任务和异步任务的定义"></a>同步任务和异步任务的定义</h3><p>CPU会立即执行的任务是同步任务。</p><h3 id="node属于多线程还是单线程"><a href="#node属于多线程还是单线程" class="headerlink" title="node属于多线程还是单线程"></a>node属于多线程还是单线程</h3><ul><li>单线程</li></ul><h3 id="node的前端模板"><a href="#node的前端模板" class="headerlink" title="node的前端模板"></a>node的前端模板</h3><ul><li>ejs pug</li></ul><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>process对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。</p><p>类似global全局对象，浏览器中的window。</p><h3 id="call-apply-bind的区别-手写？"><a href="#call-apply-bind的区别-手写？" class="headerlink" title="call apply bind的区别 手写？"></a>call apply bind的区别 手写？</h3><ul><li>三者都是改变this的指向。</li><li>区别call，apply返回函数执行的结果，bind则返回一个函数</li><li>其中call的参数是展开的数据，apply的参数是数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> bindFn ? <span class="keyword">this</span> : context, args.concat([...arguments]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  tem.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFn.prototype = <span class="keyword">new</span> tem();</span><br><span class="line">  <span class="keyword">return</span> bindFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new发生了什么"><a href="#new发生了什么" class="headerlink" title="new发生了什么"></a>new发生了什么</h3><ul><li>新建一个新对象</li><li>this指向新对象</li><li>为新对象添加属性</li><li>返回新对象</li></ul><h3 id="函数递归-f-n-返回1到n的累加和"><a href="#函数递归-f-n-返回1到n的累加和" class="headerlink" title="函数递归 f(n) 返回1到n的累加和"></a>函数递归 f(n) 返回1到n的累加和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    result = n+sum(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    result = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">n</span>=&gt;</span>n&gt;<span class="number">1</span> ? n+sum(n<span class="number">-1</span>) : n;</span><br></pre></td></tr></table></figure><h3 id="SSR-Nuxt-Next"><a href="#SSR-Nuxt-Next" class="headerlink" title="SSR Nuxt Next"></a>SSR Nuxt Next</h3><ul><li>服务器端渲染</li></ul><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><ul><li>匹配所有非空白符 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</li><li>匹配非回车的字符</li><li>匹配所有字符</li><li>12345678变成12,345,678的正则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">(str.replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">','</span>))</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">str.toLocaleString()</span><br></pre></td></tr></table></figure><h3 id="instanceOf-Object-create-new的实现原理"><a href="#instanceOf-Object-create-new的实现原理" class="headerlink" title="instanceOf/Object.create/new的实现原理"></a>instanceOf/Object.create/new的实现原理</h3><h3 id="已知"><a href="#已知" class="headerlink" title="已知"></a>已知</h3><p>一个全部装着url的数组urls和一个叫fetch的ajax api，实现一个函数ajaxAll(urls, maxParallel, cb)，同时最多并行执行maxParallel个请求，所有url得到结果后执行cb</p><h3 id="求以下输出"><a href="#求以下输出" class="headerlink" title="求以下输出"></a>求以下输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;get()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name&#125;&#125;)</span><br><span class="line"><span class="comment">// 循环引用 导致内存溢出</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出什么 如何修改</span></span><br><span class="line"><span class="comment">//输出5个5</span></span><br><span class="line"><span class="comment">//想输出1，2，3，4，5，可以使用let,IIFE,setTimeout第三个参数</span></span><br></pre></td></tr></table></figure><h3 id="手写一个div的拖拽功能"><a href="#手写一个div的拖拽功能" class="headerlink" title="手写一个div的拖拽功能"></a>手写一个div的拖拽功能</h3><h3 id="写一个工厂函数用于生成对象"><a href="#写一个工厂函数用于生成对象" class="headerlink" title="写一个工厂函数用于生成对象"></a>写一个工厂函数用于生成对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂模式？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用的手写"><a href="#常用的手写" class="headerlink" title="常用的手写"></a>常用的手写</h3><ul><li>bind,call,apply</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype._apply = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// this的实例是bindFn，说明使用了new</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> bindFn ? <span class="keyword">this</span> : context,args.concat(bindArgs));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bindFn继承this</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tem</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  tem.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFn.prototype = <span class="keyword">new</span> tem();</span><br><span class="line">  <span class="keyword">return</span> bindFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>new</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myNew(fn, args) --&gt; new fn(args)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fn是构造函数</span></span><br><span class="line"><span class="comment">1、创建一个新对象；</span></span><br><span class="line"><span class="comment">2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</span></span><br><span class="line"><span class="comment">3、执行构造函数中的代码（为这个新对象添加属性）；</span></span><br><span class="line"><span class="comment">4、返回新对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(fn.prototype !== <span class="literal">null</span>)&#123;</span><br><span class="line">    obj.__proto__ === fn.prototype</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = fn.apply(obj,args);</span><br><span class="line">  <span class="keyword">if</span>(res !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> res === <span class="string">'object'</span> || <span class="keyword">typeof</span> res === <span class="string">'function'</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object.create</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 </span></span><br><span class="line"><span class="comment">// var b = Object.create(obj)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>instanceOf</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一直遍历 left的__proto__，一直遍历到null。</span></span><br><span class="line"><span class="comment">如果到null之前都没有proto等于prototype就返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = left.__proto__;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种写法更简洁吧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(left)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left.__proto__ === right.prototye) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo 手写promise</span></span><br></pre></td></tr></table></figure><ul><li>flat</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flat = <span class="function"><span class="params">array</span>=&gt;</span>array.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p.concat(<span class="built_in">Array</span>.isArray(c) ? flat(c) : c),[])</span><br></pre></td></tr></table></figure><ul><li>节流</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span>(now-prev&gt;delay)&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">      prev = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>防抖</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay,immediate</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(timer) clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'my name is '</span>,<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,fatherName</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//step 1</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>,fatherName);</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Father</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//step 2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  F.prototype = Father.prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = create(Father);</span><br><span class="line">Son.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello boy'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure><ul><li>参考链接<br><a href="https://juejin.im/post/5c9edb066fb9a05e267026dc" target="_blank" rel="noopener">掘金-【前端面试】同学，你会手写代码吗？</a><br><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6" target="_blank" rel="noopener">「中高级前端面试」JavaScript手写代码无敌秘籍</a></li></ul><h2 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h2><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2rmjd1xy1j30fg0brwei.jpg" alt></p><ul><li><p>M:Model层<br>数据模型</p></li><li><p>V:View层<br>视图层</p></li><li><p>VM:ViewModel层<br>是Model和Controller之间的一座桥梁。</p></li><li><p>双向数据绑定<br>V和VM之间采用双向数据绑定，View的变动，会自动反映在ViewModel。反之亦然。</p></li><li><p>各部分之间的通讯都是双向的。<br>MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来。</p></li></ul><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><ul><li>M，VM和V中，数据流从M流向VM，再由VM去修改V。</li></ul><h3 id="Vue提倡的是单向数据流，但是v-model是双向数据流，为什么"><a href="#Vue提倡的是单向数据流，但是v-model是双向数据流，为什么" class="headerlink" title="Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?"></a>Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?</h3><ul><li>v-model只是一个语法糖，本质还是单向数据流</li><li>v-bind:value和v-on:input</li></ul><h3 id="vue-use"><a href="#vue-use" class="headerlink" title="vue.use()"></a>vue.use()</h3><p>全局注入一个插件</p><h3 id="Vue双向绑定实现原理-数据响应系统原理"><a href="#Vue双向绑定实现原理-数据响应系统原理" class="headerlink" title="Vue双向绑定实现原理/数据响应系统原理"></a>Vue双向绑定实现原理/数据响应系统原理</h3><blockquote><blockquote></blockquote><p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p></blockquote><h3 id="Vue中，数组的操作是如何实现数据响应的-push等原型函数以及为什么用-set"><a href="#Vue中，数组的操作是如何实现数据响应的-push等原型函数以及为什么用-set" class="headerlink" title="Vue中，数组的操作是如何实现数据响应的(push等原型函数以及为什么用$set)"></a>Vue中，数组的操作是如何实现数据响应的(push等原型函数以及为什么用$set)</h3><h3 id="Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信"><a href="#Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信" class="headerlink" title="Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信"></a>Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信</h3><ul><li><code>props</code> <code>$emit</code></li></ul><h3 id="vue-3有哪些新的东西知道吗"><a href="#vue-3有哪些新的东西知道吗" class="headerlink" title="vue 3有哪些新的东西知道吗"></a>vue 3有哪些新的东西知道吗</h3><ul><li>可以着重聊聊数据响应系统使用Proxy和原来的区别，<a href="https://www.html.cn/archives/10052" target="_blank" rel="noopener">可以看看这个</a></li><li>对Vue确实需要比较深的了解，推荐把这个看完 Vue技术内幕，不过这个里面没有AST的东西</li></ul><h3 id="以下代码经过模板渲染后变成了什么样子简单讲一下"><a href="#以下代码经过模板渲染后变成了什么样子简单讲一下" class="headerlink" title="以下代码经过模板渲染后变成了什么样子简单讲一下"></a>以下代码经过模板渲染后变成了什么样子简单讲一下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent :prop1=&quot;data1&quot;&gt;</span><br><span class="line">  &lt;child :prop2=&quot;data2&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><h3 id="provide-inject能解决什么问题"><a href="#provide-inject能解决什么问题" class="headerlink" title="provide/inject能解决什么问题"></a>provide/inject能解决什么问题</h3><h3 id="computed和props-data的区别，其实现原理是什么"><a href="#computed和props-data的区别，其实现原理是什么" class="headerlink" title="computed和props/data的区别，其实现原理是什么"></a>computed和props/data的区别，其实现原理是什么</h3><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><ul><li>主要有两种模式 <strong>hash模式</strong> <strong>history模式</strong></li><li><strong>本质</strong>就是监听url的变化，然后匹配路由规则，显示相应的页面，并且无需刷新</li><li>hash模式 点击跳转通过hashchange事件来监听到url的变化 手动刷新通过load事件</li><li>history模式 点击跳转通过pushState 浏览器动作 回退等 popState 刷新或者输入url 会向服务器发送请求 <strong>需要后端配合重定向</strong></li></ul><h3 id="Vue-Router中query和param的区别"><a href="#Vue-Router中query和param的区别" class="headerlink" title="Vue Router中query和param的区别"></a>Vue Router中query和param的区别</h3><ul><li>都可以在两个页面之间进行传值</li><li>query path?id=1 ; param path/1</li><li>param如果不在router中配置的话，页面刷新，param会丢失</li></ul><h3 id="Vuex数据周期-如何使用-有什么好处"><a href="#Vuex数据周期-如何使用-有什么好处" class="headerlink" title="Vuex数据周期 如何使用 有什么好处"></a>Vuex数据周期 如何使用 有什么好处</h3><p>state – dispatch –&gt; actions – commit –&gt; mutations</p><h3 id="vue-nextTick的原理-如何找到dom-依赖收集过程"><a href="#vue-nextTick的原理-如何找到dom-依赖收集过程" class="headerlink" title="vue.nextTick的原理 如何找到dom 依赖收集过程"></a>vue.nextTick的原理 如何找到dom 依赖收集过程</h3><ul><li>nextTick是Vue的一个全局函数，用于处理dom更新操作。Vue里面有一个watcher，用于观察数据的变化，然后更新dom。Vue里面并不是每次数据变化都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom操作。</li><li>watch的实现，当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</li><li>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</li><li>Vue是异步执行dom更新的</li><li>Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</li><li>源码中<ul><li>2.5版本使用宏任务和微任务组合</li><li>源码中依次判断的逻辑：先看是否可以使用Promise，MutationObserver，setImmediate，setTimeout</li></ul></li></ul><h3 id="virtual-dom-diff算法具体实现过程"><a href="#virtual-dom-diff算法具体实现过程" class="headerlink" title="virtual-dom    diff算法具体实现过程"></a>virtual-dom diff算法具体实现过程</h3><ul><li>diff算法源于snabbdom，复杂度为O(n)</li><li>只会在同层级比较，不会跨层级比较</li><li>重点是patch方法</li></ul><h3 id="patch方法详解"><a href="#patch方法详解" class="headerlink" title="patch方法详解"></a>patch方法详解</h3><p>注释：vnode：新的虚拟节点 oldVnode：旧的虚拟节点</p><blockquote><blockquote></blockquote><ul><li>vnode不存在但是oldVnode存在，需要销毁oldVnode</li><li>oldVnode不存在但是vnode存在，创建新节点</li><li>oldVnode和vnode都存在<br>3.1 oldVnode和vnode是同一个节点 执行patchVnode方法<br>3.2 vnode创建真实dom并替换oldVnode.elm</li></ul></blockquote><h3 id="patchVnode方法详解"><a href="#patchVnode方法详解" class="headerlink" title="patchVnode方法详解"></a>patchVnode方法详解</h3><blockquote><blockquote></blockquote><ul><li>oldVnode和vnode完全一致，则不需要做任何事情</li><li>oldVnode和vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上即可</li><li>vnode不是文本节点或注释节点<br>3.1 如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行updateChildren方法<br>3.2 只有oldVnode有子节点，那就把这些节点都删除<br>3.3 如果只有vnode有子节点，那就创建这些子节点<br>3.4 如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串</li><li>vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</li></ul></blockquote><h3 id="updateChildren方法详解"><a href="#updateChildren方法详解" class="headerlink" title="updateChildren方法详解"></a>updateChildren方法详解</h3><blockquote><blockquote></blockquote><ul><li>oldStartIdx&gt;oldEndIdx<br>oldCh已经遍历完了，但是newCh还没有，把newStartIdx-newEndIdx之间的vnode都是新增的，把这些vnode添加到oldCh末尾</li><li>newStartIdx&gt;newEndIdx<br>newCh已经遍历完了，但是oldCh还没有，把oldCh中oldStartIdx-oldEndIdx之间的vnode删除</li><li>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx<br>3.1 oldVnode第一个child不存在，oldStart索引右移<br>3.2 oldVnode最后一个child不存在，oldEnd索引左移<br>3.3 oldStartVnode和newStartVnode是同一个节点，patchVnode两个节点，索引右移<br>3.4 oldEndVnode和newEndVnode是同一个节点，patchVnode两个节点，索引左移<br>3.5 oldStartVnode和newEndVnode是同一个节点，移动oldStartVnode到oldEndVnode节点后面<br>3.6 oldEndVnode和newStartVnode是同一个节点，移动oldEndVnode到oldStartVnode前面<br>3.7 oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点<br>3.8 如果找到了相同key的节点，比较两个节点是否属于同一个节点，如果属于同一节点，就patchVnode，否则新创建节点</li></ul></blockquote><h3 id="为什么要使用key？"><a href="#为什么要使用key？" class="headerlink" title="为什么要使用key？"></a>为什么要使用key？</h3><p>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p><h3 id="Vue-React-Angular区别"><a href="#Vue-React-Angular区别" class="headerlink" title="Vue,React,Angular区别"></a>Vue,React,Angular区别</h3><h3 id="Vue多端框架"><a href="#Vue多端框架" class="headerlink" title="Vue多端框架"></a>Vue多端框架</h3><ul><li>uni-app</li></ul><h3 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h3><ul><li>axios.interceptors.request.use</li><li>axios.interceptors.response.use</li><li>axios.default.header</li></ul><h2 id="Wepack以及项目优化"><a href="#Wepack以及项目优化" class="headerlink" title="Wepack以及项目优化"></a>Wepack以及项目优化</h2><h3 id="webpack打包原理"><a href="#webpack打包原理" class="headerlink" title="webpack打包原理"></a>webpack打包原理</h3><h3 id="module和chunk的区别"><a href="#module和chunk的区别" class="headerlink" title="module和chunk的区别"></a>module和chunk的区别</h3><h3 id="loader和plugin的区别"><a href="#loader和plugin的区别" class="headerlink" title="loader和plugin的区别"></a>loader和plugin的区别</h3><ul><li>loader<br>loaders是在打包构建过程中用来处理源文件的(JSX,Scss,Less)，一次处理一个；</li><li>plugin<br>plugins并不直接操作单个文件，它直接对整个构建过程起作用。</li></ul><h3 id="webpack-4相比3有什么变化"><a href="#webpack-4相比3有什么变化" class="headerlink" title="webpack 4相比3有什么变化"></a>webpack 4相比3有什么变化</h3><h3 id="webpack构建速度优化有哪些方式-这个能扯半个小时"><a href="#webpack构建速度优化有哪些方式-这个能扯半个小时" class="headerlink" title="webpack构建速度优化有哪些方式(这个能扯半个小时)"></a>webpack构建速度优化有哪些方式(这个能扯半个小时)</h3><h3 id="tree-shaking-scope-hoisting-code-spliting-都有什么作用"><a href="#tree-shaking-scope-hoisting-code-spliting-都有什么作用" class="headerlink" title="tree-shaking/scope-hoisting/code-spliting 都有什么作用"></a>tree-shaking/scope-hoisting/code-spliting 都有什么作用</h3><h3 id="webpack热更新的模块"><a href="#webpack热更新的模块" class="headerlink" title="webpack热更新的模块"></a>webpack热更新的模块</h3><ul><li>HotModuleReplacementPlugin</li><li>该模块是如何做到监听代码修改然后刷新页面的</li></ul><h3 id="webpack配置压缩一个js如何配置"><a href="#webpack配置压缩一个js如何配置" class="headerlink" title="webpack配置压缩一个js如何配置"></a>webpack配置压缩一个js如何配置</h3><ul><li>webpack.base.conf.js entry output module loaders</li></ul><h3 id="webpack编译后图片名为什么会改变"><a href="#webpack编译后图片名为什么会改变" class="headerlink" title="webpack编译后图片名为什么会改变"></a>webpack编译后图片名为什么会改变</h3><h2 id="浏览器及安全"><a href="#浏览器及安全" class="headerlink" title="浏览器及安全"></a>浏览器及安全</h2><h3 id="浏览器中支持最大的请求并发数"><a href="#浏览器中支持最大的请求并发数" class="headerlink" title="浏览器中支持最大的请求并发数"></a>浏览器中支持最大的请求并发数</h3><p>chrome中是6</p><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><ul><li>stopPropagation</li><li>cancelBubble</li></ul><h3 id="常见的浏览器安全问题"><a href="#常见的浏览器安全问题" class="headerlink" title="常见的浏览器安全问题"></a>常见的浏览器安全问题</h3><ul><li><p>XSS 跨站脚本攻击</p><blockquote><p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p></blockquote></li><li><p>CSRF 跨站请求伪造攻击</p><blockquote><p>1.浏览器登录信任网站A<br>2.通过验证，在浏览器中产生cookie<br>3.用户在没有登出A的情况下，访问危险网站B<br>4.B要求访问A网站，并发一个请求<br>5.根据B的要求，浏览器待着cookie访问A</p></blockquote></li><li>SQL注入</li><li>命令行注入</li><li>DDos攻击<blockquote><p>原理就是利用大量的请求造成资源过载，导致服务不可用</p></blockquote></li><li><p>流量劫持</p><ul><li><p>DNS劫持</p><blockquote><p>“你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了”</p></blockquote></li><li><p>HTTP劫持</p><blockquote><p>“你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告”</p></blockquote></li></ul></li></ul><h3 id="chrome跨标签通信"><a href="#chrome跨标签通信" class="headerlink" title="chrome跨标签通信"></a>chrome跨标签通信</h3><ul><li>获取句柄 postMessage</li><li>localStorage</li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul><li>jsonp</li><li>CORS</li><li>WebSocket</li><li>Nginx代理</li><li>Node中间件代理 <code>http-proxy-middleware</code> <code>proxy-middleware</code></li></ul><h3 id="输入网址回车之后浏览器做了什么"><a href="#输入网址回车之后浏览器做了什么" class="headerlink" title="输入网址回车之后浏览器做了什么"></a>输入网址回车之后浏览器做了什么</h3><p>以chrome为例：</p><ul><li>输入地址<br>会从历史记录，书签等地方智能提示补全url。查找缓存。</li><li>NDS解析</li><li>TCP请求</li><li>浏览器向服务器发送一个 HTTP 请求</li><li>服务器的永久重定向相应(如果有的话)</li><li>浏览器跟踪重定向地址</li><li>服务器处理请求</li><li>服务器返回一个 HTTP 响应</li><li><p>浏览器显示HTML</p></li><li><p>浏览器发送请求获取嵌入在 HTML 中的资源(图片，CSS，JS，音频，视频)</p></li></ul><p><a href="https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">老生常谈-从输入url到页面展示到底发生了什么</a></p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li><li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li><li>进程是一个工厂，拥有独立的资源（独立的一块内存），进程之间相互独立，工厂中有一个或者多个工人（一个进程由一个或者多个线程组成）。</li><li>线程是工厂中的工人，工人共享空间（同一进程下的各个线程之间共享程序的内存空间）</li></ul><h3 id="Chrome是多进程吗，为什么是多进程而不是多线程，包括哪些进程"><a href="#Chrome是多进程吗，为什么是多进程而不是多线程，包括哪些进程" class="headerlink" title="Chrome是多进程吗，为什么是多进程而不是多线程，包括哪些进程"></a>Chrome是多进程吗，为什么是多进程而不是多线程，包括哪些进程</h3><ul><li>是多进程的。一个网页相当一个进程</li></ul><p>包括以下四个进程：</p><ul><li>Browser进程:浏览器的主进程（负责协调、主控），只有一个<blockquote><blockquote></blockquote><p>负责浏览器界面显示，与用户交互。如前进，后退等<br>负责各个页面的管理，创建和销毁其他进程<br>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上<br>网络资源的管理，下载等</p></blockquote></li><li>第三方插件进程<blockquote><blockquote></blockquote><p>每种类型的插件对应一个进程，仅当使用该插件时才创建看上面的图片中的“扩展程序”就是了</p></blockquote></li><li>GPU进程:最多一个，用于3D绘制等</li><li>浏览器渲染进程（浏览器内核）:重点<blockquote><blockquote></blockquote><p>Renderer进程，内部是多线程的<br>页面渲染，脚本执行，事件处理等</p></blockquote></li></ul><h3 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h3><ul><li>单个tab奔溃不会影响整个浏览器</li><li>避免第三方插件影响浏览器</li><li>多进程充分利用多核优势</li></ul><h3 id="Chrome-渲染-render-进程包含哪些线程"><a href="#Chrome-渲染-render-进程包含哪些线程" class="headerlink" title="Chrome 渲染(render)进程包含哪些线程"></a>Chrome 渲染(render)进程包含哪些线程</h3><ul><li>GUI渲染线程<blockquote><blockquote></blockquote><p>负责渲染浏览器界面，解析HTML、CSS<br>当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行<br>GUI渲染线程与JS引擎线程是互斥的，因为JS可以操作DOM元素， 从而影响到GUI的渲染结果，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</p></blockquote></li><li>JS引擎线程<blockquote><blockquote></blockquote><p>JS内核（例如V8引擎），负责处理Javascript脚本程序<br>JS引擎一直等待着任务队列中任务的到来，然后加以处理<br>GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行时间过长，页面渲染就不连贯，造成页面渲染加载阻塞</p></blockquote></li><li>事件触发线程<blockquote><blockquote></blockquote><p>由于JS引擎这个单线程的家伙自己都忙不过来，所以需要浏览器另开一个线程协助它<br>待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p></blockquote></li><li>定时触发器线程<blockquote><blockquote></blockquote><p>setInterval与setTimeout所在线程<br>JS引擎阻塞状态下计时不准确，所以由浏览器另开线程单独计时<br>计时完毕后，添加到事件队列中，等待JS引擎空闲后执行<br>W3C规定，setTimeout中低于4ms的时间间隔算为4ms</p></blockquote></li><li>异步HTTP请求线程<blockquote><blockquote></blockquote><p>如果请求有回调事件，异步线程就产生状态变更事件，将这个回调再放入事件队列中，等JS引擎空闲后执行</p></blockquote></li></ul><p><a href="https://github.com/amandakelake/blog/issues/55" target="_blank" rel="noopener">浏览器工作原理：从输入URL到页面加载完成</a></p><h3 id="Chrome是如何实现setTimout的"><a href="#Chrome是如何实现setTimout的" class="headerlink" title="Chrome是如何实现setTimout的"></a>Chrome是如何实现setTimout的</h3><h3 id="如何监控前端性能"><a href="#如何监控前端性能" class="headerlink" title="如何监控前端性能"></a>如何监控前端性能</h3><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><ul><li>强制缓存</li><li>协商缓存</li><li>先判断是否命中强缓存，如果命中，则不请求服务器，直接从缓存中返回数据；</li><li>如果未命中，则向服务器发送一个请求，再判断是否命中协商缓存，如果命中，更新缓存，然后缓存中返回数据</li><li>如果均未命中，则向服务器发送请求，服务器返回数据。</li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h3><ul><li>1** 信息类</li><li>2** 成功</li><li>3** 重定向类 301永久重定向 302临时重定向</li><li>4** 客户端出错</li><li>5** 服务器出错</li><li>200成功/204无内容</li><li>301永久重定向/302临时重定向/304未修改</li><li>401未授权/403禁止访问/404未找到/405请求方式不对</li><li>500服务器内部错误/502错误网关/503服务不可用/504服务器超时</li></ul><h3 id="Http常见请求方法以及简单描述"><a href="#Http常见请求方法以及简单描述" class="headerlink" title="Http常见请求方法以及简单描述"></a>Http常见请求方法以及简单描述</h3><p><code>get</code> <code>post</code> <code>head</code> <code>options</code> <code>delete</code> <code>put</code></p><h3 id="Http-header中都有哪些信息"><a href="#Http-header中都有哪些信息" class="headerlink" title="Http header中都有哪些信息"></a>Http header中都有哪些信息</h3><p><code>Accept</code>，<code>Connection</code>，<code>Content-Type</code>，<code>Expires</code>，<code>Server</code>，<code>Etag</code>，<code>Last-Modified</code>，<code>Server</code>，<code>Date</code>，<code>Cache-Control</code>，<code>User-Agent</code>等。</p><h3 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h3><p>Http主要有三点不足。</p><ul><li>通信使用明文，未加密。导致内容可能会被窃听。</li><li>不验证通讯方的身份。有可能遭遇伪装。</li><li>无法证明报文的完整性。有可能已遭篡改。</li></ul><p>Https的出现也是为了解决上述问题。因此：<br>Http+加密+认证+完整新保护 = Https。<br>Https是身披SSL外壳的Http。SSL协议在Http和Tcp协议之间。</p><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><h3 id="TCP三次握手-四次挥手区别"><a href="#TCP三次握手-四次挥手区别" class="headerlink" title="TCP三次握手/四次挥手区别"></a>TCP三次握手/四次挥手区别</h3><h3 id="为什么TCP建立连接是三次而关闭连接要多一次"><a href="#为什么TCP建立连接是三次而关闭连接要多一次" class="headerlink" title="为什么TCP建立连接是三次而关闭连接要多一次"></a>为什么TCP建立连接是三次而关闭连接要多一次</h3><h3 id="Https认证过程"><a href="#Https认证过程" class="headerlink" title="Https认证过程"></a>Https认证过程</h3><h3 id="HTTP2相比HTTP1多了什么"><a href="#HTTP2相比HTTP1多了什么" class="headerlink" title="HTTP2相比HTTP1多了什么"></a>HTTP2相比HTTP1多了什么</h3><ul><li><p><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。<br>基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li><li><p><strong>多路复用</strong>（MultiPlexing）<br>即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p></li><li><p><strong>header压缩</strong><br>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></li><li><p><strong>服务端推送</strong>（server push）<br>同SPDY一样，HTTP2.0也具有server push功能。</p></li></ul><h3 id="HTTP2的多路复用和HTTP-1-1的keep-alive有什么区别"><a href="#HTTP2的多路复用和HTTP-1-1的keep-alive有什么区别" class="headerlink" title="HTTP2的多路复用和HTTP 1.1的keep-alive有什么区别"></a>HTTP2的多路复用和HTTP 1.1的keep-alive有什么区别</h3><ul><li><p>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</p></li><li><p>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</p></li><li><p>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。</p></li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li>expires 过期时间</li><li>domain 域名</li><li>path 路径</li><li>security 安全情况下才传输给服务器 https</li><li>httponly js是否可以操作</li><li>如何防止js访问cookie，如何限制只能在https中才能访问cookie(set-cookie相关字段)</li></ul><h3 id="websocket是如何建立连接的"><a href="#websocket是如何建立连接的" class="headerlink" title="websocket是如何建立连接的"></a>websocket是如何建立连接的</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h3><h3 id="快排的时间复杂度和空间复杂度"><a href="#快排的时间复杂度和空间复杂度" class="headerlink" title="快排的时间复杂度和空间复杂度"></a>快排的时间复杂度和空间复杂度</h3><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;a.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;a.length-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">      [a[j],a[j+<span class="number">1</span>]] = [a[j+<span class="number">1</span>],a[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给个数组和n，找到数组里的三个数相加是n，复杂度要求O-n-2-logn"><a href="#给个数组和n，找到数组里的三个数相加是n，复杂度要求O-n-2-logn" class="headerlink" title="给个数组和n，找到数组里的三个数相加是n，复杂度要求O(n^2*logn)"></a>给个数组和n，找到数组里的三个数相加是n，复杂度要求O(n^2*logn)</h3><h3 id="对数组-2-3-3-2-5-进行多重相邻去重-第一次去重后结果-2-2-5-，然后得到-5-，复杂度要求O-n"><a href="#对数组-2-3-3-2-5-进行多重相邻去重-第一次去重后结果-2-2-5-，然后得到-5-，复杂度要求O-n" class="headerlink" title="对数组[2, 3, 3, 2, 5]进行多重相邻去重(第一次去重后结果[2, 2, 5]，然后得到[ 5 ])，复杂度要求O(n)"></a>对数组[2, 3, 3, 2, 5]进行多重相邻去重(第一次去重后结果[2, 2, 5]，然后得到[ 5 ])，复杂度要求O(n)</h3><h3 id="给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n"><a href="#给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n" class="headerlink" title="给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n"></a>给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n</h3><h3 id="给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层"><a href="#给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层" class="headerlink" title="给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层"></a>给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层</h3><h3 id="二叉树广度优先遍历"><a href="#二叉树广度优先遍历" class="headerlink" title="二叉树广度优先遍历"></a>二叉树广度优先遍历</h3><h3 id="给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止"><a href="#给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止" class="headerlink" title="给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止"></a>给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止</h3><h3 id="给一个二维数组，如-0-0-0-1-0-0-0-1-0-，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径"><a href="#给一个二维数组，如-0-0-0-1-0-0-0-1-0-，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径" class="headerlink" title="给一个二维数组，如[[0, 0, 0], [1, 0, 0], [0, 1, 0]]，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径"></a>给一个二维数组，如[[0, 0, 0], [1, 0, 0], [0, 1, 0]]，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径</h3><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h3 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个数组arr，不新建变量，过滤掉arr中大于5的，并输出arr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=arr.length;i&lt;len;)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr[i]&gt;<span class="number">5</span>)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="项目优化的点"><a href="#项目优化的点" class="headerlink" title="项目优化的点"></a>项目优化的点</h3><ul><li>html标签语义化</li><li>高效的css</li><li>图片压缩，尽可能不用图片</li><li>js等代码优化</li><li>减少http请求</li><li>打包后的代码压缩</li><li>PWA</li><li>webpack按需加载</li><li>cdn</li><li>骨架屏</li></ul><h3 id="项目中做过比较复杂的东西如何解决"><a href="#项目中做过比较复杂的东西如何解决" class="headerlink" title="项目中做过比较复杂的东西如何解决"></a>项目中做过比较复杂的东西如何解决</h3><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h3 id="鸡兔同笼-70脚-20头"><a href="#鸡兔同笼-70脚-20头" class="headerlink" title="鸡兔同笼 70脚 20头"></a>鸡兔同笼 70脚 20头</h3><ul><li>20只动物都收起两只脚，这个时候，就剩下了30只脚</li><li>30只脚全是兔子的，这个时候每只兔子只有2只脚，所以有15个兔子</li></ul><h3 id="两个村庄-A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了-这俩村庄的男女比例"><a href="#两个村庄-A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了-这俩村庄的男女比例" class="headerlink" title="两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例"></a>两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例</h3><h3 id="推荐几个链接"><a href="#推荐几个链接" class="headerlink" title="推荐几个链接"></a>推荐几个链接</h3><p><a href="https://juejin.im/post/5c9edb066fb9a05e267026dc" target="_blank" rel="noopener">【前端面试】同学，你会手写代码吗？</a><br><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6" target="_blank" rel="noopener">「中高级前端面试」JavaScript手写代码无敌秘籍</a><br><a href="https://juejin.im/post/5c71434a6fb9a049fa10633c" target="_blank" rel="noopener">前端笔试之手写代码(一)</a></p><p>小米 百度 猿辅导 瓜子 VIPKide 爱奇艺 阿里 滴滴 美团</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:chance17610999610@gmail.com">CayChance</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://caychance.github.io/2019/04/13/面试小记/">https://caychance.github.io/2019/04/13/面试小记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://caychance.github.io">ChanceのBlog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/27/webpack4-0学习笔记/"><i class="fa fa-chevron-left"></i><span>webpack4.0学习笔记</span></a></div><div class="next-post pull-right"><a href="/2019/04/03/diff算法/"><span>diff算法</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://ws2.sinaimg.cn/large/006tNc79ly1g289wvlhyej31hc0u0q7i.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By CayChance</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script></body></html>