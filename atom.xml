<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chance的个人学习笔记</title>
  
  <subtitle>Chance`blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-12T15:53:48.901Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试小记</title>
    <link href="http://yoursite.com/2019/04/13/%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/13/面试小记/</id>
    <published>2019-04-12T23:53:48.000Z</published>
    <updated>2019-04-12T15:53:48.901Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>diff算法</title>
    <link href="http://yoursite.com/2019/04/03/diff%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/03/diff算法/</id>
    <published>2019-04-02T19:08:09.000Z</published>
    <updated>2019-04-04T07:14:46.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><hr><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>因为如果在项目中大量的操作dom会很影响性能，所以Vue和React都尝试使用虚拟dom（virtual dom）。虚拟dom的本质其实就是用一个对象去描述整个dom结构，包括：当前dom的tag标签，data，children子节点，text文本，elm，key等等等，属性很多，就不一一列举了。</p><p>virtual dom真的比DOM操作效率高吗？不一定，那使用virtual dom的优势是什么呢？</p><p>使用虚拟dom的优势：</p><ol><li>不用手动频繁操作dom</li><li>框架跨平台</li><li>可以更好的实现SSR，同构渲染</li><li>组件的高度抽象化</li></ol><p>总之，<strong>大大的提高了我们的工作效率。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  tag: string | <span class="keyword">void</span>;</span><br><span class="line">  data: VNodeData | <span class="keyword">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: string | <span class="keyword">void</span>;</span><br><span class="line">  elm: Node | <span class="keyword">void</span>;</span><br><span class="line">  ns: string | <span class="keyword">void</span>;</span><br><span class="line">  context: Component | <span class="keyword">void</span>; <span class="comment">// rendered in this component's scope</span></span><br><span class="line">  key: string | number | <span class="keyword">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="keyword">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  raw: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  isStatic: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  isRootInsert: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  isComment: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  isCloned: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  isOnce: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="keyword">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  fnContext: Component | <span class="keyword">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  fnOptions: ?ComponentOptions; <span class="comment">// for SSR caching</span></span><br><span class="line">  devtoolsMeta: ?<span class="built_in">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  fnScopeId: ?string; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><ul><li>Vue的virtual dom的算法是基于Snabbdom库。</li><li>VNode只会同层级比较，不会跨层级比较，因此复杂度为O(n)。</li><li>重点是<code>patch</code>方法。</li></ul><h3 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h3><p>注释：vnode：新的虚拟节点 oldVnode：旧的虚拟节点</p><ol><li>vnode不存在但是oldVnode存在，需要销毁oldVnode</li><li>oldVnode不存在但是vnode存在，创建新节点</li><li>oldVnode和vnode都存在<br>3.1 oldVnode和vnode是同一个节点 执行<code>patchVnode</code>方法<br>3.2 vnode创建真实dom并替换oldVnode.elm</li></ol><h3 id="patchVnode方法"><a href="#patchVnode方法" class="headerlink" title="patchVnode方法"></a>patchVnode方法</h3><ol><li>oldVnode和vnode完全一致，则不需要做任何事情</li><li>vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</li><li>oldVnode和vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上即可</li><li>vnode不是文本节点或注释节点<br>4.1 如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行<code>updateChildren</code>方法<br>4.2 只有oldVnode有子节点，那就把这些节点都删除<br>4.3 如果只有vnode有子节点，那就创建这些子节点<br>4.4 如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串</li></ol><h3 id="updateChildren方法"><a href="#updateChildren方法" class="headerlink" title="updateChildren方法"></a>updateChildren方法</h3><ol><li>oldStartIdx&gt;oldEndIdx<br>oldCh已经遍历完了，但是newCh还没有，把newStartIdx-newEndIdx之间的vnode都是新增的，把这些vnode添加到oldCh末尾</li><li>newStartIdx&gt;newEndIdx<br>newCh已经遍历完了，但是oldCh还没有，把oldCh中oldStartIdx-oldEndIdx之间的vnode删除</li><li>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx<br>一直循环判断<br>3.1 oldVnode第一个child不存在，oldStart索引右移<br>3.2 oldVnode最后一个child不存在，oldEnd索引左移<br>3.3 oldStartVnode和newStartVnode是同一个节点，<code>patchVnode</code>两个节点，索引右移<br>3.4 oldEndVnode和newEndVnode是同一个节点，<code>patchVnode</code>两个节点，索引左移<br>3.5 oldStartVnode和newEndVnode是同一个节点，移动oldStartVnode到oldEndVnode节点后面<br>3.6 oldEndVnode和newStartVnode是同一个节点，移动oldEndVnode到oldStartVnode前面<br>3.7 oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点<br>3.8 如果找到了相同key的节点，比较两个节点是否属于同一个节点，如果属于同一节点，就<code>patchVnode</code>，否则新创建节点</li></ol><h3 id="什么要设置key"><a href="#什么要设置key" class="headerlink" title="什么要设置key"></a>什么要设置key</h3><p>如果不设置key的话，newCh和oldCh只会头尾两端比较，并且交叉比较。<br>如果设置key的话，除了上述的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>virtual dom是vue 2.0以后增加的，那么2.0之前vue这一块是怎么处理的呢？</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.zhihu.com/question/271485214" target="_blank" rel="noopener">Vue采用虚拟DOM的目的是什么?</a><br><a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js" target="_blank" rel="noopener">Vue中virtual dom算法源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;diff-算法&quot;&gt;&lt;a href=&quot;#diff-算法&quot; class=&quot;headerlink&quot; title=&quot;diff 算法&quot;&gt;&lt;/a&gt;diff 算法&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;Virtual-DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM&quot; clas
      
    
    </summary>
    
    
      <category term="diff算法" scheme="http://yoursite.com/tags/diff%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vuex笔记</title>
    <link href="http://yoursite.com/2019/03/29/Vuex%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/29/Vuex笔记/</id>
    <published>2019-03-28T16:21:30.000Z</published>
    <updated>2019-03-28T11:10:45.859Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex学习笔记</p><hr><h3 id="Vuex概述"><a href="#Vuex概述" class="headerlink" title="Vuex概述"></a>Vuex概述</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理</strong>模式。</p><p>简单来说，就是存储页面中的各种数据。</p><h3 id="为什么要用Vuex"><a href="#为什么要用Vuex" class="headerlink" title="为什么要用Vuex"></a>为什么要用Vuex</h3><p>Vuex的使用并不是必要的。</p><p>Vue.js中，数据之间都是在组件之间进行传递的，但是当你的应用变的很大或者很复杂的时候，会有两个问题。</p><p>1、当组件嵌套很深的时候，数据的传递，修改，其实都不太方便，很容易导致出错。</p><p>2、这些状态可能会在任何组件中被修改，不方便统一管理。尤其是多人合作开发的时候。</p><p>Vuex也是为了解决这两个问题而生的。</p><p>当然，有人可能会想到使用一个全局对象，再去上层封装了一些数据存取的接口来解决。Vuex和单纯的全局对象有以下两点不同：</p><ul><li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p></li><li><p>不能直接改变store中的状态。改变store中的状态的唯一途径就是显式地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p></li></ul><h3 id="Vuex详细介绍"><a href="#Vuex详细介绍" class="headerlink" title="Vuex详细介绍"></a>Vuex详细介绍</h3><p>Vuex中有五个核心的概念：</p><ul><li>State<blockquote><p>用于存储数据</p></blockquote></li><li><p>Getter</p><blockquote><p>可理解为store的（computed）计算属性</p></blockquote><blockquote><p>Getter可接受state和getter两个参数。</p></blockquote></li><li><p>Mutation</p><blockquote><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p></blockquote><blockquote><p>mutation 都是同步事务</p></blockquote></li><li><p>Action</p><blockquote><p>Action类似mutation。</p></blockquote><blockquote><p>区别有两点：1.Action可以包含异步操作；2.Action 提交的是 mutation，而不是直接变更状态。</p></blockquote></li><li>Module<blockquote><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。Vuex 允许我们将 store 分割成模块（module,每个模块拥有自己的state、mutation、action、getter以及嵌套子模块。</p></blockquote></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>每一个 Vuex 应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态(state)。</li><li>想修改state只能提交（commit）mutation。</li><li>mutation中只能进行同步操作。</li><li>异步操作可以分发（dispatch）action，当然，action的实质还是提交（commit）mutation。</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1io1c6idkj30jh0fbwef.jpg" alt></p><p>Vuex的数据流向：<br>State 渲染到Vue Components,分发(Dispatch) Actions,提交(Commit) Mutations，修改(Mutate) State。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vuex学习笔记&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Vuex概述&quot;&gt;&lt;a href=&quot;#Vuex概述&quot; class=&quot;headerlink&quot; title=&quot;Vuex概述&quot;&gt;&lt;/a&gt;Vuex概述&lt;/h3&gt;&lt;p&gt;Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="Vuex" scheme="http://yoursite.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue原理解析笔记</title>
    <link href="http://yoursite.com/2019/03/28/Vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/28/Vue原理解析笔记/</id>
    <published>2019-03-27T19:09:06.000Z</published>
    <updated>2019-03-27T11:19:56.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue原理学习笔记"><a href="#Vue原理学习笔记" class="headerlink" title="Vue原理学习笔记"></a>Vue原理学习笔记</h3><hr><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue原理学习笔记&quot;&gt;&lt;a href=&quot;#Vue原理学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Vue原理学习笔记&quot;&gt;&lt;/a&gt;Vue原理学习笔记&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;#### &lt;/p&gt;

      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue原理" scheme="http://yoursite.com/tags/Vue%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>为什么要用框架</title>
    <link href="http://yoursite.com/2019/03/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/03/23/为什么要用框架/</id>
    <published>2019-03-22T23:14:00.000Z</published>
    <updated>2019-03-26T02:56:57.535Z</updated>
    
    <content type="html"><![CDATA[<hr><p>一直在用Vue，但是也没有想过框架的出现是为了解决什么痛点？</p><h4 id="实现一个点赞功能"><a href="#实现一个点赞功能" class="headerlink" title="实现一个点赞功能"></a>实现一个点赞功能</h4><p>首先，实现一个简单的点赞功能，不考虑使用任何框架。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">'like-btn'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'like-text'</span>&gt;</span>点赞<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 实现一个简单的点赞按钮，点击按钮的同时按钮的文字会变换。demo1难以复用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'.like-btn'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> buttonText = button.querySelector(<span class="string">'.like-text'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> isLiked = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">    button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="undefined">      isLiked = !isLiked</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (isLiked) &#123;</span></span><br><span class="line"><span class="javascript">        buttonText.innerHTML = <span class="string">'取消'</span></span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        buttonText.innerHTML = <span class="string">'点赞'</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码实现了点赞的功能，但是有一个问题——难以复用。</p><h4 id="结构复用"><a href="#结构复用" class="headerlink" title="结构复用"></a>结构复用</h4><p>经过改造，我们也仅仅只能复用html部分，并且没有添加事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 仅仅可以复用html部分，没有添加事件</span></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">      render()&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'like-btn'</span>&gt;</span></span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;赞&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton1 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.innerHTML = likeButton1.render()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton2 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.innerHTML += likeButton2.render()</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h4><p>虽然添加了click事件，但是只能输出固定的click。我们需要点击按钮，改变文字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加了click事件，但是只能打印固定的click</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">      render()&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-button'</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;点赞&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'click'</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton1 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.appendChild(likeButton1.render())</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton2 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.appendChild(likeButton2.render())</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改文字"><a href="#修改文字" class="headerlink" title="修改文字"></a>修改文字</h4><p>点击按钮，会修改文字，但是changeLikeText方法频繁的操作dom，影响性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击按钮会执行changeLikeText方法，但是changeLikeText方法里面在不停的操作dom，影响性能</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123; <span class="attr">isLiked</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      changeLikeText () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> likeText = <span class="keyword">this</span>.el.querySelector(<span class="string">'.like-text'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state.isLiked = !<span class="keyword">this</span>.state.isLiked</span></span><br><span class="line"><span class="javascript">        likeText.innerHTML = <span class="keyword">this</span>.state.isLiked ? <span class="string">'取消'</span> : <span class="string">'点赞'</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render()&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-button'</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;点赞&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeLikeText.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton1 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.appendChild(likeButton1.render())</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton2 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.appendChild(likeButton2.render())</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>到这一步骤，基本已经大体形成，我们可以做更进一步的优化。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击按钮执行changeLikeText方法，该方法值会调用setState方法，setState方法会重新给satate赋值，并且修改虚拟html。最终只会操作一次dom</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123; <span class="attr">isLiked</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      setState (state) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> oldEl = <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = state</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = <span class="keyword">this</span>.render()</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onStateChange) <span class="keyword">this</span>.onStateChange(oldEl, <span class="keyword">this</span>.el)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      changeLikeText () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">          isLiked: !<span class="keyword">this</span>.state.isLiked</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-btn'</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;$&#123;<span class="keyword">this</span>.state.isLiked ? <span class="string">'取消'</span> : <span class="string">'点赞'</span>&#125;&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeLikeText.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="javascript">    wrapper.appendChild(likeButton.render()) <span class="comment">// 第一次插入 DOM 元素</span></span></span><br><span class="line"><span class="javascript">    likeButton.onStateChange = <span class="function">(<span class="params">oldEl, newEl</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      wrapper.insertBefore(newEl, oldEl) <span class="comment">// 插入新的元素</span></span></span><br><span class="line"><span class="javascript">      wrapper.removeChild(oldEl) <span class="comment">// 删除旧的元素</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h4><p>setState和_renderDOM封装成Component类，便于其他组件使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把setState和_renderDOM方法进行抽离，修改dom的操作封装成方法</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> mount = <span class="function">(<span class="params">component, wrapper</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">      wrapper.appendChild(component._renderDOM())</span></span><br><span class="line"><span class="javascript">      component.onStateChange = <span class="function">(<span class="params">oldEl, newEl</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">        wrapper.insertBefore(newEl, oldEl)</span></span><br><span class="line"><span class="undefined">        wrapper.removeChild(oldEl)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">      setState (state) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> oldEl = <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = state</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>._renderDOM()</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onStateChange) <span class="keyword">this</span>.onStateChange(oldEl, <span class="keyword">this</span>.el)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      _renderDOM () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="keyword">this</span>.render())</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onClick) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">super</span>()</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123; <span class="attr">isLiked</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      onClick () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">          isLiked: !<span class="keyword">this</span>.state.isLiked</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-btn'</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;$&#123;<span class="keyword">this</span>.state.isLiked ? <span class="string">'取消'</span> : <span class="string">'点赞'</span>&#125;&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    mount(<span class="keyword">new</span> LikeButton(), wrapper)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h4><p>组件可通过props传参来自定义配置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 组件可以自定义配置 通过props</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> mount = <span class="function">(<span class="params">component, wrapper</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">      wrapper.appendChild(component._renderDOM())</span></span><br><span class="line"><span class="javascript">      component.onStateChange = <span class="function">(<span class="params">oldEl, newEl</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">        wrapper.insertBefore(newEl, oldEl)</span></span><br><span class="line"><span class="undefined">        wrapper.removeChild(oldEl)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> (props = &#123;&#125;) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.props = props</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      setState (state) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> oldEl = <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = state</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>._renderDOM()</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onStateChange) <span class="keyword">this</span>.onStateChange(oldEl, <span class="keyword">this</span>.el)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      _renderDOM () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="keyword">this</span>.render())</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onClick) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> (props) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">super</span>(props)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123; <span class="attr">isLiked</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      onClick () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">          isLiked: !<span class="keyword">this</span>.state.isLiked</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-btn'</span> style=<span class="string">"background-color: $&#123;this.props.bgColor&#125;"</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;</span></span><br><span class="line"><span class="javascript">              $&#123;<span class="keyword">this</span>.state.isLiked ? <span class="string">'取消'</span> : <span class="string">'点赞'</span>&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">RedBlueButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> (props) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">super</span>(props)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123;</span></span><br><span class="line"><span class="javascript">          color: <span class="string">'red'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      onClick () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">          color: <span class="string">'blue'</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'color: $&#123;this.state.color&#125;;'</span>&gt;</span>$&#123;this.state.color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    mount(<span class="keyword">new</span> LikeButton(&#123; <span class="attr">bgColor</span>: <span class="string">'red'</span> &#125;), wrapper)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样子循序渐进的看下来，就能体会到一个框架的诞生的个中缘由——并不是平白无故做出来的，而是为了解决一些问题，然后一点一点的优化，最终诞生的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;一直在用Vue，但是也没有想过框架的出现是为了解决什么痛点？&lt;/p&gt;
&lt;h4 id=&quot;实现一个点赞功能&quot;&gt;&lt;a href=&quot;#实现一个点赞功能&quot; class=&quot;headerlink&quot; title=&quot;实现一个点赞功能&quot;&gt;&lt;/a&gt;实现一个点赞功能&lt;/h4&gt;&lt;p&gt;首先，
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JSX in Vue</title>
    <link href="http://yoursite.com/2019/03/09/JSX-in-Vue/"/>
    <id>http://yoursite.com/2019/03/09/JSX-in-Vue/</id>
    <published>2019-03-08T23:53:26.000Z</published>
    <updated>2019-03-31T14:50:04.387Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="使用Vue的template遇到的问题"><a href="#使用Vue的template遇到的问题" class="headerlink" title="使用Vue的template遇到的问题"></a>使用Vue的template遇到的问题</h4><p>前几天接了一个需求-APP首页配置化。大体思路就是，后台做一个页面，这个页面上提供了N个模板，然后运营人员可以动态的添加模板，并且给每个模板进行不同的配置。比如，轮播图模板，轮播图模板可以配置一个标题，以及描述，模板可以配置多张图片，图片可以调整顺序，点击图片跳转的链接等。</p><p>我们第一期提供了10个模板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='SCOELL_IMG_01'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-scroll-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-scroll-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='TWO_IMG_01'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-two-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-two-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='TWO_IMG_02'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-two-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-two-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='THREE_IMG_01'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-three-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-three-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='THREE_IMG_02'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-three-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-three-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我举例说明，先写5个说明一下问题。有一个比较严重的问题，就是<code>v-if</code>用的太多了。这里面不能嵌入js，如果以后提供20个模板甚至更多呢？template这种方式肯定会写的很痛苦！</p><h4 id="可以尝试使用JSX解决"><a href="#可以尝试使用JSX解决" class="headerlink" title="可以尝试使用JSX解决"></a>可以尝试使用JSX解决</h4><p>所以，我们可以试试用另一种方式去写组件-JSX，在Vue中使用JSX。JSX是React的核心组成部分。Vue2.0以后才开始支持JSX的。</p><h4 id="JSX介绍"><a href="#JSX介绍" class="headerlink" title="JSX介绍"></a>JSX介绍</h4><p>JSX其实就是使用JavaScript去表示dom元素结构。</p><p><strong>所谓的 JSX 其实就是 JavaScript 对象。</strong></p><ol><li>JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML。</li><li>React.js 可以用 JSX 来描述你的组件长什么样的。</li><li>JSX 在编译的时候会变成相应的 JavaScript 对象描述。</li><li>react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上。</li></ol><p>从 JSX 到页面到底经过了什么样的过程</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g11dfngojkj30hm075aaq.jpg" alt></p><h5 id="JSX基本语法"><a href="#JSX基本语法" class="headerlink" title="JSX基本语法"></a>JSX基本语法</h5><p>在Vue中使用JSX首先需要保证Vue的版本大于2.0，然后官方的<a href="https://github.com/vuejs/jsx" target="_blank" rel="noopener">jsx</a>包,这个包支持的是Babel 7+；<br>如果是Babel 6，则需要安装<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx" target="_blank" rel="noopener">babel-plugin-transform-vue-jsx</a>包。</p><p>然后根据文档安装完以后。</p><h4 id="JSX-VS-Template"><a href="#JSX-VS-Template" class="headerlink" title="JSX VS Template"></a>JSX VS Template</h4><ol><li>JSX其实就是JavaScript对象，Template是Vue组件中render方法的输入。</li><li>JSX特别利于理解，相比较Template而言。（虽然写惯了Template，JSX的语法还需要慢慢适应。）</li><li>Tempplate对初学者比较友好。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h4 id=&quot;使用Vue的template遇到的问题&quot;&gt;&lt;a href=&quot;#使用Vue的template遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;使用Vue的template遇到的问题&quot;&gt;&lt;/a&gt;使用Vue的template遇到的问题&lt;/h4&gt;
      
    
    </summary>
    
      <category term="JSX" scheme="http://yoursite.com/categories/JSX/"/>
    
    
      <category term="JSX" scheme="http://yoursite.com/tags/JSX/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记</title>
    <link href="http://yoursite.com/2019/03/07/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/07/docker学习笔记/</id>
    <published>2019-03-06T19:26:50.000Z</published>
    <updated>2019-03-12T05:56:14.728Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="引子-环境配置的难题"><a href="#引子-环境配置的难题" class="headerlink" title="引子-环境配置的难题"></a>引子-环境配置的难题</h4><p>软件开发最大的麻烦事之一就是环境配置。解决的思路就是软件带环境安装，即安装的时候，把原始环境一模一样的复制过来。</p><h4 id="初始的尝试解决方案-虚拟机"><a href="#初始的尝试解决方案-虚拟机" class="headerlink" title="初始的尝试解决方案-虚拟机"></a>初始的尝试解决方案-虚拟机</h4><p>虚拟机就是带环境安装的一种解决方案。</p><p>缺点:</p><ol><li><p>资源占用多<br>虚拟机会独占一部分内存和硬盘空间。</p></li><li><p>冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，无法跳过。</p></li><li><p>启动慢<br>启动虚拟机的时间和启动操作系统的时间一样长。</p></li></ol><h4 id="另一种解决方案-Linux容器"><a href="#另一种解决方案-Linux容器" class="headerlink" title="另一种解决方案-Linux容器"></a>另一种解决方案-Linux容器</h4><p>由于以上缺点，Linux有另一种虚拟化技术:Linux容器。</p><p><strong>Linux容器不是模拟一个完整的操作系统，而且对进程进行隔离。</strong><br>或者说在正常的进程外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的。</p><p>由于容器是进程级别的，相比虚拟机有以下优势:</p><ol><li><p>启动快<br>启动进程肯定比启动操作系统快太多了。</p></li><li><p>资源占用少<br>容器只占用需要的资源。另外，多个容器可以共享资源。</p></li><li><p>体积小<br>容器只要包含用到的组件即可。</p></li></ol><p>结论:容器有点类似轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h4 id="噔噔噔～主角登场-Docker是个啥"><a href="#噔噔噔～主角登场-Docker是个啥" class="headerlink" title="噔噔噔～主角登场-Docker是个啥"></a>噔噔噔～主角登场-Docker是个啥</h4><p><strong>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。</strong></p><p>Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。(有了 Docker，妈妈再也不用担心环境问题。)</p><p>此外，容器还可以进行版本管理、复制、分享、修改，类似代码的管理。</p><h4 id="Docker的用途"><a href="#Docker的用途" class="headerlink" title="Docker的用途"></a>Docker的用途</h4><p>Docker 的主要用途，目前有三大类。</p><ol><li><p>提供一次性的环境。<br>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p></li><li><p>提供弹性的云服务。<br>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p></li><li><p>组建微服务架构。<br>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p></li></ol><h4 id="咦？Docker中的image是个啥"><a href="#咦？Docker中的image是个啥" class="headerlink" title="咦？Docker中的image是个啥"></a>咦？Docker中的image是个啥</h4><p><strong>Docker把应用程序及其依赖，打包在image文件里面。</strong></p><p>我们通过image文件，可以生成Docker容器。</p><p>image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</p><p>image是二进制文件。image文件可以继承别的image文件，一般来讲，尽量使用别人制作好的docker，或者基于别人的image文件进行加工。</p><h4 id="容器文件又是个啥？"><a href="#容器文件又是个啥？" class="headerlink" title="容器文件又是个啥？"></a>容器文件又是个啥？</h4><p>image文件能够生成的容器实例，这个容器实例本身也是一个文件，称为容器文件。</p><p>所以说，一旦容器生成，会同时有两个文件:image文件和容器文件。</p><p>关闭容器，并不会删除容器文件，只是容器停止运行而已。</p><h4 id="我也想做一个Docker容器，肿么办？"><a href="#我也想做一个Docker容器，肿么办？" class="headerlink" title="我也想做一个Docker容器，肿么办？"></a>我也想做一个Docker容器，肿么办？</h4><ol><li><p>编写Dockerfile<br>在项目的根目录下，新建一个文本文件.dockerignore和Dockerfile。前者是docker打包要忽略的路径;后者是docker打包的代码</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span> . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></li><li><p>创建image文件<br>在dockerfile文件的基础上使用docker image build 命令创建image文件。</p></li><li><p>生成容器<br>docker container run 命令会从image文件生成容器。</p></li></ol><h4 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h4><h5 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker version //docker客户端和服务端的版本号</span><br><span class="line">docker info //docker更加详尽的信息</span><br></pre></td></tr></table></figure><h5 id="image相关"><a href="#image相关" class="headerlink" title="image相关"></a>image相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker image ls //列出所有的docker image</span><br><span class="line">docker image rm [imageId] //删除指定image</span><br><span class="line">docker image build -t koa-demo . //创建 image 文件</span><br><span class="line">docker image prune //清除所有image</span><br></pre></td></tr></table></figure><h5 id="运行一个image并启动容器"><a href="#运行一个image并启动容器" class="headerlink" title="运行一个image并启动容器"></a>运行一个image并启动容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world //将image文件从仓库抓取到本地</span><br><span class="line">docker container run hello-world //运行image文件生成容器，每运行一次，就会新建一个容器。</span><br><span class="line">docker container start [containerID] //重复使用容器</span><br><span class="line">docker container kill [containID] //终止指定容器运行  相当于向容器里面的主进程发出 SIGKILL 信号</span><br><span class="line">docker container stop [containID] //终止指定容器运行  相当于向容器里面的主进程发出 SIGTERM 信号</span><br><span class="line">这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</span><br></pre></td></tr></table></figure><h5 id="container相关"><a href="#container相关" class="headerlink" title="container相关"></a>container相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container ls //列出正在运行的容器</span><br><span class="line">docker container ls -a //列出所有的容器，包括终止运行的容器</span><br><span class="line">docker container kill [containID] //终止指定容器运行</span><br><span class="line">docker container rm [containerID] //删除指定容器文件</span><br><span class="line">docker container prune //清除所有container</span><br><span class="line">docker system prune //清除所有</span><br></pre></td></tr></table></figure><h5 id="发布image"><a href="#发布image" class="headerlink" title="发布image"></a>发布image</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker login //登录</span><br><span class="line">docker image tag [imageName] [username]/[repository]:[tag] // 为本地的 image 标注用户名和版本。docker image tag koa-demos:0.0.1 cc/koa-demos:0.0.1</span><br><span class="line">docker image build -t [username]/[repository]:[tag] . //重新构建image文件</span><br><span class="line">docker image push [username]/[repository]:[tag] //发布image文件</span><br></pre></td></tr></table></figure><p>以上都是简单介绍。</p><p>详细请移步<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮老师的教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h4 id=&quot;引子-环境配置的难题&quot;&gt;&lt;a href=&quot;#引子-环境配置的难题&quot; class=&quot;headerlink&quot; title=&quot;引子-环境配置的难题&quot;&gt;&lt;/a&gt;引子-环境配置的难题&lt;/h4&gt;&lt;p&gt;软件开发最大的麻烦事之一就是环境配置。解决的思路就是软件带环境安装
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://yoursite.com/2019/02/27/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/02/27/原型与原型链/</id>
    <published>2019-02-26T17:10:20.000Z</published>
    <updated>2019-04-10T06:17:57.354Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每个函数都有一个特殊的属性叫作原型（<code>prototype</code>）<br>每个实例对象（<code>object</code>）都有一个私有属性（称之为<code>__proto__</code>）指向它的原型对象（<code>prototype</code>）<br>该原型对象也有一个自己的原型对象(<code>__proto__</code>) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p><p>构造函数，原型和实例三者之间的关系</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0jzrv2ditj30zk0puq4y.jpg" style="    width: 400px;    height: 300px;"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Father();</span><br><span class="line">Father.prototype === f.__proto__ <span class="comment">//true</span></span><br><span class="line">f.constructor === Father <span class="comment">//true</span></span><br><span class="line">Father.prototype.constructor === Father <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0l17qcp6vj30zk0pugn7.jpg" style="    height: 500px;"></p><p>1、原型链的最顶端是<code>null</code><br>2、所有的原型的<code>_proto_</code>都是Object的原型<br>3、所有的构造函数的<code>_proto_</code>都是Function的原型<br>4、Function的<code>_proto_</code>和<code>prototype</code>都是Function的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ <span class="comment">//null 1</span></span><br><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__ <span class="comment">//true 4</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Father.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true 3</span></span><br><span class="line">Father.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true 2</span></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true 3</span></span><br><span class="line"><span class="built_in">String</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true 2</span></span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>理解，每个函数（构造函数，或者普通函数）都有一个属性叫做原型（prototype）,<br>每个实例对象都有一个私有属性（<code>__proto__</code>），每个实例对象之间的<code>__proto__</code>指向就是原型链。</p><p>最后贴一张更全的图</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0l0c6dx6cj30u011c7ci.jpg" style="    height: 600px;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h3&gt;&lt;p&gt;每个函数都有一个特殊的属性叫作原型（&lt;code&gt;prototype&lt;/code&gt;）&lt;br&gt;每个实例对象（&lt;code&gt;object&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基础入门</title>
    <link href="http://yoursite.com/2019/02/01/MongoDB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/02/01/MongoDB基础入门/</id>
    <published>2019-02-01T10:23:29.000Z</published>
    <updated>2019-02-14T06:17:49.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB基础入门（基础篇）"><a href="#MongoDB基础入门（基础篇）" class="headerlink" title="MongoDB基础入门（基础篇）"></a>MongoDB基础入门（基础篇）</h2><p>最新心血来潮，准备在网上学习一下Vue+Node+MongoDB。之前接触过MySQL，但是MongoDB跟MySQL还是有区别的。话不多说：</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>一个mongodb中可以建立多个数据库。</p><p>每个数据库里面有多个表（也叫做集合）。</p><p>表里面存储的数据格式就是一个json，这也是区别于SQL的地方。</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>这一步就省略了，自己Google去吧。我在mac下用的homebrew</p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>在命令行中输入mongo就会连接到数据库</p><h4 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h4><p><code>show dbs</code>           查看所有数据库<br><code>use DATABASE_NAME</code>  创建数据库或者切换到该数据库<br><code>db.dropDatabase()</code>  删除数据库</p><h4 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h4><p><code>show tables</code>                           查看已有表<br><code>show collections</code>                      查看已有集合<br><code>db.createCollection(name, options)</code>    创建集合<br><code>db.COLLECTION_NAME.drop()</code>             删除集合</p><p><strong>PS：show tables 和 show collections 的区别，网上还么有搜到，但是实际操作了一下，发现两者是一样的。</strong></p><p>直接在COLLECTION_NAME集合中插入数据的时候，会自动创建COLLECTION_NAME集合<br><code>db.COLLECTION_NAME.insert({&quot;name&quot; : &quot;Chance&quot;})</code></p><p><strong>情况1：如果没有新建一个数据库的话，会默认在test数据库中新建一个COLLECTION_NAME集合（表）</strong><br><strong>情况2：在该命令之前新建了一个数据库的话，会在该数据库下新建一个COLLECTION_NAME集合（表）</strong></p><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>增删改查的操作是基于集合来的，所有统一的格式都是db.COLLECTION_NAME.***</p><p>增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(document)</span><br></pre></td></tr></table></figure><p>删<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(query, projection)</span><br></pre></td></tr></table></figure></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>解释/说明</th></tr></thead><tbody><tr><td>show dbs</td><td>查看所有数据库</td></tr><tr><td>db</td><td>显示当前数据库对象或集合</td></tr><tr><td>use DATABASE_NAME</td><td>如果数据库不存在，则创建数据库，否则切换到指定数据库。</td></tr><tr><td>show tables</td><td>查看该数据库下的所有表</td></tr><tr><td>show collections</td><td>查看该数据库下的所有集合</td></tr><tr><td>db.dropDatabase()</td><td>删除数据库</td></tr><tr><td>db.COLLECTION_NAME.insert({“name”:”Chance”})</td><td>创建集合并向其中插入一些数据</td></tr><tr><td>db.createCollection(name, options)</td><td>创建集合</td></tr><tr><td>db.COLLECTION_NAME.drop()</td><td>删除当前集合</td></tr><tr><td>db.COLLECTION_NAME.insert(document)</td><td>增</td></tr><tr><td>db.COLLECTION_NAME.remove()</td><td>删</td></tr><tr><td>db.COLLECTION_NAME.update()</td><td>改</td></tr><tr><td>db.COLLECTION_NAME.insert(document)</td><td>查</td></tr></tbody></table><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>正常情况下，node中不会直接使用mongo的语法，会使用mongoose<br><a href="https://mongoosejs.com/" target="_blank" rel="noopener">mongoose官网</a><br><a href="https://www.bilibili.com/video/av41033371" target="_blank" rel="noopener">mongoose教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MongoDB基础入门（基础篇）&quot;&gt;&lt;a href=&quot;#MongoDB基础入门（基础篇）&quot; class=&quot;headerlink&quot; title=&quot;MongoDB基础入门（基础篇）&quot;&gt;&lt;/a&gt;MongoDB基础入门（基础篇）&lt;/h2&gt;&lt;p&gt;最新心血来潮，准备在网上学习
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目的整体认识</title>
    <link href="http://yoursite.com/2019/01/26/Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2019/01/26/Vue项目的整体认识/</id>
    <published>2019-01-25T21:08:20.000Z</published>
    <updated>2019-02-16T15:55:27.103Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Vue项目的一些整体认识"><a href="#Vue项目的一些整体认识" class="headerlink" title="Vue项目的一些整体认识"></a>Vue项目的一些整体认识</h4><hr><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>其实从16年11月28日进公司实习至今，已经两年多了。刚去公司的时候，我们当时前端就3个人，那会也是第一次接触Vue的。刚接触的感觉，就是，这玩意，这么神奇。然后平时做需求也是，能把需求做了就行。至今还记得第一次前后端联调，第一次项目上线。</p><p>虽然很早就接触了，但是我们项目的很多东西，我都没有认真的静下来去看。导致很多东西都是一知半解的。直到自己有一天幡然醒悟。</p><p>我们的项目是我们前端小组长搭建的一个脚手架,包括vue cli+webpack配置+node(express)。使用 node 代替 NGINX 提供请求代理、WebViewJavaScriptbridge 与客户端交互、Vue 全家桶作为开发框架，并且用 express 搭建了 mock 框架。</p><h4 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h4><p>首先，Vue没有什么神奇的，最后上线的东西就是一个dist文件，里面一个入口文件index.html+一个static文件，static文件里面是打包后的图片，css和js。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzj6d8fhqvj30hk0k40ue.jpg" alt></p><p>以本地开发为例，<code>npm run dev</code> 以后，正常情况下会启动一个本地服务，然后当用户访问<code>localhost:8080/login</code>，本地服务器会返回打包后的<code>index.html</code>文件，index文件里面引入了main.js即js代码的主入口文件。</p><p>这部分是Vue项目中的node服务器处理的，这也是node服务器的第一个作用，方便本地调试。服务器会把收到的请求转到index.html。具体可参考作用1。</p><p>main.js文件里面其实会实例化一个Vue对象，并挂载在某个dom元素下。实例化的Vue对象里面有Vue Router和Vuex。Vuex按需要来决定要不要引用。Vue Router会在你访问某个路径的时候，比对当前的location.pathname和Vue Router中的某一个path是否可以匹配上，能够匹配上的话，会渲染对应的组件页面。</p><p>以上就是对Vue整个项目的一个认识。Vue项目中用到了node，说一下node的作用吧。</p><h5 id="作用1"><a href="#作用1" class="headerlink" title="作用1"></a>作用1</h5><p>服务器会把收到的请求转到index.html。（PS：test环境和production环境是这样处理的。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendFile(webpackConfig.output.path + <span class="string">'/index.html'</span>, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/html; charset=UTF-8'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中，dev环境下使用webpack-dev-middleware中间件来做。这么做的其中一个好处是，不在磁盘中存储文件，而是直接生成在内存中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> devMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)(compiler, &#123;</span><br><span class="line">  publicPath: webpackConfig.output.publicPath,</span><br><span class="line">  stats: &#123;</span><br><span class="line">    colors: <span class="literal">true</span>,</span><br><span class="line">    chunks: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve webpack bundle output</span></span><br><span class="line">app.use(devMiddleware)</span><br></pre></td></tr></table></figure></p><h5 id="作用2"><a href="#作用2" class="headerlink" title="作用2"></a>作用2</h5><p>使用中间件代理解决跨域问题，我们用了一个proxy-middleware的中间件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy api requests</span></span><br><span class="line"><span class="built_in">Object</span>.keys(apiMap).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> api = apiMap[key];</span><br><span class="line">  app.use(api.path, proxy(api.proxy));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="作用3"><a href="#作用3" class="headerlink" title="作用3"></a>作用3</h5><p>请求一些静态资源，或者本地不经过webpack编译的图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serve pure static assets</span></span><br><span class="line"><span class="keyword">var</span> staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory);</span><br><span class="line">app.use(staticPath, express.static(path.resolve(__dirname, <span class="string">'../static'</span>)))</span><br></pre></td></tr></table></figure><h5 id="作用4"><a href="#作用4" class="headerlink" title="作用4"></a>作用4</h5><p>本地调试的时候mock数据 else部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv.proxy) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(apiMap).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> api = apiMap[key];</span><br><span class="line">    app.use(api.path, proxy(api.proxy));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mock api requests</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mockDir = path.resolve(__dirname, <span class="string">'../mock'</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">setMock</span>(<span class="params">mockDir</span>) </span>&#123;</span><br><span class="line">    fs.readdirSync(mockDir).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> filePath = path.resolve(mockDir, file);</span><br><span class="line">      <span class="keyword">var</span> mock;</span><br><span class="line">      <span class="keyword">if</span> (fs.statSync(filePath).isDirectory()) &#123;</span><br><span class="line">        setMock(filePath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(file)) &#123;</span><br><span class="line">          mock = <span class="built_in">require</span>(filePath);</span><br><span class="line">          app.use(mock.api, mock.response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(mockDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>这些话是说给自己的。</p><p>首先鼓励的话，从最开始看到项目那一堆代码时的一脸懵逼，到现在基本都明白了。（不说全部都明白了，但是就算有不知道的，也知道去搜索然后了解对应的部分是做什么的）。当然，这个经历的时间有些长，包括自己学习node，koa+express。这个过程也是很美好的，收获也不少。</p><p>然后警钟的话，</p><p><strong>爱一行，干一行；干一行，爱一行。</strong>最开始虽然说是为了互联网行业的高薪来的，但是起码当时选的是你感兴趣的前端，（PS：这话说得可能就不对，因为真正的程序员眼里是不分前后端的），所以，爱一行，干一行。</p><p><strong>时刻保持着对知识的好奇以及极强的求知欲。</strong> 这句话，自己好好反思。</p><p>最后，没有最后。加油！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Vue项目的一些整体认识&quot;&gt;&lt;a href=&quot;#Vue项目的一些整体认识&quot; class=&quot;headerlink&quot; title=&quot;Vue项目的一些整体认识&quot;&gt;&lt;/a&gt;Vue项目的一些整体认识&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; cl
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vuex存储的时候遇到的问题及解决方案</title>
    <link href="http://yoursite.com/2019/01/23/Vuex%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/01/23/Vuex存储的时候遇到的问题及解决方案/</id>
    <published>2019-01-22T19:40:06.000Z</published>
    <updated>2019-01-22T12:19:06.464Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex使用心得</p><hr><h5 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h5><p>使用Vuex遇到过两个问题。<br>1.页面刷新或者跳转到第三方再回来，数据是会丢掉的。即Vuex持久化存储问题。<br>2.在Vuex中存储一个Falsey值（PS：false,’’,null,undefined,NaN）的时候，Vuex中存储不了。</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>第一个问题，网上有很多解决方案。使用<a href="https://github.com/robinvdvleuten/vuex-persistedstate" target="_blank" rel="noopener">vuex-persistedstate</a>。具体看文档，我就不细说了，可以使用localStorage,也可以使用cookie。</p><p>第二个问题，其实并不是Vuex本身的问题，而是因为我们项目中统一为每一个state字段生成了mutations方法。</p><p>generate方法中的语句<code>state[name] = value || state[name];</code>判断，value为false的时候，确实存不进来。</p><p>然后自己重新写了一个<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateToken(state,newToken)&#123;</span><br><span class="line">  state.token = newToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多页面共享数据</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    aaa: <span class="string">''</span>,</span><br><span class="line">    bbb:<span class="string">''</span>,</span><br><span class="line">    ccc: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据变更</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    updateToken(state,newToken)&#123;</span><br><span class="line">      state.token = newToken;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 mutations 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, value</span>) </span>&#123;</span><br><span class="line">    state[name] = value || state[name];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个 state 字段生成对应的 mutations 方法</span></span><br><span class="line"><span class="built_in">Object</span>.keys(options.state).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  options.mutations[key] = generate(key);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vuex使用心得&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h5&gt;&lt;p&gt;使用Vuex遇到过两个问题。&lt;br&gt;1.页面刷新或者跳转到第三方再回来，数据是会丢掉的。即Vuex
      
    
    </summary>
    
    
      <category term="Vuex" scheme="http://yoursite.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>find-记一次生产的bug排查</title>
    <link href="http://yoursite.com/2019/01/19/find-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E7%9A%84bug%E6%8E%92%E6%9F%A5/"/>
    <id>http://yoursite.com/2019/01/19/find-记一次生产的bug排查/</id>
    <published>2019-01-18T21:14:12.000Z</published>
    <updated>2019-01-18T13:54:29.023Z</updated>
    
    <content type="html"><![CDATA[<h4 id="记一次生产的bug排查"><a href="#记一次生产的bug排查" class="headerlink" title="记一次生产的bug排查"></a>记一次生产的bug排查</h4><hr><h5 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h5><p>上线一周，最近的用户量增加了一些，今天下午的时候，群里一直被@，有一部分用户打开产品流程首页的时候白屏。</p><h5 id="bug复现"><a href="#bug复现" class="headerlink" title="bug复现"></a>bug复现</h5><p>借了用户的账号密码登录以后发现，我手机上是可以打开的。然后看了用户的手机系统是安卓5.0，不是很高的系统。然后找了一个测试的5.0的手机试了一下，还是可以打开的。反映出问题的用户中，vivo的机型比较多。然鹅，我们这边vivo的测试机没有5.0以下版本的。后来接到了一个魅族和小米的手机，分别是5.0和4.4的系统。登录账号，发现bug复现了。</p><h5 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h5><p>1.装了生产的包，打开chrome的调试功能(chrome://inspect/#devices);发现webpack打包以后的main文件里面的1行3000多列出现的报错。去代码中定位了一下，发现了这段代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stepObj = allStep.find(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.routeName === currentName;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2.chrome模拟打开页面的时候，在控制台输入<code>navigator.userAgent</code>，发现这个浏览器的是chrome 43。chrome43支持find语法吗？</p><p>3.去<a href="https://caniuse.com/#search=find" target="_blank" rel="noopener">caniuse</a>中搜索find的兼容性，发现chrome44以后的版本才支持find语法。</p><p>至此，问题已经定位到了。我们使用了find语法，但是用户的浏览器版本太低不支持。但是我们项目中使用了babel了呀?</p><h5 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h5><p>但是我们项目中使用了babel了呀?</p><p>虽然使用了babel，但是没有配置转换find语法。</p><p>google搜索babel find然后找到一条Stack Overflow的<a href="https://stackoverflow.com/questions/32401513/array-find-doesnt-work-with-babel" target="_blank" rel="noopener">帖子</a>。解决方法也列出来了。</p><p>至此，结束。</p><h5 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h5><p>当然了，还没有结束呢。</p><p>页面可以打开了，但是又出现另一个问题了。等着下周客户端一起检查一下。</p><h5 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h5><p>1.遇到bug心态一定要保持好，用我同事的话，你不觉得这样子一步步的去定位bug，跟侦探破案一样刺激吗？（PS：感谢他，以上有很多都是他发现的，受益匪浅）。</p><p>2.用好google搜索，Stack Overflow,github等这些国外技术社区，真的会收益良多。（PS：百度是真的垃圾，此处略去一万字）</p><p>3.英语好真的很重要啊。那天看了一篇文章，英语对一个程序员来说重要吗？回答是，如果英语不好不影响你做一个程序员；但是你想学好一门编程语言，那英语实在是太重要了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;记一次生产的bug排查&quot;&gt;&lt;a href=&quot;#记一次生产的bug排查&quot; class=&quot;headerlink&quot; title=&quot;记一次生产的bug排查&quot;&gt;&lt;/a&gt;记一次生产的bug排查&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;前提概要&quot;&gt;&lt;a href=&quot;#前提概要&quot; cl
      
    
    </summary>
    
      <category term="bug排查" scheme="http://yoursite.com/categories/bug%E6%8E%92%E6%9F%A5/"/>
    
    
      <category term="find bug" scheme="http://yoursite.com/tags/find-bug/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://yoursite.com/2019/01/16/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/16/git学习笔记/</id>
    <published>2019-01-16T13:52:57.000Z</published>
    <updated>2019-01-18T13:02:15.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>git是14年才接触的，然后也没有系统的学习过。都是平时遇到一点问题，去搜一搜。</p><p>安装部分就不说了。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz9dildkoxj30cq06iaa8.jpg" alt><br>1.工作区<br>就是电脑上写代码部分<br>2.版本库<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><blockquote><p>mkdir learngit            新建一个文件夹<br>  cd learngit               并进入该文件夹<br>  git init                  初始化，把该文件夹变成git可以管理的仓库（会产生一个.git文件）<br>  git add <file>            把文件修改添加到暂存区（Stage）<br>  git commit -m <message>   把暂存区的所有内容提交到当前分支</message></file></p></blockquote><h5 id="查看状态及回退"><a href="#查看状态及回退" class="headerlink" title="查看状态及回退"></a>查看状态及回退</h5><blockquote><p>git status                  查看当前仓库状态<br>  git diff                    查看详细的修改内容<br>  git diff HEAD – readme.txt 查看工作区和版本库里面最新版本的区别<br>  git log                     查看从最近到最远的提交日志<br>  git log –pretty=oneline    查看从最近到最远的简洁版提交日志<br>  git log –graph             查看分支合并图<br>  git reflog                  查看历史命令<br>  git reset –hard HEAD^      回退到上一个版本<br>  git reset –hard HEAD^^     回退到上上一个版本<br>  git reset –hard HEAD~10    回退到往上10个版本<br>  git reset –hard commit_id  回退到固定某个版本</p></blockquote><h5 id="放弃修改"><a href="#放弃修改" class="headerlink" title="放弃修改"></a>放弃修改</h5><blockquote><p>git checkout – <file>      丢弃工作区的修改<br>  git reset HEAD <file>       丢弃暂存区的修改，回到工作区<br>  git rm <file>               从版本库中删除掉某文件</file></file></file></p></blockquote><h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><blockquote><p>git remote add origin git@server-name:path/repo-name.git  关联一个远程仓库<br>  git push -u origin <name>   关联后，第一次推送master分支的所有内容<br>  git push origin <name>      以后的正常提交<br>  git checkout -b <name>      新建dev分支并切换到dev分支<br>  相当于<br>  git branch <name>           新建dev分支<br>  git checkout <name>         切换到dev分支</name></name></name></name></name></p></blockquote><h5 id="合并删除分支"><a href="#合并删除分支" class="headerlink" title="合并删除分支"></a>合并删除分支</h5><blockquote><p>git branch                  查看当前分支<br>  git merge <name>            合并某个分支到当前分支<br>  git branch -d <name>        删除分支<br>  git branch -D <name>        强制删除分支</name></name></name></p></blockquote><h5 id="临时存储"><a href="#临时存储" class="headerlink" title="临时存储"></a>临时存储</h5><blockquote><p>git stash                   把当前工作现场存储起来<br>  git stash list              查看已存储<br>  git stash apply             把已存储的内容恢复，内容不删除<br>  git stash drop              删除已存储的内容<br>  git stash pop               恢复内容以后同时删除内容</p></blockquote><h5 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h5><blockquote><p>git remote                  查看远程库信息<br>  git remote -v               查看远程库详细信息<br>  git push origin <name>      把该分支上的所有本地提交推送到远程库<br>  git checkout -b <name> origin/<name>  在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致<br>  git branch –set-upstream <name> origin/<name>  建立本地分支和远程分支的关联<br>  git pull                    从远程合并<br>  如果提示no tracking information<br>  则说明本地分支和远程分支的链接关系没有创建，可以使用<br>  git branch –set-upstream-to <name> origin/<name></name></name></name></name></name></name></name></p></blockquote><h5 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h5><blockquote><p>标签总是和某个commit挂钩。<br>  git tag <tagname>           用于新建一个标签，默认为HEAD，也可以指定一个commit id<br>  git tag <tagname> commit_id 给指定一个commit_id新建一个标签<br>  git tag                     查看所有标签<br>  git show <tagname>          查看标签信息<br>  git tag -d <tagname>        删除一个本地标签<br>  git push origin <tagname>   推送某个标签到远程（PS：创建的标签都只存储在本地）<br>  git push origin –tags      一次性推送全部尚未推送到远程的本地标签<br>  如果标签已经推送到远程，要删除远程标签就麻烦一点<br>  git tag -d <tagname>                   删除一个本地标签<br>  git push origin :refs/tags/<tagname>   删除一个远程标签</tagname></tagname></tagname></tagname></tagname></tagname></tagname></p></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>git是Linux之父linus创造的，属于一种分布式版本控制系统。（PS：区别于集中式的版本控制系统）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;p&gt;git是14年才接触的，然后也没有系统的学习过。都是平时遇到一点问题，去搜一搜。&lt;/p&gt;
&lt;p&gt;安装部分就不说了。&lt;/p&gt;
&lt;h4 id=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="http://yoursite.com/2019/01/12/BFC/"/>
    <id>http://yoursite.com/2019/01/12/BFC/</id>
    <published>2019-01-11T20:31:59.000Z</published>
    <updated>2019-01-18T13:03:31.352Z</updated>
    
    <content type="html"><![CDATA[<h4 id="BFC是什么"><a href="#BFC是什么" class="headerlink" title="BFC是什么"></a>BFC是什么</h4><p>前几天被人问到了BFC，一脸懵逼。赶紧看看，简单总结一下。</p><ul><li><a href="#概念">概念</a></li><li><a href="#BFC的特性">BFC的特性</a></li><li><a href="#如何触发BFC">如何触发BFC</a></li></ul><p>简单总结一下：</p><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><blockquote><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流。</p></blockquote><p>PS:区别于普通流，常见的还有浮动（float），绝对定位（absolute）</p><p><strong>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</strong></p><h5 id="BFC的特性："><a href="#BFC的特性：" class="headerlink" title="BFC的特性："></a>BFC的特性：</h5><p>1.同一个BFC中的margin会重叠<br>2.浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。<br>3.BFC可以阻止元素被浮动元素覆盖。</p><h5 id="如何触发BFC：-PS：满足一下任一条件即可触发"><a href="#如何触发BFC：-PS：满足一下任一条件即可触发" class="headerlink" title="如何触发BFC：(PS：满足一下任一条件即可触发)"></a>如何触发BFC：(PS：满足一下任一条件即可触发)</h5><p>1.body根元素<br>2.浮动元素：float除none以外的值<br>3.绝对定位元素：position 等于absolute或者fixed<br>4.display等于 inline-block、table-cells、flex<br>5.overflow等于除了 visible 以外的值 (hidden、auto、scroll)<br>类似函数作用域。</p><p><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;BFC是什么&quot;&gt;&lt;a href=&quot;#BFC是什么&quot; class=&quot;headerlink&quot; title=&quot;BFC是什么&quot;&gt;&lt;/a&gt;BFC是什么&lt;/h4&gt;&lt;p&gt;前几天被人问到了BFC，一脸懵逼。赶紧看看，简单总结一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>如何使用七牛云</title>
    <link href="http://yoursite.com/2019/01/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    <id>http://yoursite.com/2019/01/06/如何使用七牛云/</id>
    <published>2019-01-05T23:59:38.000Z</published>
    <updated>2019-01-13T10:45:17.217Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一个需求，使用七牛云的sdk来上传图片。  七牛云的文档写的可以更好一点。</p><p>html部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">'imageUrl'</span> <span class="attr">type</span>=<span class="string">"file"</span> @<span class="attr">click</span>=<span class="string">"uploadImage('imageUrl')"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个用的是vue做的，所以会有一个ref标签，直接用原生html写的可以忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上传图片</span></span><br><span class="line">uploadImage(ref) &#123;</span><br><span class="line">  <span class="comment">//选中input元素</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span>(ref === <span class="string">'imageUrl'</span>)&#123;</span><br><span class="line">    input = <span class="keyword">this</span>.$refs[ref];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    input = <span class="keyword">this</span>.$refs[ref][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//input在onchange的时候触发</span></span><br><span class="line">  input.onchange = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//localFileName 文件的本地名，一般是一个绝对地址的路径</span></span><br><span class="line">    <span class="keyword">let</span> localFileName = input.value;</span><br><span class="line">    <span class="comment">//文件名</span></span><br><span class="line">    <span class="keyword">let</span> suffix = localFileName.substring(localFileName.lastIndexOf(<span class="string">"."</span>),localFileName.length);<span class="comment">//后缀名</span></span><br><span class="line">    <span class="keyword">let</span> fileName = localFileName.substring(localFileName.lastIndexOf(<span class="string">"\\"</span>)+<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> file = input.files[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要先获取上传七牛云的token</span></span><br><span class="line">    axios.get(<span class="string">`<span class="subst">$&#123;GET_UPLOAD_TOKEN&#125;</span>?fileName=<span class="subst">$&#123;fileName&#125;</span>`</span>).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(response.code === <span class="number">2000</span>)&#123;</span><br><span class="line">        <span class="comment">//七牛云token</span></span><br><span class="line">        <span class="keyword">const</span> token = response.data;</span><br><span class="line">        <span class="keyword">const</span> observer = &#123;</span><br><span class="line">          next(response)&#123;</span><br><span class="line">            <span class="keyword">let</span> process = <span class="built_in">Math</span>.floor(response.total.percent)+<span class="string">'%'</span>;</span><br><span class="line">            <span class="keyword">if</span>(process === <span class="string">'100%'</span>)&#123;</span><br><span class="line">              <span class="comment">//这里可以写上传成功的处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          error(err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">          &#125;,</span><br><span class="line">          complete(res1)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res1);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> key = fileName;<span class="comment">//上传文件名</span></span><br><span class="line">        <span class="keyword">const</span> putExtra = &#123;</span><br><span class="line">            fname: fileName,</span><br><span class="line">            params: &#123;&#125;,</span><br><span class="line">            mimeType:[<span class="string">"image/png"</span>, <span class="string">"image/jpeg"</span>, <span class="string">"image/gif"</span>]</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> config = &#123;</span><br><span class="line">          useCdnDomain: <span class="literal">true</span>,</span><br><span class="line">          region: qiniu.region.z0</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> observable = qiniu.upload(file, key, token, putExtra, config);</span><br><span class="line">        observable.subscribe(observer) <span class="comment">// 上传开始</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>以上结束。当然了，七牛云的存储那边也需要设置一下。具体查看文档就好了。其实js部分就是七牛云提供的，html部分，我刚开始很纠结，不知道能不能用form表单的action来操作。</p><p><a href="https://developer.qiniu.com/kodo/sdk/1283/javascript" target="_blank" rel="noopener">七牛云的文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做了一个需求，使用七牛云的sdk来上传图片。  七牛云的文档写的可以更好一点。&lt;/p&gt;
&lt;p&gt;html部分&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="七牛云" scheme="http://yoursite.com/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>js继承方法总结</title>
    <link href="http://yoursite.com/2018/12/14/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/14/js继承方法总结/</id>
    <published>2018-12-13T20:31:20.000Z</published>
    <updated>2019-03-28T02:25:31.324Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="js继承方法"><a href="#js继承方法" class="headerlink" title="js继承方法"></a>js继承方法</h3><ul><li><a href="#1原型链继承">原型链继承</a></li><li><a href="#2借用构造函数继承">借用构造函数继承</a></li><li><a href="#3组合继承">组合继承</a></li><li><a href="#4原型式继承">原型式继承</a></li><li><a href="#5寄生式继承">寄生式继承</a></li><li><a href="#6寄生组合式继承">寄生组合式继承</a></li><li><a href="#7混入方式继承多个对象">混入方式继承多个对象</a></li><li><a href="#8ES6类继承extends">ES6类继承extends</a></li><li><a href="#总结">总结</a><h4 id="1原型链继承"><a href="#1原型链继承" class="headerlink" title="1原型链继承"></a>1原型链继承</h4>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。<blockquote><p>继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里是关键，创建Father的实例，并将该实例赋值给Son.prototype</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy5eirt2pxj30m80bldjb.jpg" alt><br>原型链方案存在的缺点：</p><ul><li><strong>多个实例对引用类型的操作会被篡改。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure><h4 id="2借用构造函数继承"><a href="#2借用构造函数继承" class="headerlink" title="2借用构造函数继承"></a>2借用构造函数继承</h4><blockquote><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自Father</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.color.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//"red,green,blue,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance2.color);<span class="comment">//"red,green,blue"</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>Father.call(this)</code>，创建子类实例时调用<code>Father</code>构造函数，于是<code>Son</code>的每个实例都会将<code>Father</code>中的属性复制一份。</p><p>借用构造函数继承的缺点：</p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h4 id="3组合继承"><a href="#3组合继承" class="headerlink" title="3组合继承"></a>3组合继承</h4><blockquote><p>组合上述两种方法就是组合继承。用<strong>原型链实现对原型属性和方法的继承</strong>，用<strong>借用构造函数技术来实现实例属性的继承</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用Father()</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用Father()</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 重写Son.prototype的constructor属性，指向自己的构造函数Son</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>组合继承的缺点：</p><ul><li>第一次调用Father()：给Son.prototype写入两个属性name，color。</li><li>第二次调用Father()：给instance1写入两个属性name，color。</li></ul><p>实例对象instance1上的两个属性就屏蔽了其原型对象Son.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p><h4 id="4原型式继承"><a href="#4原型式继承" class="headerlink" title="4原型式继承"></a>4原型式继承</h4><blockquote><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<strong>浅复制</strong>，将构造函数F的原型直接指向传入的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure><p>原型式继承缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数<br>另外，ES5中存在Object.create()的方法，能够代替上面的object方法。</li></ul><h4 id="5寄生式继承"><a href="#5寄生式继承" class="headerlink" title="5寄生式继承"></a>5寄生式继承</h4><blockquote><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">// 通过调用 object() 函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强对象</span></span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure><p>寄生式继承的缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h4 id="6寄生组合式继承"><a href="#6寄生组合式继承" class="headerlink" title="6寄生组合式继承"></a>6寄生组合式继承</h4><blockquote><p>结合借用构造函数(2)传递参数和寄生模式(5)实现继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">son, father</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(father.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = son;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  son.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类原型指向子类</span></span><br><span class="line">inheritPrototype(Son, Father);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"xyc"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son(<span class="string">"lxy"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">"2"</span>); <span class="comment">// ["red", "blue", "green", "2"]</span></span><br><span class="line">instance1.colors.push(<span class="string">"3"</span>); <span class="comment">// ["red", "blue", "green", "3"]</span></span><br></pre></td></tr></table></figure><ul><li>这个例子的高效率体现在它只调用了一次<code>Father</code>构造函数，并且因此避免了在<code>Son.prototype</code>上创建不必要的、多余的属性。<br>于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code>和<code>isPrototypeOf()</code></li><li>这是最成熟的方法，也是现在库实现的方法</li></ul><h4 id="7混入方式继承多个对象"><a href="#7混入方式继承多个对象" class="headerlink" title="7混入方式继承多个对象"></a>7混入方式继承多个对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p><h4 id="8ES6类继承extends"><a href="#8ES6类继承extends" class="headerlink" title="8ES6类继承extends"></a>8ES6类继承extends</h4><p>extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    get area() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    calcArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p>extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">son, father</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">    son.prototype = <span class="built_in">Object</span>.create(father &amp;&amp; father.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: son,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (father) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf</span><br><span class="line">            ? <span class="built_in">Object</span>.setPrototypeOf(son, father)</span><br><span class="line">            : son.__proto__ = father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、ES5继承和ES6继承的区别</p><ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li><li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;js继承方法&quot;&gt;&lt;a href=&quot;#js继承方法&quot; class=&quot;headerlink&quot; title=&quot;js继承方法&quot;&gt;&lt;/a&gt;js继承方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1原型链继承&quot;&gt;原型链继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="http://yoursite.com/2018/12/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/12/07/浏览器缓存机制/</id>
    <published>2018-12-06T16:43:58.000Z</published>
    <updated>2019-02-15T02:36:29.106Z</updated>
    
    <content type="html"><![CDATA[<hr><p>（PS:这篇文章，就是纯粹的纸上谈兵哈，并没有实践过。所以一定要自己动手试试。）</p><h4 id="浏览器缓存的基本原理"><a href="#浏览器缓存的基本原理" class="headerlink" title="浏览器缓存的基本原理"></a>浏览器缓存的基本原理</h4><p>1）浏览器在加载资源时，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。<br>2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过<code>last-modified</code>和<code>etag</code>验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源<br>3）如果前面两者都没有命中，直接从服务器加载资源</p><h4 id="浏览器缓存类型："><a href="#浏览器缓存类型：" class="headerlink" title="浏览器缓存类型："></a>浏览器缓存类型：</h4><p>浏览器的缓存分为两种：强缓存和协商缓存。</p><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源。</p><p>协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>共同点：两者都是从客户端缓存中读取资源；区别：强缓存不会向服务器发送请求，协商缓存会向服务器发送请求。</p><h4 id="强缓存相关字段"><a href="#强缓存相关字段" class="headerlink" title="强缓存相关字段"></a>强缓存相关字段</h4><p>Expires和Cache-Control</p><p>1）Expires</p><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。<br>Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p><blockquote><p>Expires: Wed, 11 May 2018 07:20:00 GMT</p></blockquote><p>2）Cache-Control</p><p>Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间。</p><p>相对Expires而言，max-age是距离请求发起的时间的秒数。</p><blockquote><p>Cache-Control: max-age=315360000</p></blockquote><h4 id="协商缓存相关字段"><a href="#协商缓存相关字段" class="headerlink" title="协商缓存相关字段"></a>协商缓存相关字段</h4><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p><p>1）Last-Modified，If-Modified-Since</p><p><code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</p><p>但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag</p><p>2）ETag、If-None-Match</p><p><code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的</p><p><code>If-None-Match</code>的header会将上次返回的<code>Etag</code>发送给服务器，询问该资源的<code>Etag</code>是否有更新，有变动就会发送新的资源回来</p><p>3）ETag的优先级比Last-Modified更高</p><p>具体为什么要用<code>ETag</code>，主要出于下面几种情况考虑：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p><a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">参考链接</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226262&amp;idx=1&amp;sn=2128db200b88479face67ed8e095757c&amp;chksm=bd4959128a3ed0041b43a5683c75c4b88c7d35fac909a59c14b4e9fc11e8d408680b171d2706&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;（PS:这篇文章，就是纯粹的纸上谈兵哈，并没有实践过。所以一定要自己动手试试。）&lt;/p&gt;
&lt;h4 id=&quot;浏览器缓存的基本原理&quot;&gt;&lt;a href=&quot;#浏览器缓存的基本原理&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存的基本原理&quot;&gt;&lt;/a&gt;浏览器
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>js event loop</title>
    <link href="http://yoursite.com/2018/12/06/js-event-loop/"/>
    <id>http://yoursite.com/2018/12/06/js-event-loop/</id>
    <published>2018-12-06T15:45:40.000Z</published>
    <updated>2019-03-29T11:48:33.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><hr><p>JavaScript是单线程的，这与它的用途有关。</p><h4 id="为什么JavaScript是单线程的？"><a href="#为什么JavaScript是单线程的？" class="headerlink" title="为什么JavaScript是单线程的？"></a>为什么JavaScript是单线程的？</h4><p>假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><h4 id="任务分类"><a href="#任务分类" class="headerlink" title="任务分类"></a>任务分类</h4><h5 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h5><p>因为JavaScript是单线程的，如果加载一个图片，需要很久，那么网页就会阻塞。因此，从广义上来讲任务分为两类：</p><ul><li>同步任务<blockquote><p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</p></blockquote></li><li>异步任务<blockquote><p>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p></blockquote></li></ul><p>执行顺序：</p><pre><code>（1）所有同步任务都在主线程上执行，形成一个执行栈。（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。</code></pre><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1jrpu6q3ij30g50boq3q.jpg" alt></p><h5 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h5><p>对任务进行更精细的定义的话，也可以分为两类：</p><ul><li>宏任务（macro-task）<blockquote><p>包括整体代码script、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI Rendering</p></blockquote></li><li>微任务（micro-task）<blockquote><p>new Promise().then(回调)、Process.nextTick、Object.observe、MutationObserver</p></blockquote></li></ul><h4 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h4><p>执行顺序：</p><pre><code>1.当某个宏任务执行完后,会查看是否有微任务队列。2-1.如果有，先执行微任务队列中的所有任务，2-2.如果没有，会读取宏任务队列中排在最前的任务，3.执行宏任务的过程中，遇到微任务，依次加入微任务队列。4.栈空后，再次读取微任务队列里的任务，依次类推。</code></pre><h4 id="Node中的Event-Loop"><a href="#Node中的Event-Loop" class="headerlink" title="Node中的Event Loop"></a>Node中的Event Loop</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1js5cwo3wj30m808saad.jpg" alt></p><p>Node中的Event Loop不同于浏览器。Node运行机制如下：</p><ul><li>V8引擎解析JavaScript脚本。</li><li>解析后的代码，调用Node API。</li><li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ul><p>其中libuv引擎中的事件循环分为6个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1js4x78vxj30lg0jm76o.jpg" alt></p><p>node中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）</p><ul><li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li><li>I/O callbacks阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅node内部使用</li><li>poll 阶段：获取新的I/O事件,适当的条件下node将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close事件回调</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p><ul><li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li><li>Node端，microtask 在事件循环的各个阶段之间执行</li><li>Node11版本中，Event Loop运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这点就跟浏览器端一致。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>浏览器端：</p><p>先执行宏任务，宏任务执行完以后，执行当前的微任务。然后再依次往后执行，循环。</p><p>Node端：</p><p>1.Node版本11 同浏览器端</p><p>2.Node版本10及以下</p><p>按照poll=&gt;check=&gt;close callbacks=&gt;timers=&gt;I/O callbacks=&gt;idle,prepare的顺序执行，微任务会在每个阶段执行完以后执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Event-Loop&quot;&gt;&lt;a href=&quot;#Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;Event Loop&quot;&gt;&lt;/a&gt;Event Loop&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;JavaScript是单线程的，这与它的用途有关。&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="event loop" scheme="http://yoursite.com/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2018/12/05/markdown/"/>
    <id>http://yoursite.com/2018/12/05/markdown/</id>
    <published>2018-12-05T14:13:45.000Z</published>
    <updated>2018-12-06T05:11:01.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="markdown常用语法"><a href="#markdown常用语法" class="headerlink" title="markdown常用语法"></a>markdown常用语法</h3><hr><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#1">标题</a></li><li><a href="#2">引入代码</a></li><li><a href="#3">外链</a></li><li><a href="#4">引入图片</a></li><li><a href="#5">引用</a></li><li><a href="#6">缩进</a></li><li><a href="#7">斜体</a></li><li><a href="#8">加粗</a></li><li><a href="#9">分割线</a></li><li><a href="#10">待办</a></li><li><a href="#11目录锚点">目录锚点</a></li><li><a href="#12引入单句代码">引入单句代码</a><br><h4 id="1">1、标题</h4><br>井号#后面空一格<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p></p><h4 id="2">2、引入代码</h4><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h4 id="3">3、外链</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">参考链接</span>](<span class="link">https://caychance.github.io/</span>)</span><br></pre></td></tr></table></figure><p></p><p><a href="https://caychance.github.io/" target="_blank" rel="noopener">参考链接</a></p><p></p><h4 id="4">4、引入图片</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwly1fxq7h427d7j30780c7t9o.jpg)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxq7h427d7j30780c7t9o.jpg" alt></p><p></p><h4 id="5">5、引用</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;一段引用的话</span><br><span class="line">换行了</span><br></pre></td></tr></table></figure><p></p><blockquote><p>一段引用的话<br>换行了</p></blockquote><p></p><h4 id="6">6、缩进</h4><br>三种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不带缩进的一行</span><br><span class="line">&amp;nbsp;不断行的空白格或&amp;#160;</span><br><span class="line">&amp;ensp;半方大的空白或&amp;#8194;</span><br><span class="line">&amp;emsp;全方大的空白或&amp;#8195;</span><br></pre></td></tr></table></figure><p></p><p>不带缩进的一行<br>&nbsp;不断行的空白格或&#160;<br>&ensp;半方大的空白或&#8194;<br>&emsp;全方大的空白或&#8195;</p><p></p><h4 id="7">7、斜体</h4><br>两种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_这是斜体_</span></span><br><span class="line"><span class="emphasis">*这是斜体*</span></span><br></pre></td></tr></table></figure><p></p><p><em>这是斜体</em><br><em>这是斜体</em></p><p></p><h4 id="8">8、加粗</h4><br>两种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">__这是斜体__</span></span><br><span class="line"><span class="strong">**这是斜体**</span></span><br></pre></td></tr></table></figure><p></p><p><strong>这是斜体</strong><br><strong>这是斜体</strong></p><p></p><h4 id="9">9、分割线</h4><br>分割线只能标题下使用<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">##### 华丽的分割线</span></span><br><span class="line">---</span><br><span class="line">华丽的分割线</span><br></pre></td></tr></table></figure><p></p><h5 id="华丽的分割线"><a href="#华丽的分割线" class="headerlink" title="华丽的分割线"></a>华丽的分割线</h5><hr><p>华丽的分割线</p><p></p><h4 id="10">10、待办</h4><br>[ ] 前后都要有空格<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[ ] 不勾选</span><br><span class="line"><span class="bullet">- </span>[x] 勾选</span><br></pre></td></tr></table></figure><p></p><ul><li style="list-style: none"><input type="checkbox"> 不勾选</li><li style="list-style: none"><input type="checkbox" checked> 勾选</li></ul><h4 id="11目录锚点"><a href="#11目录锚点" class="headerlink" title="11目录锚点"></a>11目录锚点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>[<span class="string">中国</span>](<span class="link">#中国</span>)</span><br><span class="line">  * [<span class="string">北京</span>](<span class="link">#北京</span>)</span><br><span class="line">  * [<span class="string">陕西</span>](<span class="link">#陕西</span>)</span><br><span class="line"><span class="code">    * [西安](#西安_1)</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">美国</span>](<span class="link">#美国</span>)</span><br><span class="line">  * [<span class="string">纽约</span>](<span class="link">#纽约</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">俄罗斯</span>](<span class="link">#俄罗斯</span>)</span><br><span class="line">  * [<span class="string">莫斯科</span>](<span class="link">#莫斯科</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">希腊</span>](<span class="link">#希腊</span>)</span><br><span class="line">  * [<span class="string">有些尴尬</span>](<span class="link">#有些尴尬</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="#中国">中国</a><ul><li><a href="#北京">北京</a></li><li><a href="#陕西">陕西</a><ul><li><a href="#西安_1">西安</a></li></ul></li></ul></li><li><a href="#美国">美国</a><ul><li><a href="#纽约">纽约</a></li></ul></li><li><a href="#俄罗斯">俄罗斯</a><ul><li><a href="#莫斯科">莫斯科</a></li></ul></li><li><a href="#希腊">希腊</a><ul><li><a href="#有些尴尬">有些尴尬</a></li></ul></li></ul><p></p><h4 id="西安_1">西安</h4><br>方法一：以标题西安为例。标题加一个id等于目录上西安的锚点西安_1。这种方式锚点中可以有特殊字符。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">id</span>=<span class="string">西安_1</span>&gt;</span></span>西安<span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p></p><h4 id="纽约"><a href="#纽约" class="headerlink" title="纽约"></a>纽约</h4><p>方法二：以纽约为例。markdown的标题会自动加上锚点。例如下面的锚点自动就是纽约。不过这种方式设置的锚点中不能设置特殊字符。打开开发者模式查看一下元素就明白了。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 纽约</span></span><br></pre></td></tr></table></figure></p><h4 id="12引入单句代码"><a href="#12引入单句代码" class="headerlink" title="12引入单句代码"></a>12引入单句代码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="code">`hexo server`</span>启动服务，使用<span class="code">`hexo g`</span>和<span class="code">`hexo d`</span>发布</span><br></pre></td></tr></table></figure><p>使用<code>hexo server</code>启动服务，使用<code>hexo g</code>和<code>hexo d</code>发布</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;markdown常用语法&quot;&gt;&lt;a href=&quot;#markdown常用语法&quot; class=&quot;headerlink&quot; title=&quot;markdown常用语法&quot;&gt;&lt;/a&gt;markdown常用语法&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; cl
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>github没有记录你的contributions?</title>
    <link href="http://yoursite.com/2018/12/04/github%E6%B2%A1%E6%9C%89%E8%AE%B0%E5%BD%95%E4%BD%A0%E7%9A%84contributions/"/>
    <id>http://yoursite.com/2018/12/04/github没有记录你的contributions/</id>
    <published>2018-12-04T10:51:31.000Z</published>
    <updated>2018-12-05T08:20:27.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="github是怎么计算contributions的呢？"><a href="#github是怎么计算contributions的呢？" class="headerlink" title="github是怎么计算contributions的呢？"></a>github是怎么计算contributions的呢？</h2><hr><blockquote><h4 id="贡献的计算"><a href="#贡献的计算" class="headerlink" title="贡献的计算"></a>贡献的计算</h4><h5 id="Issues-and-pull请求"><a href="#Issues-and-pull请求" class="headerlink" title="Issues and pull请求"></a>Issues and pull请求</h5><p>   如果issues和pull请求是在独立库中打开而不是分叉（fork），它们将显示在您的贡献图上。</p><h5 id="Commits"><a href="#Commits" class="headerlink" title="Commits"></a>Commits</h5><p>   如果commits符合以下所有的条件，那么会在您的贡献图上有所显示。<br>   1.用于提交的电子邮件地址与您的GitHub帐户相关联。<br>   2.在独立的库中进行提交的，而不是分支（fork）。<br>   3.提交内容如下：<br>   &emsp;在库的默认分支。（通常是master分支）。<br>   &emsp;在gh-pages分支中（对于具有Project Pages站点的库）。</p></blockquote><p><a href="https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;github是怎么计算contributions的呢？&quot;&gt;&lt;a href=&quot;#github是怎么计算contributions的呢？&quot; class=&quot;headerlink&quot; title=&quot;github是怎么计算contributions的呢？&quot;&gt;&lt;/a&gt;githu
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
</feed>
