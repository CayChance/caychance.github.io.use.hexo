<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chance的个人学习笔记</title>
  
  <subtitle>Chance`blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-06T11:31:22.774Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker学习笔记</title>
    <link href="http://yoursite.com/2019/03/07/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/07/docker学习笔记/</id>
    <published>2019-03-06T19:26:50.000Z</published>
    <updated>2019-03-06T11:31:22.774Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h4><h4 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h4><h4 id="docker如何使用"><a href="#docker如何使用" class="headerlink" title="docker如何使用"></a>docker如何使用</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h4 id=&quot;docker是什么&quot;&gt;&lt;a href=&quot;#docker是什么&quot; class=&quot;headerlink&quot; title=&quot;docker是什么&quot;&gt;&lt;/a&gt;docker是什么&lt;/h4&gt;&lt;h4 id=&quot;为什么要用docker&quot;&gt;&lt;a href=&quot;#为什么要用dock
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://yoursite.com/2019/02/27/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/02/27/原型与原型链/</id>
    <published>2019-02-26T17:10:20.000Z</published>
    <updated>2019-02-27T08:23:07.209Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每个函数都有一个特殊的属性叫作原型（<code>prototype</code>）<br>每个实例对象（<code>object</code>）都有一个私有属性（称之为<code>__proto__</code>）指向它的原型对象（<code>prototype</code>）<br>该原型对象也有一个自己的原型对象(<code>__proto__</code>) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p><p>构造函数，原型和实例三者之间的关系</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0jzrv2ditj30zk0puq4y.jpg" style="    width: 400px;    height: 300px;"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Father();</span><br><span class="line">Father.prototype === f.__proto__ <span class="comment">//true</span></span><br><span class="line">f.constructor === Father <span class="comment">//true</span></span><br><span class="line">Father.prototype.constructor === Father <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0l17qcp6vj30zk0pugn7.jpg" style="    height: 500px;"></p><p>1、原型链的最顶端是<code>null</code><br>2、所有的原型的<code>_proto_</code>都是Object的原型<br>3、所有的构造函数的<code>_proto_</code>都是Function的原型<br>4、Function的<code>_proto_</code>和<code>prototype</code>都是Function的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ <span class="comment">//null 1</span></span><br><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__ <span class="comment">//true 4</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Father.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true 3</span></span><br><span class="line">Father.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true 2</span></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true 3</span></span><br><span class="line"><span class="built_in">String</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true 2</span></span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>理解，每个函数（构造函数，或者普通函数）都有一个属性叫做原型（prototype）,</p><p>最后贴一张更全的图</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0l0c6dx6cj30u011c7ci.jpg" style="    height: 600px;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h3&gt;&lt;p&gt;每个函数都有一个特殊的属性叫作原型（&lt;code&gt;prototype&lt;/code&gt;）&lt;br&gt;每个实例对象（&lt;code&gt;object&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基础入门</title>
    <link href="http://yoursite.com/2019/02/01/MongoDB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/02/01/MongoDB基础入门/</id>
    <published>2019-02-01T10:23:29.000Z</published>
    <updated>2019-02-14T06:17:49.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB基础入门（基础篇）"><a href="#MongoDB基础入门（基础篇）" class="headerlink" title="MongoDB基础入门（基础篇）"></a>MongoDB基础入门（基础篇）</h2><p>最新心血来潮，准备在网上学习一下Vue+Node+MongoDB。之前接触过MySQL，但是MongoDB跟MySQL还是有区别的。话不多说：</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>一个mongodb中可以建立多个数据库。</p><p>每个数据库里面有多个表（也叫做集合）。</p><p>表里面存储的数据格式就是一个json，这也是区别于SQL的地方。</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>这一步就省略了，自己Google去吧。我在mac下用的homebrew</p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>在命令行中输入mongo就会连接到数据库</p><h4 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h4><p><code>show dbs</code>           查看所有数据库<br><code>use DATABASE_NAME</code>  创建数据库或者切换到该数据库<br><code>db.dropDatabase()</code>  删除数据库</p><h4 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h4><p><code>show tables</code>                           查看已有表<br><code>show collections</code>                      查看已有集合<br><code>db.createCollection(name, options)</code>    创建集合<br><code>db.COLLECTION_NAME.drop()</code>             删除集合</p><p><strong>PS：show tables 和 show collections 的区别，网上还么有搜到，但是实际操作了一下，发现两者是一样的。</strong></p><p>直接在COLLECTION_NAME集合中插入数据的时候，会自动创建COLLECTION_NAME集合<br><code>db.COLLECTION_NAME.insert({&quot;name&quot; : &quot;Chance&quot;})</code></p><p><strong>情况1：如果没有新建一个数据库的话，会默认在test数据库中新建一个COLLECTION_NAME集合（表）</strong><br><strong>情况2：在该命令之前新建了一个数据库的话，会在该数据库下新建一个COLLECTION_NAME集合（表）</strong></p><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>增删改查的操作是基于集合来的，所有统一的格式都是db.COLLECTION_NAME.***</p><p>增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(document)</span><br></pre></td></tr></table></figure><p>删<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(query, projection)</span><br></pre></td></tr></table></figure></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>解释/说明</th></tr></thead><tbody><tr><td>show dbs</td><td>查看所有数据库</td></tr><tr><td>db</td><td>显示当前数据库对象或集合</td></tr><tr><td>use DATABASE_NAME</td><td>如果数据库不存在，则创建数据库，否则切换到指定数据库。</td></tr><tr><td>show tables</td><td>查看该数据库下的所有表</td></tr><tr><td>show collections</td><td>查看该数据库下的所有集合</td></tr><tr><td>db.dropDatabase()</td><td>删除数据库</td></tr><tr><td>db.COLLECTION_NAME.insert({“name”:”Chance”})</td><td>创建集合并向其中插入一些数据</td></tr><tr><td>db.createCollection(name, options)</td><td>创建集合</td></tr><tr><td>db.COLLECTION_NAME.drop()</td><td>删除当前集合</td></tr><tr><td>db.COLLECTION_NAME.insert(document)</td><td>增</td></tr><tr><td>db.COLLECTION_NAME.remove()</td><td>删</td></tr><tr><td>db.COLLECTION_NAME.update()</td><td>改</td></tr><tr><td>db.COLLECTION_NAME.insert(document)</td><td>查</td></tr></tbody></table><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>正常情况下，node中不会直接使用mongo的语法，会使用mongoose<br><a href="https://mongoosejs.com/" target="_blank" rel="noopener">mongoose官网</a><br><a href="https://www.bilibili.com/video/av41033371" target="_blank" rel="noopener">mongoose教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MongoDB基础入门（基础篇）&quot;&gt;&lt;a href=&quot;#MongoDB基础入门（基础篇）&quot; class=&quot;headerlink&quot; title=&quot;MongoDB基础入门（基础篇）&quot;&gt;&lt;/a&gt;MongoDB基础入门（基础篇）&lt;/h2&gt;&lt;p&gt;最新心血来潮，准备在网上学习
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目的整体认识</title>
    <link href="http://yoursite.com/2019/01/26/Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2019/01/26/Vue项目的整体认识/</id>
    <published>2019-01-25T21:08:20.000Z</published>
    <updated>2019-02-16T15:55:27.103Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Vue项目的一些整体认识"><a href="#Vue项目的一些整体认识" class="headerlink" title="Vue项目的一些整体认识"></a>Vue项目的一些整体认识</h4><hr><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>其实从16年11月28日进公司实习至今，已经两年多了。刚去公司的时候，我们当时前端就3个人，那会也是第一次接触Vue的。刚接触的感觉，就是，这玩意，这么神奇。然后平时做需求也是，能把需求做了就行。至今还记得第一次前后端联调，第一次项目上线。</p><p>虽然很早就接触了，但是我们项目的很多东西，我都没有认真的静下来去看。导致很多东西都是一知半解的。直到自己有一天幡然醒悟。</p><p>我们的项目是我们前端小组长搭建的一个脚手架,包括vue cli+webpack配置+node(express)。使用 node 代替 NGINX 提供请求代理、WebViewJavaScriptbridge 与客户端交互、Vue 全家桶作为开发框架，并且用 express 搭建了 mock 框架。</p><h4 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h4><p>首先，Vue没有什么神奇的，最后上线的东西就是一个dist文件，里面一个入口文件index.html+一个static文件，static文件里面是打包后的图片，css和js。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzj6d8fhqvj30hk0k40ue.jpg" alt=""></p><p>以本地开发为例，<code>npm run dev</code> 以后，正常情况下会启动一个本地服务，然后当用户访问<code>localhost:8080/login</code>，本地服务器会返回打包后的<code>index.html</code>文件，index文件里面引入了main.js即js代码的主入口文件。</p><p>这部分是Vue项目中的node服务器处理的，这也是node服务器的第一个作用，方便本地调试。服务器会把收到的请求转到index.html。具体可参考作用1。</p><p>main.js文件里面其实会实例化一个Vue对象，并挂载在某个dom元素下。实例化的Vue对象里面有Vue Router和Vuex。Vuex按需要来决定要不要引用。Vue Router会在你访问某个路径的时候，比对当前的location.pathname和Vue Router中的某一个path是否可以匹配上，能够匹配上的话，会渲染对应的组件页面。</p><p>以上就是对Vue整个项目的一个认识。Vue项目中用到了node，说一下node的作用吧。</p><h5 id="作用1"><a href="#作用1" class="headerlink" title="作用1"></a>作用1</h5><p>服务器会把收到的请求转到index.html。（PS：test环境和production环境是这样处理的。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendFile(webpackConfig.output.path + <span class="string">'/index.html'</span>, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/html; charset=UTF-8'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中，dev环境下使用webpack-dev-middleware中间件来做。这么做的其中一个好处是，不在磁盘中存储文件，而是直接生成在内存中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> devMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)(compiler, &#123;</span><br><span class="line">  publicPath: webpackConfig.output.publicPath,</span><br><span class="line">  stats: &#123;</span><br><span class="line">    colors: <span class="literal">true</span>,</span><br><span class="line">    chunks: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve webpack bundle output</span></span><br><span class="line">app.use(devMiddleware)</span><br></pre></td></tr></table></figure></p><h5 id="作用2"><a href="#作用2" class="headerlink" title="作用2"></a>作用2</h5><p>使用中间件代理解决跨域问题，我们用了一个proxy-middleware的中间件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy api requests</span></span><br><span class="line"><span class="built_in">Object</span>.keys(apiMap).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> api = apiMap[key];</span><br><span class="line">  app.use(api.path, proxy(api.proxy));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="作用3"><a href="#作用3" class="headerlink" title="作用3"></a>作用3</h5><p>请求一些静态资源，或者本地不经过webpack编译的图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serve pure static assets</span></span><br><span class="line"><span class="keyword">var</span> staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory);</span><br><span class="line">app.use(staticPath, express.static(path.resolve(__dirname, <span class="string">'../static'</span>)))</span><br></pre></td></tr></table></figure><h5 id="作用4"><a href="#作用4" class="headerlink" title="作用4"></a>作用4</h5><p>本地调试的时候mock数据 else部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv.proxy) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(apiMap).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> api = apiMap[key];</span><br><span class="line">    app.use(api.path, proxy(api.proxy));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mock api requests</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mockDir = path.resolve(__dirname, <span class="string">'../mock'</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">setMock</span>(<span class="params">mockDir</span>) </span>&#123;</span><br><span class="line">    fs.readdirSync(mockDir).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> filePath = path.resolve(mockDir, file);</span><br><span class="line">      <span class="keyword">var</span> mock;</span><br><span class="line">      <span class="keyword">if</span> (fs.statSync(filePath).isDirectory()) &#123;</span><br><span class="line">        setMock(filePath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(file)) &#123;</span><br><span class="line">          mock = <span class="built_in">require</span>(filePath);</span><br><span class="line">          app.use(mock.api, mock.response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(mockDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>这些话是说给自己的。</p><p>首先鼓励的话，从最开始看到项目那一堆代码时的一脸懵逼，到现在基本都明白了。（不说全部都明白了，但是就算有不知道的，也知道去搜索然后了解对应的部分是做什么的）。当然，这个经历的时间有些长，包括自己学习node，koa+express。这个过程也是很美好的，收获也不少。</p><p>然后警钟的话，</p><p><strong>爱一行，干一行；干一行，爱一行。</strong>最开始虽然说是为了互联网行业的高薪来的，但是起码当时选的是你感兴趣的前端，（PS：这话说得可能就不对，因为真正的程序员眼里是不分前后端的），所以，爱一行，干一行。</p><p><strong>时刻保持着对知识的好奇以及极强的求知欲。</strong> 这句话，自己好好反思。</p><p>最后，没有最后。加油！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Vue项目的一些整体认识&quot;&gt;&lt;a href=&quot;#Vue项目的一些整体认识&quot; class=&quot;headerlink&quot; title=&quot;Vue项目的一些整体认识&quot;&gt;&lt;/a&gt;Vue项目的一些整体认识&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; cl
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vuex存储的时候遇到的问题及解决方案</title>
    <link href="http://yoursite.com/2019/01/23/Vuex%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/01/23/Vuex存储的时候遇到的问题及解决方案/</id>
    <published>2019-01-22T19:40:06.000Z</published>
    <updated>2019-01-22T12:19:06.464Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex使用心得</p><hr><h5 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h5><p>使用Vuex遇到过两个问题。<br>1.页面刷新或者跳转到第三方再回来，数据是会丢掉的。即Vuex持久化存储问题。<br>2.在Vuex中存储一个Falsey值（PS：false,’’,null,undefined,NaN）的时候，Vuex中存储不了。</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>第一个问题，网上有很多解决方案。使用<a href="https://github.com/robinvdvleuten/vuex-persistedstate" target="_blank" rel="noopener">vuex-persistedstate</a>。具体看文档，我就不细说了，可以使用localStorage,也可以使用cookie。</p><p>第二个问题，其实并不是Vuex本身的问题，而是因为我们项目中统一为每一个state字段生成了mutations方法。</p><p>generate方法中的语句<code>state[name] = value || state[name];</code>判断，value为false的时候，确实存不进来。</p><p>然后自己重新写了一个<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateToken(state,newToken)&#123;</span><br><span class="line">  state.token = newToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多页面共享数据</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    aaa: <span class="string">''</span>,</span><br><span class="line">    bbb:<span class="string">''</span>,</span><br><span class="line">    ccc: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据变更</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    updateToken(state,newToken)&#123;</span><br><span class="line">      state.token = newToken;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 mutations 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, value</span>) </span>&#123;</span><br><span class="line">    state[name] = value || state[name];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个 state 字段生成对应的 mutations 方法</span></span><br><span class="line"><span class="built_in">Object</span>.keys(options.state).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  options.mutations[key] = generate(key);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vuex使用心得&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h5&gt;&lt;p&gt;使用Vuex遇到过两个问题。&lt;br&gt;1.页面刷新或者跳转到第三方再回来，数据是会丢掉的。即Vuex
      
    
    </summary>
    
    
      <category term="Vuex" scheme="http://yoursite.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>find-记一次生产的bug排查</title>
    <link href="http://yoursite.com/2019/01/19/find-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E7%9A%84bug%E6%8E%92%E6%9F%A5/"/>
    <id>http://yoursite.com/2019/01/19/find-记一次生产的bug排查/</id>
    <published>2019-01-18T21:14:12.000Z</published>
    <updated>2019-01-18T13:54:29.023Z</updated>
    
    <content type="html"><![CDATA[<h4 id="记一次生产的bug排查"><a href="#记一次生产的bug排查" class="headerlink" title="记一次生产的bug排查"></a>记一次生产的bug排查</h4><hr><h5 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h5><p>上线一周，最近的用户量增加了一些，今天下午的时候，群里一直被@，有一部分用户打开产品流程首页的时候白屏。</p><h5 id="bug复现"><a href="#bug复现" class="headerlink" title="bug复现"></a>bug复现</h5><p>借了用户的账号密码登录以后发现，我手机上是可以打开的。然后看了用户的手机系统是安卓5.0，不是很高的系统。然后找了一个测试的5.0的手机试了一下，还是可以打开的。反映出问题的用户中，vivo的机型比较多。然鹅，我们这边vivo的测试机没有5.0以下版本的。后来接到了一个魅族和小米的手机，分别是5.0和4.4的系统。登录账号，发现bug复现了。</p><h5 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h5><p>1.装了生产的包，打开chrome的调试功能(chrome://inspect/#devices);发现webpack打包以后的main文件里面的1行3000多列出现的报错。去代码中定位了一下，发现了这段代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stepObj = allStep.find(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.routeName === currentName;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2.chrome模拟打开页面的时候，在控制台输入<code>navigator.userAgent</code>，发现这个浏览器的是chrome 43。chrome43支持find语法吗？</p><p>3.去<a href="https://caniuse.com/#search=find" target="_blank" rel="noopener">caniuse</a>中搜索find的兼容性，发现chrome44以后的版本才支持find语法。</p><p>至此，问题已经定位到了。我们使用了find语法，但是用户的浏览器版本太低不支持。但是我们项目中使用了babel了呀?</p><h5 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h5><p>但是我们项目中使用了babel了呀?</p><p>虽然使用了babel，但是没有配置转换find语法。</p><p>google搜索babel find然后找到一条Stack Overflow的<a href="https://stackoverflow.com/questions/32401513/array-find-doesnt-work-with-babel" target="_blank" rel="noopener">帖子</a>。解决方法也列出来了。</p><p>至此，结束。</p><h5 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h5><p>当然了，还没有结束呢。</p><p>页面可以打开了，但是又出现另一个问题了。等着下周客户端一起检查一下。</p><h5 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h5><p>1.遇到bug心态一定要保持好，用我同事的话，你不觉得这样子一步步的去定位bug，跟侦探破案一样刺激吗？（PS：感谢他，以上有很多都是他发现的，受益匪浅）。</p><p>2.用好google搜索，Stack Overflow,github等这些国外技术社区，真的会收益良多。（PS：百度是真的垃圾，此处略去一万字）</p><p>3.英语好真的很重要啊。那天看了一篇文章，英语对一个程序员来说重要吗？回答是，如果英语不好不影响你做一个程序员；但是你想学好一门编程语言，那英语实在是太重要了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;记一次生产的bug排查&quot;&gt;&lt;a href=&quot;#记一次生产的bug排查&quot; class=&quot;headerlink&quot; title=&quot;记一次生产的bug排查&quot;&gt;&lt;/a&gt;记一次生产的bug排查&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;前提概要&quot;&gt;&lt;a href=&quot;#前提概要&quot; cl
      
    
    </summary>
    
      <category term="bug排查" scheme="http://yoursite.com/categories/bug%E6%8E%92%E6%9F%A5/"/>
    
    
      <category term="find bug" scheme="http://yoursite.com/tags/find-bug/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://yoursite.com/2019/01/16/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/16/git学习笔记/</id>
    <published>2019-01-16T13:52:57.000Z</published>
    <updated>2019-01-18T13:02:15.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>git是14年才接触的，然后也没有系统的学习过。都是平时遇到一点问题，去搜一搜。</p><p>安装部分就不说了。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz9dildkoxj30cq06iaa8.jpg" alt=""><br>1.工作区<br>就是电脑上写代码部分<br>2.版本库<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><blockquote><p>mkdir learngit            新建一个文件夹<br>  cd learngit               并进入该文件夹<br>  git init                  初始化，把该文件夹变成git可以管理的仓库（会产生一个.git文件）<br>  git add <file>            把文件修改添加到暂存区（Stage）<br>  git commit -m <message>   把暂存区的所有内容提交到当前分支</message></file></p></blockquote><h5 id="查看状态及回退"><a href="#查看状态及回退" class="headerlink" title="查看状态及回退"></a>查看状态及回退</h5><blockquote><p>git status                  查看当前仓库状态<br>  git diff                    查看详细的修改内容<br>  git diff HEAD – readme.txt 查看工作区和版本库里面最新版本的区别<br>  git log                     查看从最近到最远的提交日志<br>  git log –pretty=oneline    查看从最近到最远的简洁版提交日志<br>  git log –graph             查看分支合并图<br>  git reflog                  查看历史命令<br>  git reset –hard HEAD^      回退到上一个版本<br>  git reset –hard HEAD^^     回退到上上一个版本<br>  git reset –hard HEAD~10    回退到往上10个版本<br>  git reset –hard commit_id  回退到固定某个版本</p></blockquote><h5 id="放弃修改"><a href="#放弃修改" class="headerlink" title="放弃修改"></a>放弃修改</h5><blockquote><p>git checkout – <file>      丢弃工作区的修改<br>  git reset HEAD <file>       丢弃暂存区的修改，回到工作区<br>  git rm <file>               从版本库中删除掉某文件</file></file></file></p></blockquote><h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><blockquote><p>git remote add origin git@server-name:path/repo-name.git  关联一个远程仓库<br>  git push -u origin <name>   关联后，第一次推送master分支的所有内容<br>  git push origin <name>      以后的正常提交<br>  git checkout -b <name>      新建dev分支并切换到dev分支<br>  相当于<br>  git branch <name>           新建dev分支<br>  git checkout <name>         切换到dev分支</name></name></name></name></name></p></blockquote><h5 id="合并删除分支"><a href="#合并删除分支" class="headerlink" title="合并删除分支"></a>合并删除分支</h5><blockquote><p>git branch                  查看当前分支<br>  git merge <name>            合并某个分支到当前分支<br>  git branch -d <name>        删除分支<br>  git branch -D <name>        强制删除分支</name></name></name></p></blockquote><h5 id="临时存储"><a href="#临时存储" class="headerlink" title="临时存储"></a>临时存储</h5><blockquote><p>git stash                   把当前工作现场存储起来<br>  git stash list              查看已存储<br>  git stash apply             把已存储的内容恢复，内容不删除<br>  git stash drop              删除已存储的内容<br>  git stash pop               恢复内容以后同时删除内容</p></blockquote><h5 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h5><blockquote><p>git remote                  查看远程库信息<br>  git remote -v               查看远程库详细信息<br>  git push origin <name>      把该分支上的所有本地提交推送到远程库<br>  git checkout -b <name> origin/<name>  在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致<br>  git branch –set-upstream <name> origin/<name>  建立本地分支和远程分支的关联<br>  git pull                    从远程合并<br>  如果提示no tracking information<br>  则说明本地分支和远程分支的链接关系没有创建，可以使用<br>  git branch –set-upstream-to <name> origin/<name></name></name></name></name></name></name></name></p></blockquote><h5 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h5><blockquote><p>标签总是和某个commit挂钩。<br>  git tag <tagname>           用于新建一个标签，默认为HEAD，也可以指定一个commit id<br>  git tag <tagname> commit_id 给指定一个commit_id新建一个标签<br>  git tag                     查看所有标签<br>  git show <tagname>          查看标签信息<br>  git tag -d <tagname>        删除一个本地标签<br>  git push origin <tagname>   推送某个标签到远程（PS：创建的标签都只存储在本地）<br>  git push origin –tags      一次性推送全部尚未推送到远程的本地标签<br>  如果标签已经推送到远程，要删除远程标签就麻烦一点<br>  git tag -d <tagname>                   删除一个本地标签<br>  git push origin :refs/tags/<tagname>   删除一个远程标签</tagname></tagname></tagname></tagname></tagname></tagname></tagname></p></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>git是Linux之父linus创造的，属于一种分布式版本控制系统。（PS：区别于集中式的版本控制系统）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;p&gt;git是14年才接触的，然后也没有系统的学习过。都是平时遇到一点问题，去搜一搜。&lt;/p&gt;
&lt;p&gt;安装部分就不说了。&lt;/p&gt;
&lt;h4 id=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="http://yoursite.com/2019/01/12/BFC/"/>
    <id>http://yoursite.com/2019/01/12/BFC/</id>
    <published>2019-01-11T20:31:59.000Z</published>
    <updated>2019-01-18T13:03:31.352Z</updated>
    
    <content type="html"><![CDATA[<h4 id="BFC是什么"><a href="#BFC是什么" class="headerlink" title="BFC是什么"></a>BFC是什么</h4><p>前几天被人问到了BFC，一脸懵逼。赶紧看看，简单总结一下。</p><ul><li><a href="#概念">概念</a></li><li><a href="#BFC的特性">BFC的特性</a></li><li><a href="#如何触发BFC">如何触发BFC</a></li></ul><p>简单总结一下：</p><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><blockquote><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流。</p></blockquote><p>PS:区别于普通流，常见的还有浮动（float），绝对定位（absolute）</p><p><strong>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</strong></p><h5 id="BFC的特性："><a href="#BFC的特性：" class="headerlink" title="BFC的特性："></a>BFC的特性：</h5><p>1.同一个BFC中的margin会重叠<br>2.浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。<br>3.BFC可以阻止元素被浮动元素覆盖。</p><h5 id="如何触发BFC：-PS：满足一下任一条件即可触发"><a href="#如何触发BFC：-PS：满足一下任一条件即可触发" class="headerlink" title="如何触发BFC：(PS：满足一下任一条件即可触发)"></a>如何触发BFC：(PS：满足一下任一条件即可触发)</h5><p>1.body根元素<br>2.浮动元素：float除none以外的值<br>3.绝对定位元素：position 等于absolute或者fixed<br>4.display等于 inline-block、table-cells、flex<br>5.overflow等于除了 visible 以外的值 (hidden、auto、scroll)<br>类似函数作用域。</p><p><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;BFC是什么&quot;&gt;&lt;a href=&quot;#BFC是什么&quot; class=&quot;headerlink&quot; title=&quot;BFC是什么&quot;&gt;&lt;/a&gt;BFC是什么&lt;/h4&gt;&lt;p&gt;前几天被人问到了BFC，一脸懵逼。赶紧看看，简单总结一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>如何使用七牛云</title>
    <link href="http://yoursite.com/2019/01/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    <id>http://yoursite.com/2019/01/06/如何使用七牛云/</id>
    <published>2019-01-05T23:59:38.000Z</published>
    <updated>2019-01-13T10:45:17.217Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一个需求，使用七牛云的sdk来上传图片。  七牛云的文档写的可以更好一点。</p><p>html部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">'imageUrl'</span> <span class="attr">type</span>=<span class="string">"file"</span> @<span class="attr">click</span>=<span class="string">"uploadImage('imageUrl')"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个用的是vue做的，所以会有一个ref标签，直接用原生html写的可以忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上传图片</span></span><br><span class="line">uploadImage(ref) &#123;</span><br><span class="line">  <span class="comment">//选中input元素</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span>(ref === <span class="string">'imageUrl'</span>)&#123;</span><br><span class="line">    input = <span class="keyword">this</span>.$refs[ref];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    input = <span class="keyword">this</span>.$refs[ref][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//input在onchange的时候触发</span></span><br><span class="line">  input.onchange = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//localFileName 文件的本地名，一般是一个绝对地址的路径</span></span><br><span class="line">    <span class="keyword">let</span> localFileName = input.value;</span><br><span class="line">    <span class="comment">//文件名</span></span><br><span class="line">    <span class="keyword">let</span> suffix = localFileName.substring(localFileName.lastIndexOf(<span class="string">"."</span>),localFileName.length);<span class="comment">//后缀名</span></span><br><span class="line">    <span class="keyword">let</span> fileName = localFileName.substring(localFileName.lastIndexOf(<span class="string">"\\"</span>)+<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> file = input.files[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要先获取上传七牛云的token</span></span><br><span class="line">    axios.get(<span class="string">`<span class="subst">$&#123;GET_UPLOAD_TOKEN&#125;</span>?fileName=<span class="subst">$&#123;fileName&#125;</span>`</span>).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(response.code === <span class="number">2000</span>)&#123;</span><br><span class="line">        <span class="comment">//七牛云token</span></span><br><span class="line">        <span class="keyword">const</span> token = response.data;</span><br><span class="line">        <span class="keyword">const</span> observer = &#123;</span><br><span class="line">          next(response)&#123;</span><br><span class="line">            <span class="keyword">let</span> process = <span class="built_in">Math</span>.floor(response.total.percent)+<span class="string">'%'</span>;</span><br><span class="line">            <span class="keyword">if</span>(process === <span class="string">'100%'</span>)&#123;</span><br><span class="line">              <span class="comment">//这里可以写上传成功的处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          error(err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">          &#125;,</span><br><span class="line">          complete(res1)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res1);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> key = fileName;<span class="comment">//上传文件名</span></span><br><span class="line">        <span class="keyword">const</span> putExtra = &#123;</span><br><span class="line">            fname: fileName,</span><br><span class="line">            params: &#123;&#125;,</span><br><span class="line">            mimeType:[<span class="string">"image/png"</span>, <span class="string">"image/jpeg"</span>, <span class="string">"image/gif"</span>]</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> config = &#123;</span><br><span class="line">          useCdnDomain: <span class="literal">true</span>,</span><br><span class="line">          region: qiniu.region.z0</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> observable = qiniu.upload(file, key, token, putExtra, config);</span><br><span class="line">        observable.subscribe(observer) <span class="comment">// 上传开始</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>以上结束。当然了，七牛云的存储那边也需要设置一下。具体查看文档就好了。其实js部分就是七牛云提供的，html部分，我刚开始很纠结，不知道能不能用form表单的action来操作。</p><p><a href="https://developer.qiniu.com/kodo/sdk/1283/javascript" target="_blank" rel="noopener">七牛云的文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做了一个需求，使用七牛云的sdk来上传图片。  七牛云的文档写的可以更好一点。&lt;/p&gt;
&lt;p&gt;html部分&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="七牛云" scheme="http://yoursite.com/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>js继承方法总结</title>
    <link href="http://yoursite.com/2018/12/14/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/14/js继承方法总结/</id>
    <published>2018-12-13T20:31:20.000Z</published>
    <updated>2019-01-04T14:46:50.610Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="js继承方法"><a href="#js继承方法" class="headerlink" title="js继承方法"></a>js继承方法</h3><ul><li><a href="#1原型链继承">原型链继承</a></li><li><a href="#2借用构造函数继承">借用构造函数继承</a></li><li><a href="#3组合继承">组合继承</a></li><li><a href="#4原型式继承">原型式继承</a></li><li><a href="#5寄生式继承">寄生式继承</a></li><li><a href="#6寄生组合式继承">寄生组合式继承</a></li><li><a href="#7混入方式继承多个对象">混入方式继承多个对象</a></li><li><a href="#8ES6类继承extends">ES6类继承extends</a></li><li><a href="#总结">总结</a><h4 id="1原型链继承"><a href="#1原型链继承" class="headerlink" title="1原型链继承"></a>1原型链继承</h4>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。<blockquote><p>继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里是关键，创建Father的实例，并将该实例赋值给Son.prototype</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy5eirt2pxj30m80bldjb.jpg" alt=""><br>原型链方案存在的缺点：</p><ul><li><strong>多个实例对引用类型的操作会被篡改。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure><h4 id="2借用构造函数继承"><a href="#2借用构造函数继承" class="headerlink" title="2借用构造函数继承"></a>2借用构造函数继承</h4><blockquote><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自Father</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.color.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//"red,green,blue,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance2.color);<span class="comment">//"red,green,blue"</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>Father.call(this)</code>，创建子类实例时调用<code>Father</code>构造函数，于是<code>Son</code>的每个实例都会将<code>Father</code>中的属性复制一份。</p><p>借用构造函数继承的缺点：</p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h4 id="3组合继承"><a href="#3组合继承" class="headerlink" title="3组合继承"></a>3组合继承</h4><blockquote><p>组合上述两种方法就是组合继承。用<strong>原型链实现对原型属性和方法的继承</strong>，用<strong>借用构造函数技术来实现实例属性的继承</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用Father()</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用Father()</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 重写Son.prototype的constructor属性，指向自己的构造函数Son</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>组合继承的缺点：</p><ul><li>第一次调用Father()：给Son.prototype写入两个属性name，color。</li><li>第二次调用Father()：给instance1写入两个属性name，color。</li></ul><p>实例对象instance1上的两个属性就屏蔽了其原型对象Son.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p><h4 id="4原型式继承"><a href="#4原型式继承" class="headerlink" title="4原型式继承"></a>4原型式继承</h4><blockquote><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<strong>浅复制</strong>，将构造函数F的原型直接指向传入的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure><p>原型式继承缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数<br>另外，ES5中存在Object.create()的方法，能够代替上面的object方法。</li></ul><h4 id="5寄生式继承"><a href="#5寄生式继承" class="headerlink" title="5寄生式继承"></a>5寄生式继承</h4><blockquote><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">// 通过调用 object() 函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强对象</span></span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure><p>寄生式继承的缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h4 id="6寄生组合式继承"><a href="#6寄生组合式继承" class="headerlink" title="6寄生组合式继承"></a>6寄生组合式继承</h4><blockquote><p>结合借用构造函数(2)传递参数和寄生模式(5)实现继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">son, father</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(father.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = son;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  son.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类原型指向子类</span></span><br><span class="line">inheritPrototype(Son, Father);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"xyc"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son(<span class="string">"lxy"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">"2"</span>); <span class="comment">// ["red", "blue", "green", "2"]</span></span><br><span class="line">instance1.colors.push(<span class="string">"3"</span>); <span class="comment">// ["red", "blue", "green", "3"]</span></span><br></pre></td></tr></table></figure><ul><li>这个例子的高效率体现在它只调用了一次<code>Father</code>构造函数，并且因此避免了在<code>Son.prototype</code>上创建不必要的、多余的属性。<br>于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code>和<code>isPrototypeOf()</code></li><li>这是最成熟的方法，也是现在库实现的方法</li></ul><h4 id="7混入方式继承多个对象"><a href="#7混入方式继承多个对象" class="headerlink" title="7混入方式继承多个对象"></a>7混入方式继承多个对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p><h4 id="8ES6类继承extends"><a href="#8ES6类继承extends" class="headerlink" title="8ES6类继承extends"></a>8ES6类继承extends</h4><p>extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    get area() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    calcArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p>extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">son, father</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">    son.prototype = <span class="built_in">Object</span>.create(father &amp;&amp; father.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: son,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (father) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf</span><br><span class="line">            ? <span class="built_in">Object</span>.setPrototypeOf(son, father)</span><br><span class="line">            : son.__proto__ = father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、ES5继承和ES6继承的区别</p><ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li><li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;js继承方法&quot;&gt;&lt;a href=&quot;#js继承方法&quot; class=&quot;headerlink&quot; title=&quot;js继承方法&quot;&gt;&lt;/a&gt;js继承方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1原型链继承&quot;&gt;原型链继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="http://yoursite.com/2018/12/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/12/07/浏览器缓存机制/</id>
    <published>2018-12-06T16:43:58.000Z</published>
    <updated>2019-02-15T02:36:29.106Z</updated>
    
    <content type="html"><![CDATA[<hr><p>（PS:这篇文章，就是纯粹的纸上谈兵哈，并没有实践过。所以一定要自己动手试试。）</p><h4 id="浏览器缓存的基本原理"><a href="#浏览器缓存的基本原理" class="headerlink" title="浏览器缓存的基本原理"></a>浏览器缓存的基本原理</h4><p>1）浏览器在加载资源时，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。<br>2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过<code>last-modified</code>和<code>etag</code>验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源<br>3）如果前面两者都没有命中，直接从服务器加载资源</p><h4 id="浏览器缓存类型："><a href="#浏览器缓存类型：" class="headerlink" title="浏览器缓存类型："></a>浏览器缓存类型：</h4><p>浏览器的缓存分为两种：强缓存和协商缓存。</p><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源。</p><p>协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>共同点：两者都是从客户端缓存中读取资源；区别：强缓存不会向服务器发送请求，协商缓存会向服务器发送请求。</p><h4 id="强缓存相关字段"><a href="#强缓存相关字段" class="headerlink" title="强缓存相关字段"></a>强缓存相关字段</h4><p>Expires和Cache-Control</p><p>1）Expires</p><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。<br>Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p><blockquote><p>Expires: Wed, 11 May 2018 07:20:00 GMT</p></blockquote><p>2）Cache-Control</p><p>Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间。</p><p>相对Expires而言，max-age是距离请求发起的时间的秒数。</p><blockquote><p>Cache-Control: max-age=315360000</p></blockquote><h4 id="协商缓存相关字段"><a href="#协商缓存相关字段" class="headerlink" title="协商缓存相关字段"></a>协商缓存相关字段</h4><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p><p>1）Last-Modified，If-Modified-Since</p><p><code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</p><p>但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag</p><p>2）ETag、If-None-Match</p><p><code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的</p><p><code>If-None-Match</code>的header会将上次返回的<code>Etag</code>发送给服务器，询问该资源的<code>Etag</code>是否有更新，有变动就会发送新的资源回来</p><p>3）ETag的优先级比Last-Modified更高</p><p>具体为什么要用<code>ETag</code>，主要出于下面几种情况考虑：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p><a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">参考链接</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226262&amp;idx=1&amp;sn=2128db200b88479face67ed8e095757c&amp;chksm=bd4959128a3ed0041b43a5683c75c4b88c7d35fac909a59c14b4e9fc11e8d408680b171d2706&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;（PS:这篇文章，就是纯粹的纸上谈兵哈，并没有实践过。所以一定要自己动手试试。）&lt;/p&gt;
&lt;h4 id=&quot;浏览器缓存的基本原理&quot;&gt;&lt;a href=&quot;#浏览器缓存的基本原理&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存的基本原理&quot;&gt;&lt;/a&gt;浏览器
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>js event loop</title>
    <link href="http://yoursite.com/2018/12/06/js-event-loop/"/>
    <id>http://yoursite.com/2018/12/06/js-event-loop/</id>
    <published>2018-12-06T15:45:40.000Z</published>
    <updated>2018-12-06T08:20:37.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS-Event-Loop"><a href="#JS-Event-Loop" class="headerlink" title="JS Event Loop"></a>JS Event Loop</h3><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS-Event-Loop&quot;&gt;&lt;a href=&quot;#JS-Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;JS Event Loop&quot;&gt;&lt;/a&gt;JS Event Loop&lt;/h3&gt;&lt;hr&gt;

      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="event loop" scheme="http://yoursite.com/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2018/12/05/markdown/"/>
    <id>http://yoursite.com/2018/12/05/markdown/</id>
    <published>2018-12-05T14:13:45.000Z</published>
    <updated>2018-12-06T05:11:01.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="markdown常用语法"><a href="#markdown常用语法" class="headerlink" title="markdown常用语法"></a>markdown常用语法</h3><hr><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#1">标题</a></li><li><a href="#2">引入代码</a></li><li><a href="#3">外链</a></li><li><a href="#4">引入图片</a></li><li><a href="#5">引用</a></li><li><a href="#6">缩进</a></li><li><a href="#7">斜体</a></li><li><a href="#8">加粗</a></li><li><a href="#9">分割线</a></li><li><a href="#10">待办</a></li><li><a href="#11目录锚点">目录锚点</a></li><li><a href="#12引入单句代码">引入单句代码</a><br><h4 id="1">1、标题</h4><br>井号#后面空一格<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p></p><h4 id="2">2、引入代码</h4><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h4 id="3">3、外链</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">参考链接</span>](<span class="link">https://caychance.github.io/</span>)</span><br></pre></td></tr></table></figure><p></p><p><a href="https://caychance.github.io/" target="_blank" rel="noopener">参考链接</a></p><p></p><h4 id="4">4、引入图片</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwly1fxq7h427d7j30780c7t9o.jpg)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxq7h427d7j30780c7t9o.jpg" alt=""></p><p></p><h4 id="5">5、引用</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;一段引用的话</span><br><span class="line">换行了</span><br></pre></td></tr></table></figure><p></p><blockquote><p>一段引用的话<br>换行了</p></blockquote><p></p><h4 id="6">6、缩进</h4><br>三种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不带缩进的一行</span><br><span class="line">&amp;nbsp;不断行的空白格或&amp;#160;</span><br><span class="line">&amp;ensp;半方大的空白或&amp;#8194;</span><br><span class="line">&amp;emsp;全方大的空白或&amp;#8195;</span><br></pre></td></tr></table></figure><p></p><p>不带缩进的一行<br>&nbsp;不断行的空白格或&#160;<br>&ensp;半方大的空白或&#8194;<br>&emsp;全方大的空白或&#8195;</p><p></p><h4 id="7">7、斜体</h4><br>两种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_这是斜体_</span></span><br><span class="line"><span class="emphasis">*这是斜体*</span></span><br></pre></td></tr></table></figure><p></p><p><em>这是斜体</em><br><em>这是斜体</em></p><p></p><h4 id="8">8、加粗</h4><br>两种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">__这是斜体__</span></span><br><span class="line"><span class="strong">**这是斜体**</span></span><br></pre></td></tr></table></figure><p></p><p><strong>这是斜体</strong><br><strong>这是斜体</strong></p><p></p><h4 id="9">9、分割线</h4><br>分割线只能标题下使用<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">##### 华丽的分割线</span></span><br><span class="line">---</span><br><span class="line">华丽的分割线</span><br></pre></td></tr></table></figure><p></p><h5 id="华丽的分割线"><a href="#华丽的分割线" class="headerlink" title="华丽的分割线"></a>华丽的分割线</h5><hr><p>华丽的分割线</p><p></p><h4 id="10">10、待办</h4><br>[ ] 前后都要有空格<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[ ] 不勾选</span><br><span class="line"><span class="bullet">- </span>[x] 勾选</span><br></pre></td></tr></table></figure><p></p><ul><li style="list-style: none"><input type="checkbox"> 不勾选</li><li style="list-style: none"><input type="checkbox" checked> 勾选</li></ul><h4 id="11目录锚点"><a href="#11目录锚点" class="headerlink" title="11目录锚点"></a>11目录锚点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>[<span class="string">中国</span>](<span class="link">#中国</span>)</span><br><span class="line">  * [<span class="string">北京</span>](<span class="link">#北京</span>)</span><br><span class="line">  * [<span class="string">陕西</span>](<span class="link">#陕西</span>)</span><br><span class="line"><span class="code">    * [西安](#西安_1)</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">美国</span>](<span class="link">#美国</span>)</span><br><span class="line">  * [<span class="string">纽约</span>](<span class="link">#纽约</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">俄罗斯</span>](<span class="link">#俄罗斯</span>)</span><br><span class="line">  * [<span class="string">莫斯科</span>](<span class="link">#莫斯科</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">希腊</span>](<span class="link">#希腊</span>)</span><br><span class="line">  * [<span class="string">有些尴尬</span>](<span class="link">#有些尴尬</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="#中国">中国</a><ul><li><a href="#北京">北京</a></li><li><a href="#陕西">陕西</a><ul><li><a href="#西安_1">西安</a></li></ul></li></ul></li><li><a href="#美国">美国</a><ul><li><a href="#纽约">纽约</a></li></ul></li><li><a href="#俄罗斯">俄罗斯</a><ul><li><a href="#莫斯科">莫斯科</a></li></ul></li><li><a href="#希腊">希腊</a><ul><li><a href="#有些尴尬">有些尴尬</a></li></ul></li></ul><p></p><h4 id="西安_1">西安</h4><br>方法一：以标题西安为例。标题加一个id等于目录上西安的锚点西安_1。这种方式锚点中可以有特殊字符。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">id</span>=<span class="string">西安_1</span>&gt;</span></span>西安<span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p></p><h4 id="纽约"><a href="#纽约" class="headerlink" title="纽约"></a>纽约</h4><p>方法二：以纽约为例。markdown的标题会自动加上锚点。例如下面的锚点自动就是纽约。不过这种方式设置的锚点中不能设置特殊字符。打开开发者模式查看一下元素就明白了。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 纽约</span></span><br></pre></td></tr></table></figure></p><h4 id="12引入单句代码"><a href="#12引入单句代码" class="headerlink" title="12引入单句代码"></a>12引入单句代码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="code">`hexo server`</span>启动服务，使用<span class="code">`hexo g`</span>和<span class="code">`hexo d`</span>发布</span><br></pre></td></tr></table></figure><p>使用<code>hexo server</code>启动服务，使用<code>hexo g</code>和<code>hexo d</code>发布</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;markdown常用语法&quot;&gt;&lt;a href=&quot;#markdown常用语法&quot; class=&quot;headerlink&quot; title=&quot;markdown常用语法&quot;&gt;&lt;/a&gt;markdown常用语法&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; cl
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>github没有记录你的contributions?</title>
    <link href="http://yoursite.com/2018/12/04/github%E6%B2%A1%E6%9C%89%E8%AE%B0%E5%BD%95%E4%BD%A0%E7%9A%84contributions/"/>
    <id>http://yoursite.com/2018/12/04/github没有记录你的contributions/</id>
    <published>2018-12-04T10:51:31.000Z</published>
    <updated>2018-12-05T08:20:27.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="github是怎么计算contributions的呢？"><a href="#github是怎么计算contributions的呢？" class="headerlink" title="github是怎么计算contributions的呢？"></a>github是怎么计算contributions的呢？</h2><hr><blockquote><h4 id="贡献的计算"><a href="#贡献的计算" class="headerlink" title="贡献的计算"></a>贡献的计算</h4><h5 id="Issues-and-pull请求"><a href="#Issues-and-pull请求" class="headerlink" title="Issues and pull请求"></a>Issues and pull请求</h5><p>   如果issues和pull请求是在独立库中打开而不是分叉（fork），它们将显示在您的贡献图上。</p><h5 id="Commits"><a href="#Commits" class="headerlink" title="Commits"></a>Commits</h5><p>   如果commits符合以下所有的条件，那么会在您的贡献图上有所显示。<br>   1.用于提交的电子邮件地址与您的GitHub帐户相关联。<br>   2.在独立的库中进行提交的，而不是分支（fork）。<br>   3.提交内容如下：<br>   &emsp;在库的默认分支。（通常是master分支）。<br>   &emsp;在gh-pages分支中（对于具有Project Pages站点的库）。</p></blockquote><p><a href="https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;github是怎么计算contributions的呢？&quot;&gt;&lt;a href=&quot;#github是怎么计算contributions的呢？&quot; class=&quot;headerlink&quot; title=&quot;github是怎么计算contributions的呢？&quot;&gt;&lt;/a&gt;githu
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>服务端渲染vs客户端渲染</title>
    <link href="http://yoursite.com/2018/12/03/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93vs%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2018/12/03/服务端渲染vs客户端渲染/</id>
    <published>2018-12-02T22:25:08.000Z</published>
    <updated>2018-12-06T05:11:01.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务端渲染VS客户端渲染"><a href="#服务端渲染VS客户端渲染" class="headerlink" title="服务端渲染VS客户端渲染"></a>服务端渲染VS客户端渲染</h3><hr><p>前几天被人问到了nuxt是啥东西，我就知道这东西是vue的一个衍生品，别的就不知道了。然后吓得我回去赶紧翻开了nuxt的文档。</p><blockquote><p>Nuxt.js 是一个基于Vue.js 的轻量级应用框架，可用来创建服务端渲染(SSR) 应用，也可充当静态站点引擎生成静态站点应用，具有优雅的代码结构分层和热加载等balabala</p></blockquote><p>提到了一个词——服务端渲染，服务端渲染SSR（Server-Side Rendering）是什么？与之相对的是客户端渲染CSR（Client-Side Rendering）。<br>单从字面来理解，服务端渲染，就是服务端来渲染；客户端渲染则是客户端渲染。（这话听着像句废话）</p><h4 id="一、什么是服务端渲染和客户端渲染"><a href="#一、什么是服务端渲染和客户端渲染" class="headerlink" title="一、什么是服务端渲染和客户端渲染"></a>一、什么是服务端渲染和客户端渲染</h4><p>服务端渲染（后端渲染） 简单来说就是在服务器上把数据和模板拼接好以后发送给客户端显示。</p><p>客户端渲染（前端渲染） html 仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端，然后客户端根据 html 上的 JavaScript，生成 DOM 插入 html。</p><p>现在常用的SPA单页应用模式，就是典型的前端渲染。</p><h4 id="二、两者的本质区别"><a href="#二、两者的本质区别" class="headerlink" title="二、两者的本质区别"></a>二、两者的本质区别</h4><p>两者本地的区别就是<strong>谁来完成html文件的完整拼接</strong>。如果在后端完成，然后返回给前端，那么就是服务端渲染；否则就是客户端渲染。</p><h4 id="三、服务端渲染的优缺点"><a href="#三、服务端渲染的优缺点" class="headerlink" title="三、服务端渲染的优缺点"></a>三、服务端渲染的优缺点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>&emsp;1.不占用客户端资源，前端耗时少<br>&emsp;2.有利于SEO</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>&emsp;1.占用服务端资源。如果请求量较多，会对服务器造成一定压力。<br>&emsp;2.不利于前后端分离，开发效率较低。</p><h4 id="四、客户端渲染的优缺点"><a href="#四、客户端渲染的优缺点" class="headerlink" title="四、客户端渲染的优缺点"></a>四、客户端渲染的优缺点</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>&emsp;1.前后端分离。<br>&emsp;2.体验更好，接近于原生app。</p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>&emsp;1.前端响应较慢，首屏加载缓慢。<br>&emsp;2.不利于SEO。</p><h5 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h5><p>后端渲染html叫吐或者喷，爬虫可以看到完整的呈现源码<br>前端模板渲染html叫填，爬虫看不到完整的呈现源码</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxuug2d9gwj316o0gcmy8.jpg" alt=""></p><h4 id="五、如何选择"><a href="#五、如何选择" class="headerlink" title="五、如何选择"></a>五、如何选择</h4><p>不谈业务场景而盲目选择使用何种渲染方式都是耍流氓。比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客户端渲染。</p><p>另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了首屏服务器端渲染，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。</p><h4 id="六、写在最后"><a href="#六、写在最后" class="headerlink" title="六、写在最后"></a>六、写在最后</h4><blockquote><p>2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。</p></blockquote><p>随着Next.js和Nuxt.js的发布，<strong>以前是 Back-end（或者说 Full-stack）工程师负责 SSR，但是现在是 Front-end 工程师负责 SSR 了啊。</strong></p><p>参考文章：<br><a href="https://www.cnblogs.com/zhuzhenwei918/p/8795945.html" target="_blank" rel="noopener">服务器端渲染和客户端渲染</a><br><a href="https://www.jianshu.com/p/3e62641eb381" target="_blank" rel="noopener">也谈服务端渲染（SSR）</a><br><a href="https://jkchao.cn/article/5a11155fb520d115154c8fa1" target="_blank" rel="noopener">服务端渲染 vs 客户端渲染</a><br><a href="https://www.zhihu.com/question/59578433" target="_blank" rel="noopener">为什么现在又流行服务端渲染html？-知乎</a><br><a href="https://blog.csdn.net/b9q8e64lo6mm/article/details/79418969" target="_blank" rel="noopener">为什么现在又流行服务器端渲染html？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务端渲染VS客户端渲染&quot;&gt;&lt;a href=&quot;#服务端渲染VS客户端渲染&quot; class=&quot;headerlink&quot; title=&quot;服务端渲染VS客户端渲染&quot;&gt;&lt;/a&gt;服务端渲染VS客户端渲染&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;前几天被人问到了nuxt是啥东西，我就知道这东西是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2018/12/03/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/12/03/跨域/</id>
    <published>2018-12-02T22:20:50.000Z</published>
    <updated>2018-12-06T06:01:57.591Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="跨域" scheme="http://yoursite.com/categories/%E8%B7%A8%E5%9F%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>label标签语义化</title>
    <link href="http://yoursite.com/2018/12/01/label%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>http://yoursite.com/2018/12/01/label标签语义化/</id>
    <published>2018-11-30T16:17:03.000Z</published>
    <updated>2018-12-06T05:11:01.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="label标签的语义化"><a href="#label标签的语义化" class="headerlink" title="label标签的语义化"></a>label标签的语义化</h2><hr><p>今天做一个问卷调研的需求的时候，如下图。用户点击A选项的文字的时候被选中，而不是只能点击A前面的圆圈的时候。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxq5xd2ppyj30j20dyjtt.jpg" alt=""></p><p>html部分，需要使用input+label标签，其中label的for属性和input的id属性使用同一个变量。如下图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">:id</span>=<span class="string">"subItem"</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"answers[index]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">:for</span>=<span class="string">"subItem"</span>&gt;</span>&#123;&#123;subItem&#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刚开始用的p标签，一直不好使。后来解决了以后，去搜了一下label标签的语义化</p><blockquote><p>   <label> 标签为 input 元素定义标注（标记）。<br>     label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。<br>     如果您在 label 元素内点击文本，就会触发此控件。<br>     就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。<br>     <label> 标签的 for 属性应当与相关元素的 id 属性相同。</label></label></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;label标签的语义化&quot;&gt;&lt;a href=&quot;#label标签的语义化&quot; class=&quot;headerlink&quot; title=&quot;label标签的语义化&quot;&gt;&lt;/a&gt;label标签的语义化&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;今天做一个问卷调研的需求的时候，如下图。用户点击A选项的文
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="label" scheme="http://yoursite.com/tags/label/"/>
    
  </entry>
  
  <entry>
    <title>函数参数的解构赋值和函数参数的默认值</title>
    <link href="http://yoursite.com/2018/11/30/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <id>http://yoursite.com/2018/11/30/函数参数的解构赋值和函数参数的默认值/</id>
    <published>2018-11-30T10:58:47.000Z</published>
    <updated>2018-12-06T05:11:01.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="es6中函数参数的解构赋值和函数参数的默认值"><a href="#es6中函数参数的解构赋值和函数参数的默认值" class="headerlink" title="es6中函数参数的解构赋值和函数参数的默认值"></a>es6中函数参数的解构赋值和函数参数的默认值</h2><hr><p>昨天在二刷阮一峰es6的时候，看到了一个思考题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种写法的差异在哪里？</p><p>写法一中m1函数的入参是一个对象（默认值为一个空对象），该对象有两个属性，x（默认值为0）和y（默认值为0）。</p><p>写法二中m2函数的入参是一个对象（默认值为一个对象，对象x和y属性都为0）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1() <span class="comment">// [0, 0]</span></span><br><span class="line">m2() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure><p><a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="noopener">参考链接-阮一峰es6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;es6中函数参数的解构赋值和函数参数的默认值&quot;&gt;&lt;a href=&quot;#es6中函数参数的解构赋值和函数参数的默认值&quot; class=&quot;headerlink&quot; title=&quot;es6中函数参数的解构赋值和函数参数的默认值&quot;&gt;&lt;/a&gt;es6中函数参数的解构赋值和函数参数的默
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="解构  函数参数默认值" scheme="http://yoursite.com/tags/%E8%A7%A3%E6%9E%84-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://yoursite.com/2018/11/29/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/11/29/flex布局/</id>
    <published>2018-11-28T17:06:01.000Z</published>
    <updated>2018-12-05T08:21:43.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今天发现一个flex的问题"><a href="#今天发现一个flex的问题" class="headerlink" title="今天发现一个flex的问题"></a>今天发现一个flex的问题</h3><hr><p>flex布局中的justify-content: space-evenly;在部分安卓手机上是不支持这个属性的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-evenly</span></span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以使用space-around或者space-between配合margin一起使用达到space-evenly的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-around</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-between</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;今天发现一个flex的问题&quot;&gt;&lt;a href=&quot;#今天发现一个flex的问题&quot; class=&quot;headerlink&quot; title=&quot;今天发现一个flex的问题&quot;&gt;&lt;/a&gt;今天发现一个flex的问题&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;flex布局中的justify-conte
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="flex" scheme="http://yoursite.com/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>异步编程的前世今生</title>
    <link href="http://yoursite.com/2018/11/28/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A/"/>
    <id>http://yoursite.com/2018/11/28/异步编程的前世今/</id>
    <published>2018-11-27T18:20:25.000Z</published>
    <updated>2018-11-30T09:09:15.028Z</updated>
    
    <content type="html"><![CDATA[<p>一、问题起源：因为JS只有一根线程，因此异步编程对JS很重要。</p><p>二、目的：异步编程的语法目标，就是怎样让它更像同步编程。</p><p>三、很久很久以前：异步编程的方法有四种：</p><p>  1、回调函数；</p><p>  2、事件监听；</p><p>  3、发布/订阅；</p><p>  4、Promise对象。</p><p>四、回调函数的故事：</p><p>  1、概念：JS对异步编程的实现就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</p><p>  2、局限性：回调函数本身没有问题，但是多个回调函数嵌套的时候就会有问题。会导致代码横向发展，而不是纵向发展。称之为回调地狱。</p><p>  3、解决之道：为了解决该问题，Promise诞生了，它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载改为纵向加载。</p><p>  4、改进的地方：Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>  5、新面临的问题：然后，Promise也面临一个巨大的问题，代码冗余，原来的任务被Promise包装一下，一眼看去都是一堆then，语义变的不清楚。</p><p>五、协程的故事：</p><p>  1、概念：传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>  2、本质：协程的终极奥义就在于yield命令，它表示执行到此处，执行权将交给其他协程。即yield命令是异步两个阶段的分界线。</p><p>  3、协程在ES6中的衍生及其特点：于是乎，Generator函数诞生了。它是协程在ES6中的实现，其最大特点就是可以交出函数的执行权，即暂停执行。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。</p><p>  4、Generator的另外两个特性：Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p><p>  5、函数体内外数据交换：next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。</p><p>  6、错误处理机制：Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><p>  7、Generator函数的局限：</p><p>  7.1不能自动执行</p><p>  7.2程序的执行权移出以后，需要再次交换回来。</p><p>  综上所述：Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制（即自动执行器），当异步操作有了结果，能够自动交回执行权</p><p>  8、两种解决之道：由于Generator函数中的yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p><p>  基于Thunk函数的自动执行器：回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p><p>  基于Promise对象的自动执行器：Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</p><p>  9、co函数库，用于Generator函数的自动执行。它可以使你不用编写Generator函数的执行器。其原理就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。</p><p>六、异步编程的终极解决之道：async函数</p><p>  1、概念：一句话，async函数就是Generator函数的语法糖。</p><p>  2、改进点：async函数对Generator函数的改进体现在以下几点：</p><p>  2.1内置执行器</p><p>  Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p><p>  2.2更好的语义</p><p>  async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p><p>  2.3更广的适用性</p><p>  co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。所以，async函数的实现，就是把Generator函数和自动执行器包装在一个函数里。</p><p>  2.4返回值是Promise</p><p>  async函数的返回值是 Promise 对象。</p><p>  3、使用手册说明：</p><p>  3.1await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch中。</p><p>  3.2await命令只能用在async函数中，如果用在普通函数中，就会报错。</p><p>  3.3如有多个请求并发执行，请使用Promise.all方法。</p><p><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、问题起源：因为JS只有一根线程，因此异步编程对JS很重要。&lt;/p&gt;
&lt;p&gt;二、目的：异步编程的语法目标，就是怎样让它更像同步编程。&lt;/p&gt;
&lt;p&gt;三、很久很久以前：异步编程的方法有四种：&lt;/p&gt;
&lt;p&gt;  1、回调函数；&lt;/p&gt;
&lt;p&gt;  2、事件监听；&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="异步 Promise Generator async" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5-Promise-Generator-async/"/>
    
  </entry>
  
</feed>
