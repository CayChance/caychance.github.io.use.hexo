<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChanceのBlog</title>
  <icon>https://www.gravatar.com/avatar/54004b9178f525fba75296a91a94f3f7</icon>
  <subtitle>Do what you love,Love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caychance.github.io/"/>
  <updated>2019-04-28T03:45:31.921Z</updated>
  <id>https://caychance.github.io/</id>
  
  <author>
    <name>CayChance</name>
    <email>chance17610999610@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack4.0学习笔记</title>
    <link href="https://caychance.github.io/2019/04/27/webpack4-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caychance.github.io/2019/04/27/webpack4-0学习笔记/</id>
    <published>2019-04-26T16:21:00.000Z</published>
    <updated>2019-04-28T03:45:31.921Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h2><h2 id="为什么要用webpack"><a href="#为什么要用webpack" class="headerlink" title="为什么要用webpack"></a>为什么要用webpack</h2><h2 id="常用的loader"><a href="#常用的loader" class="headerlink" title="常用的loader"></a>常用的loader</h2><p>loader是有执行顺序的，默认的执行顺序是从右至左，从下至上执行。<br>loader的类型：</p><ol><li>前置loader pre</li><li>普通loader normal</li><li>后置loader post</li><li>内联loader</li></ol><h3 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h3><h3 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h3><h3 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h3><p>less less-loader</p><h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><p>node-sass sass-loader</p><h3 id="stylus-loader"><a href="#stylus-loader" class="headerlink" title="stylus-loader"></a>stylus-loader</h3><p>stylus stylus-loader</p><h3 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h3><p>postcss-loader autoprefixer</p><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><p>babel-loader @babel/core @babel/preset-env</p><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>eslint-loader </p><h3 id="expose-loader"><a href="#expose-loader" class="headerlink" title="expose-loader"></a>expose-loader</h3><p>代码中引入第三方模块，例如jquery，把jquery暴露给window</p><h3 id="file-loder-图片打包"><a href="#file-loder-图片打包" class="headerlink" title="file-loder 图片打包"></a>file-loder 图片打包</h3><p>file-loader默认会在内部生成一张图片到build目录下，并且把生成的图片名字返回回来</p><h2 id="常用的plugin"><a href="#常用的plugin" class="headerlink" title="常用的plugin"></a>常用的plugin</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><h3 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h3><p>压缩css 并且js还需要去压缩 使用uglifyjs-webpack-plugin</p><h3 id="webpack-ProvidePlugin"><a href="#webpack-ProvidePlugin" class="headerlink" title="webpack.ProvidePlugin"></a>webpack.ProvidePlugin</h3><p>在代码中引入第三方模块，例如jquery，可以在每个模块中引入jquery</p><p><a href="https://webpack.docschina.org/plugins/provide-plugin/" target="_blank" rel="noopener">ProvidePlugin</a></p><h2 id="在代码中引入第三方模块"><a href="#在代码中引入第三方模块" class="headerlink" title="在代码中引入第三方模块"></a>在代码中引入第三方模块</h2><h2 id="图片如何打包"><a href="#图片如何打包" class="headerlink" title="图片如何打包"></a>图片如何打包</h2><ol><li>在js中引入</li><li>在css中</li><li>在html中</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;webpack是什么&quot;&gt;&lt;a href=&quot;#webpack是什么&quot; class=&quot;headerlink&quot; title=&quot;webpack是什么&quot;&gt;&lt;/a&gt;webpack是什么&lt;/h2&gt;&lt;h2 id=&quot;为什么要用webpack&quot;&gt;&lt;a href=&quot;#为什么要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试小记</title>
    <link href="https://caychance.github.io/2019/04/13/%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/"/>
    <id>https://caychance.github.io/2019/04/13/面试小记/</id>
    <published>2019-04-12T23:53:48.000Z</published>
    <updated>2019-04-28T11:36:56.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="css三列布局，两边固定宽度，中间自适应"><a href="#css三列布局，两边固定宽度，中间自适应" class="headerlink" title="css三列布局，两边固定宽度，中间自适应"></a>css三列布局，两边固定宽度，中间自适应</h3><h3 id="两栏布局-至少三种，float-absolute-flex"><a href="#两栏布局-至少三种，float-absolute-flex" class="headerlink" title="两栏布局(至少三种，float/absolute/flex)"></a>两栏布局(至少三种，float/absolute/flex)</h3><h3 id="三栏布局-双飞翼-圣杯-flex"><a href="#三栏布局-双飞翼-圣杯-flex" class="headerlink" title="三栏布局(双飞翼/圣杯/flex)"></a>三栏布局(双飞翼/圣杯/flex)</h3><h3 id="BFC-产生条件、用途"><a href="#BFC-产生条件、用途" class="headerlink" title="BFC(产生条件、用途)"></a>BFC(产生条件、用途)</h3><p>产生条件：</p><ul><li>body根元素</li><li>float元素 float不等于none</li><li>绝对定位 absolute fixed</li><li>display等于inline-block、table-cells、flex</li><li>overflow除了visible以外的值hidden、auto、scroll</li></ul><p>BFC的用途/特性：</p><ul><li>同一个BFC中的margin会重叠</li><li>浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。</li><li>BFC可以阻止元素被浮动元素覆盖。</li></ul><h3 id="用border画一个半圆-三角形"><a href="#用border画一个半圆-三角形" class="headerlink" title="用border画一个半圆/三角形"></a>用border画一个半圆/三角形</h3><ul><li>三角形</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">border-top</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">blue</span>;</span><br><span class="line"><span class="selector-tag">border-right</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line"><span class="selector-tag">border-bottom</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">green</span>;</span><br><span class="line"><span class="selector-tag">border-left</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">yellow</span>;</span><br></pre></td></tr></table></figure><ul><li>半圆</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-radius</span>: 50<span class="selector-tag">px</span> 50<span class="selector-tag">px</span> 0 0;</span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">pink</span>;</span><br></pre></td></tr></table></figure><h3 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h3><h3 id="实现向内旋转的效果-transform-rotateY"><a href="#实现向内旋转的效果-transform-rotateY" class="headerlink" title="实现向内旋转的效果(transform: rotateY)"></a>实现向内旋转的效果(transform: rotateY)</h3><h3 id="css3如何开启动画的GPU加速-translate3d-0-0-0"><a href="#css3如何开启动画的GPU加速-translate3d-0-0-0" class="headerlink" title="css3如何开启动画的GPU加速(translate3d(0, 0, 0))"></a>css3如何开启动画的GPU加速(translate3d(0, 0, 0))</h3><h3 id="行内元素padding-margin有用吗"><a href="#行内元素padding-margin有用吗" class="headerlink" title="行内元素padding margin有用吗"></a>行内元素padding margin有用吗</h3><ul><li>padding有用</li><li>margin左右有用，上下无效。</li></ul><h3 id="盒模型有哪两种，区别是啥"><a href="#盒模型有哪两种，区别是啥" class="headerlink" title="盒模型有哪两种，区别是啥"></a>盒模型有哪两种，区别是啥</h3><ul><li>IE盒模型 border-box<br>width = content宽度+padding+border</li><li>W3C盒模型 content-box<br>width = content宽度</li></ul><h3 id="常用移动端适配方案，border-1px在dpr比较大的手机上咋解决"><a href="#常用移动端适配方案，border-1px在dpr比较大的手机上咋解决" class="headerlink" title="常用移动端适配方案，border 1px在dpr比较大的手机上咋解决"></a>常用移动端适配方案，border 1px在dpr比较大的手机上咋解决</h3><ul><li><a href="https://juejin.im/post/5c0dd7ac6fb9a049c43d7edc" target="_blank" rel="noopener">掘金-移动端适配总结</a> 感觉这篇文章里的适配代码是个无敌的答案</li></ul><h3 id="css水平垂直居中"><a href="#css水平垂直居中" class="headerlink" title="css水平垂直居中"></a>css水平垂直居中</h3><ul><li>table-cell</li><li>absolute</li><li>transform:translate</li><li>flex</li><li>grid</li></ul><h3 id="flex-align-item-align-content的区别"><a href="#flex-align-item-align-content的区别" class="headerlink" title="flex  align-item align-content的区别"></a>flex  align-item align-content的区别</h3><ul><li>容器属性<ul><li>flex-direction        主轴的方向</li><li>flex-wrap        主轴一行展示不下，如何换行</li><li>justify-content    项目在主轴上的对齐方式</li><li>align-items        项目在交叉轴上的对齐方式</li><li>align-content        多根轴线如何对齐</li></ul></li><li>项目属性<ul><li>order             项目的排列顺序 越小越靠前 默认0</li><li>flex-grow        项目的放大比例<br>默认为0 等于0不会放大。大于0，如果有剩余空间的情况下，项目1为x1，项目2为x2，则项目1占剩余空间的x1/(x1+x2)</li><li>flex-shrink        项目的缩小比例<br>默认为1 等于0不参与缩小。ul width 100px。两个li宽100px，默认每个li都会被缩小1/(1+1)=1/2。第一个li 2，第二个li 3，则第一个li被缩小2/(2+3)=2/5，被缩小的实际宽度为2/5*100=40，剩余宽度为60。第一个li 为0，如果第二个li为0，那么两者都不缩小，第二个li 大于0，那么li实际宽度，第一个li不缩小。</li><li>flex-basis        项目的占据主轴的空间 默认auto</li><li>flex-self            该项目单独的对齐方式</li></ul></li></ul><h3 id="单行，多行文本超出省略号"><a href="#单行，多行文本超出省略号" class="headerlink" title="单行，多行文本超出省略号"></a>单行，多行文本超出省略号</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><h3 id="和-代表啥"><a href="#和-代表啥" class="headerlink" title=":和::代表啥"></a>:和::代表啥</h3><ul><li>:伪类</li><li>::伪元素</li></ul><h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><h3 id="基本类型和引用类型在内存中是如何存储的"><a href="#基本类型和引用类型在内存中是如何存储的" class="headerlink" title="基本类型和引用类型在内存中是如何存储的"></a>基本类型和引用类型在内存中是如何存储的</h3><ul><li>基本类型存储在栈内存</li><li>引用类型存储在堆内存 栈内存中存的是引用类型在堆内存中的地址 或者说存的是引用类型的引用</li></ul><h3 id="事件委托和事件代理"><a href="#事件委托和事件代理" class="headerlink" title="事件委托和事件代理"></a>事件委托和事件代理</h3><p>一个ul里面有很多个li的时候，如果想让每个li都有一个点击事件，不需要给每个li都去添加，只需要给ul添加一个就行了。</p><p>利用事件冒泡的原理。</p><h3 id="闭包-会导致的问题-如何解决"><a href="#闭包-会导致的问题-如何解决" class="headerlink" title="闭包 会导致的问题 如何解决"></a>闭包 会导致的问题 如何解决</h3><p>闭包使用不当会导致内存溢出。因此，在退出函数之前，将不使用的局部变量全部删除。</p><h3 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a>js的垃圾回收机制</h3><ul><li>引用计数垃圾收集<br>概念：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放；<br>缺点：该算法有一个限制——循环引用。</li><li>标记-清除垃圾回收算法<br>2012年起，所有现代浏览器都是用了该算法</li></ul><h3 id="原生的ajax"><a href="#原生的ajax" class="headerlink" title="原生的ajax"></a>原生的ajax</h3><p>XMLHttp​Request</p><h3 id="window-onload和document-onload的区别"><a href="#window-onload和document-onload的区别" class="headerlink" title="window.onload和document.onload的区别"></a>window.onload和document.onload的区别</h3><h3 id="match方法实现，支持-和-通配符"><a href="#match方法实现，支持-和-通配符" class="headerlink" title="match方法实现，支持?和*通配符"></a>match方法实现，支持?和*通配符</h3><h3 id="ES6模块和CommonJs模块的区别"><a href="#ES6模块和CommonJs模块的区别" class="headerlink" title="ES6模块和CommonJs模块的区别"></a>ES6模块和CommonJs模块的区别</h3><ul><li>commonJs是被加载的时候运行，es6是编译的时候运行</li><li>commonJs输出的是值的浅拷贝，es6输出值的引用</li><li>commentJs具有缓存。在第一次被加载时，会完整运行整个文件并输出一个对象，拷贝（浅拷贝）在内存中。下次加载文件时，直接从内存中取值</li><li>参考链接<br><a href="https://juejin.im/post/5ae04fba6fb9a07acb3c8ac5" target="_blank" rel="noopener">掘金-CommonJs 和 ESModule 的 区别整理</a><br><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html" target="_blank" rel="noopener">JavaScript 模块的循环加载</a></li></ul><h3 id="es6新特性列举几个"><a href="#es6新特性列举几个" class="headerlink" title="es6新特性列举几个"></a>es6新特性列举几个</h3><p><code>let/const</code>，<code>箭头函数</code>，<code>解构</code>，<code>模板字符串</code>，<code>Promise</code>，<code>Class</code></p><h3 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var/let/const 区别"></a>var/let/const 区别</h3><table><thead><tr><th style="text-align:center">声明方式</th><th style="text-align:center">变量提升</th><th style="text-align:center">重复声明</th><th style="text-align:center">暂时性死区</th><th style="text-align:center">初始值</th><th style="text-align:center">作用域</th></tr></thead><tbody><tr><td style="text-align:center">var</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">不存在</td><td style="text-align:center">不需要</td><td style="text-align:center">除块级</td></tr><tr><td style="text-align:center">let</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">存在</td><td style="text-align:center">需要</td><td style="text-align:center">块级</td></tr><tr><td style="text-align:center">const</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">存在</td><td style="text-align:center">需要</td><td style="text-align:center">块级</td></tr></tbody></table><p>const实际上保证的，并<strong>不是变量的值不得改动</strong>，而是<strong>变量指向的那个内存地址所保存的数据不得改动</strong>。</p><h3 id="es6中Object的方法-Object-assign-合并对象是浅拷贝，深拷贝"><a href="#es6中Object的方法-Object-assign-合并对象是浅拷贝，深拷贝" class="headerlink" title="es6中Object的方法  Object.assign()合并对象是浅拷贝，深拷贝"></a>es6中Object的方法  Object.assign()合并对象是浅拷贝，深拷贝</h3><ul><li>浅拷贝<br>Object.assign()</li><li>深拷贝<ul><li>JSON.parse(JSON.stringify(obj))</li><li>手写一个深拷贝</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'object'</span>)&#123;</span><br><span class="line">    result = obj.constructor === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      result[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span> ? deepClone(obj[i]) : obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> result = obj;</span><br><span class="line">  <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="es6模板字符串如何实现"><a href="#es6模板字符串如何实现" class="headerlink" title="es6模板字符串如何实现"></a>es6模板字符串如何实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">content</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> content.replace(<span class="regexp">/\$\&#123;([^&#125;]+)\&#125;/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">matched,childItem</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(childItem);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//   /\$\&#123;([^&#125;]+)\&#125;/g</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个正则匹配的内容就是$&#123;&#125;，括号里面是除了&#125;以外所有的字符，并且若干个</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ul><li>箭头函数声明时绑定this。</li><li>普通函数执行时绑定this</li><li>箭头函数不能用于构造函数，不能使用new，不能call,apply,bind，不能当作generator函数，不能使用yield，没有arguments，没有prototype。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;</span><br><span class="line">  func:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b=a.func; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  func:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> d=c.func</span><br><span class="line"><span class="comment">//a.func 输出a本身 b(),c.func(),c()输出window</span></span><br></pre></td></tr></table></figure><h3 id="继承-原型-原型链"><a href="#继承-原型-原型链" class="headerlink" title="继承 原型 原型链"></a>继承 原型 原型链</h3><ul><li>使用ES5实现一个继承 <strong>核心是用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'parent name:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, parentName</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, parentName);  </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = proto;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = create(Parent.prototype);</span><br><span class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'child name:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</span><br><span class="line">parent.sayName();    <span class="comment">// parent name: father</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>, <span class="string">'father'</span>);</span><br></pre></td></tr></table></figure><ul><li>ES6继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parentName,age)&#123;</span><br><span class="line">    <span class="keyword">super</span>(parentName);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">handle = <span class="function"><span class="params">array</span>=&gt;</span>array.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>&#123;</span><br><span class="line">  !p.includes(c) &amp;&amp; p.push(c);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><ul><li>遍历</li></ul><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><ul><li><code>forEach</code> <code>map</code> <code>reduce</code> <code>filter</code> <code>some</code> <code>every</code> <code>concat</code> <code>push</code> <code>pop</code> <code>unshift</code> <code>shift</code></li><li>用reduce实现map</li><li>用reduce计算[2, [3, 4], [4, [5, 6]]]里所有的值的和</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="function"><span class="params">array</span>=&gt;</span>array.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p+(<span class="built_in">Array</span>.isArray(c) ? sum(c) : c),<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>使用reduce实现flap方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flap = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">p,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.concat(<span class="built_in">Array</span>.isArray(c) ? myFlap(c) : c);</span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFlap = <span class="function"><span class="params">array</span>=&gt;</span>array.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p.concat(<span class="built_in">Array</span>.isArray(c) ? myFlap(c) : c),[])</span><br></pre></td></tr></table></figure><h3 id="for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性"><a href="#for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性" class="headerlink" title="for in/for of/for 遍历对象 缺点 只能遍历原型的属性"></a>for in/for of/for 遍历对象 缺点 只能遍历原型的属性</h3><blockquote><p>for…in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。</p></blockquote><blockquote><p>for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p></blockquote><ul><li>for in 可以遍历数组和对象。可以获取key和value。</li><li>for of 可以遍历数组，<strong>不可遍历对象</strong>。只能获取value</li><li>for循环就是遍历数组的方法。</li></ul><h3 id="如何判断一个数组"><a href="#如何判断一个数组" class="headerlink" title="如何判断一个数组"></a>如何判断一个数组</h3><ul><li><code>arr instanceof Array</code> </li><li><code>arr.constructor === Array</code></li><li><code>Object.prototype.toString.call(arr)</code></li><li><code>Array.isArray(arr)</code></li></ul><h3 id="如何判断一个对象是否为空对象"><a href="#如何判断一个对象是否为空对象" class="headerlink" title="如何判断一个对象是否为空对象"></a>如何判断一个对象是否为空对象</h3><ul><li><code>for in</code></li><li><code>Object.keys()</code></li></ul><h3 id="如何判断一个类数组对象"><a href="#如何判断一个类数组对象" class="headerlink" title="如何判断一个类数组对象"></a>如何判断一个类数组对象</h3><ul><li>本质还是一个对象</li><li>有一个length属性</li></ul><h3 id="异步的处理方式都有哪些"><a href="#异步的处理方式都有哪些" class="headerlink" title="异步的处理方式都有哪些"></a>异步的处理方式都有哪些</h3><ul><li>回调函数</li><li>promise</li><li>generator</li><li>async/await</li></ul><p><a href="https://caychance.github.io/2018/11/28/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A/#more">关于js中的异步</a></p><h3 id="Promise和async-await"><a href="#Promise和async-await" class="headerlink" title="Promise和async/await"></a>Promise和async/await</h3><h3 id="Promise原理-手写"><a href="#Promise原理-手写" class="headerlink" title="Promise原理 手写"></a>Promise原理 手写</h3><ul><li>Promise中存在三个状态    等待态pending 执行态fullfilled 拒绝态rejected</li><li>Promise状态不可逆    pending=&gt;fullfied  pending=&gt;rejected</li><li>Promise.then()方法返回一个Promise对象，因此可以链式调用</li><li>Promise接受的函数参数是同步执行的，但then方法中的回调函数则是异步的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//promise声明</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>()&#123;<span class="comment">//成功</span></span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//promise调用</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// succ</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise封装setTimeOut"><a href="#Promise封装setTimeOut" class="headerlink" title="Promise封装setTimeOut"></a>Promise封装setTimeOut</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait=<span class="function"><span class="params">time</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">y</span>=&gt;</span>setTimeout(y,time))</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>async/await是generator的语法糖。</p><p>async/await对generator的改进有以下几点：</p><ul><li>内置执行器<br>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li><li>更好的语义<br>async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性<br>co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。所以，async函数的实现，就是把Generator函数和自动执行器包装在一个函数里。</li><li>返回值是Promise<br>async函数的返回值是 Promise 对象。</li></ul><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>Event Loop分为<strong>浏览器中的Event Loop</strong>和<strong>Node中的Event Loop</strong></p><h3 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h3><blockquote><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p></blockquote><h3 id="Node中的Event-Loop"><a href="#Node中的Event-Loop" class="headerlink" title="Node中的Event Loop"></a>Node中的Event Loop</h3><blockquote><p>（1）V8引擎解析JavaScript脚本。<br>（2）解析后的代码，调用Node API。<br>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），任务的执行结果会以异步的方式返回给V8引擎。<br>（4）V8引擎再将结果返回给用户。</p></blockquote><h3 id="宏任务和微任务的执行顺序"><a href="#宏任务和微任务的执行顺序" class="headerlink" title="宏任务和微任务的执行顺序"></a>宏任务和微任务的执行顺序</h3><blockquote><p>（1）先执行宏任务，执行完后，查看是否有微任务队列<br>（2）如果有微任务队列，则执行微任务<br>（3）如果没有，则读取宏任务中排在最前列的任务<br>（4）执行宏任务的过程中遇到微任务，则加入微任务队列<br>（5）执行完宏任务后，查看是否有微任务队列</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 1 2 3 6 8 4 7 5</span></span><br></pre></td></tr></table></figure><h3 id="Node的执行顺序"><a href="#Node的执行顺序" class="headerlink" title="Node的执行顺序"></a>Node的执行顺序</h3><p>数据输入 =&gt; poll轮询 =&gt; check检查 =&gt; close callbacks关闭事件回调 =&gt; timers定时器 =&gt; I/O callbacks I/O事件回调 =&gt; idle prepare 闲置 =&gt; 轮询</p><h3 id="同步任务和异步任务的定义"><a href="#同步任务和异步任务的定义" class="headerlink" title="同步任务和异步任务的定义"></a>同步任务和异步任务的定义</h3><p>CPU会立即执行的任务是同步任务。</p><h3 id="node属于多线程还是单线程"><a href="#node属于多线程还是单线程" class="headerlink" title="node属于多线程还是单线程"></a>node属于多线程还是单线程</h3><ul><li>单线程</li></ul><h3 id="node的前端模板"><a href="#node的前端模板" class="headerlink" title="node的前端模板"></a>node的前端模板</h3><ul><li>ejs pug</li></ul><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>process对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。</p><p>类似global全局对象，浏览器中的window。</p><h3 id="call-apply-bind的区别-手写？"><a href="#call-apply-bind的区别-手写？" class="headerlink" title="call apply bind的区别 手写？"></a>call apply bind的区别 手写？</h3><ul><li>三者都是改变this的指向。</li><li>区别call，apply返回函数执行的结果，bind则返回一个函数</li><li>其中call的参数是展开的数据，apply的参数是数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> bindFn ? <span class="keyword">this</span> : context, args.concat([...arguments]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  tem.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFn.prototype = <span class="keyword">new</span> tem();</span><br><span class="line">  <span class="keyword">return</span> bindFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new发生了什么"><a href="#new发生了什么" class="headerlink" title="new发生了什么"></a>new发生了什么</h3><ul><li>新建一个新对象</li><li>this指向新对象</li><li>为新对象添加属性</li><li>返回新对象</li></ul><h3 id="函数递归-f-n-返回1到n的累加和"><a href="#函数递归-f-n-返回1到n的累加和" class="headerlink" title="函数递归 f(n) 返回1到n的累加和"></a>函数递归 f(n) 返回1到n的累加和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    result = n+sum(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    result = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">n</span>=&gt;</span>n&gt;<span class="number">1</span> ? n+sum(n<span class="number">-1</span>) : n;</span><br></pre></td></tr></table></figure><h3 id="SSR-Nuxt-Next"><a href="#SSR-Nuxt-Next" class="headerlink" title="SSR Nuxt Next"></a>SSR Nuxt Next</h3><ul><li>服务器端渲染</li></ul><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><ul><li>匹配所有非空白符 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</li><li>匹配非回车的字符</li><li>匹配所有字符</li><li>12345678变成12,345,678的正则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">(str.replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">','</span>))</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">str.toLocaleString()</span><br></pre></td></tr></table></figure><h3 id="instanceOf-Object-create-new的实现原理"><a href="#instanceOf-Object-create-new的实现原理" class="headerlink" title="instanceOf/Object.create/new的实现原理"></a>instanceOf/Object.create/new的实现原理</h3><h3 id="已知"><a href="#已知" class="headerlink" title="已知"></a>已知</h3><p>一个全部装着url的数组urls和一个叫fetch的ajax api，实现一个函数ajaxAll(urls, maxParallel, cb)，同时最多并行执行maxParallel个请求，所有url得到结果后执行cb</p><h3 id="求以下输出"><a href="#求以下输出" class="headerlink" title="求以下输出"></a>求以下输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;get()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name&#125;&#125;)</span><br><span class="line"><span class="comment">// 循环引用 导致内存溢出</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出什么 如何修改</span></span><br><span class="line"><span class="comment">//输出5个5</span></span><br><span class="line"><span class="comment">//想输出1，2，3，4，5，可以使用let,IIFE,setTimeout第三个参数</span></span><br></pre></td></tr></table></figure><h3 id="手写一个div的拖拽功能"><a href="#手写一个div的拖拽功能" class="headerlink" title="手写一个div的拖拽功能"></a>手写一个div的拖拽功能</h3><h3 id="写一个工厂函数用于生成对象"><a href="#写一个工厂函数用于生成对象" class="headerlink" title="写一个工厂函数用于生成对象"></a>写一个工厂函数用于生成对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂模式？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用的手写"><a href="#常用的手写" class="headerlink" title="常用的手写"></a>常用的手写</h3><ul><li>bind,call,apply</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype._apply = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// this的实例是bindFn，说明使用了new</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> bindFn ? <span class="keyword">this</span> : context,args.concat(bindArgs));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bindFn继承this</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tem</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  tem.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFn.prototype = <span class="keyword">new</span> tem();</span><br><span class="line">  <span class="keyword">return</span> bindFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>new</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myNew(fn, args) --&gt; new fn(args)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fn是构造函数</span></span><br><span class="line"><span class="comment">1、创建一个新对象；</span></span><br><span class="line"><span class="comment">2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</span></span><br><span class="line"><span class="comment">3、执行构造函数中的代码（为这个新对象添加属性）；</span></span><br><span class="line"><span class="comment">4、返回新对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(fn.prototype !== <span class="literal">null</span>)&#123;</span><br><span class="line">    obj.__proto__ === fn.prototype</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = fn.apply(obj,args);</span><br><span class="line">  <span class="keyword">if</span>(res !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> res === <span class="string">'object'</span> || <span class="keyword">typeof</span> res === <span class="string">'function'</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object.create</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 </span></span><br><span class="line"><span class="comment">// var b = Object.create(obj)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>instanceOf</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一直遍历 left的__proto__，一直遍历到null。</span></span><br><span class="line"><span class="comment">如果到null之前都没有proto等于prototype就返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = left.__proto__;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种写法更简洁吧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(left)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left.__proto__ === right.prototye) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo 手写promise</span></span><br></pre></td></tr></table></figure><ul><li>flat</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flat = <span class="function"><span class="params">array</span>=&gt;</span>array.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p.concat(<span class="built_in">Array</span>.isArray(c) ? flat(c) : c),[])</span><br></pre></td></tr></table></figure><ul><li>节流</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span>(now-prev&gt;delay)&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">      prev = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>防抖</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay,immediate</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(timer) clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'my name is '</span>,<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,fatherName</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//step 1</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>,fatherName);</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Father</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//step 2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  F.prototype = Father.prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = create(Father);</span><br><span class="line">Son.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello boy'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure><ul><li>参考链接<br><a href="https://juejin.im/post/5c9edb066fb9a05e267026dc" target="_blank" rel="noopener">掘金-【前端面试】同学，你会手写代码吗？</a><br><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6" target="_blank" rel="noopener">「中高级前端面试」JavaScript手写代码无敌秘籍</a></li></ul><h2 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h2><h3 id="Vue提倡的是单向数据流，但是v-model是双向数据流，为什么"><a href="#Vue提倡的是单向数据流，但是v-model是双向数据流，为什么" class="headerlink" title="Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?"></a>Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?</h3><ul><li>v-model只是一个语法糖，本质还是单向数据流</li><li>v-bind:value和v-on:input</li></ul><h3 id="vue-use"><a href="#vue-use" class="headerlink" title="vue.use()"></a>vue.use()</h3><p>全局注入一个插件</p><h3 id="Vue双向绑定-实现原理"><a href="#Vue双向绑定-实现原理" class="headerlink" title="Vue双向绑定 实现原理"></a>Vue双向绑定 实现原理</h3><p>object.defineproperty()修改getter和setter+发布订阅模式</p><h3 id="Vue的数据响应系统原理"><a href="#Vue的数据响应系统原理" class="headerlink" title="Vue的数据响应系统原理"></a>Vue的数据响应系统原理</h3><h3 id="Vue中，数组的操作是如何实现数据响应的-push等原型函数以及为什么用-set"><a href="#Vue中，数组的操作是如何实现数据响应的-push等原型函数以及为什么用-set" class="headerlink" title="Vue中，数组的操作是如何实现数据响应的(push等原型函数以及为什么用$set)"></a>Vue中，数组的操作是如何实现数据响应的(push等原型函数以及为什么用$set)</h3><h3 id="Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信"><a href="#Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信" class="headerlink" title="Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信"></a>Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信</h3><ul><li><code>props</code> <code>$emit</code></li></ul><h3 id="vue-3有哪些新的东西知道吗"><a href="#vue-3有哪些新的东西知道吗" class="headerlink" title="vue 3有哪些新的东西知道吗"></a>vue 3有哪些新的东西知道吗</h3><ul><li>可以着重聊聊数据响应系统使用Proxy和原来的区别，<a href="https://www.html.cn/archives/10052" target="_blank" rel="noopener">可以看看这个</a></li><li>对Vue确实需要比较深的了解，推荐把这个看完 Vue技术内幕，不过这个里面没有AST的东西</li></ul><h3 id="以下代码经过模板渲染后变成了什么样子简单讲一下"><a href="#以下代码经过模板渲染后变成了什么样子简单讲一下" class="headerlink" title="以下代码经过模板渲染后变成了什么样子简单讲一下"></a>以下代码经过模板渲染后变成了什么样子简单讲一下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent :prop1=&quot;data1&quot;&gt;</span><br><span class="line">    &lt;child :prop2=&quot;data2&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><h3 id="provide-inject能解决什么问题"><a href="#provide-inject能解决什么问题" class="headerlink" title="provide/inject能解决什么问题"></a>provide/inject能解决什么问题</h3><h3 id="computed和props-data的区别，其实现原理是什么"><a href="#computed和props-data的区别，其实现原理是什么" class="headerlink" title="computed和props/data的区别，其实现原理是什么"></a>computed和props/data的区别，其实现原理是什么</h3><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><ul><li>主要有两种模式 <strong>hash模式</strong> <strong>history模式</strong></li><li><strong>本质</strong>就是监听url的变化，然后匹配路由规则，显示相应的页面，并且无需刷新</li><li>hash模式    点击跳转通过hashchange事件来监听到url的变化    手动刷新通过load事件</li><li>history模式        点击跳转通过pushState    浏览器动作 回退等 popState        刷新或者输入url 会向服务器发送请求 <strong>需要后端配合重定向</strong></li></ul><h3 id="Vue-Router中query和param的区别"><a href="#Vue-Router中query和param的区别" class="headerlink" title="Vue Router中query和param的区别"></a>Vue Router中query和param的区别</h3><ul><li>都可以在两个页面之间进行传值</li><li>query path?id=1 ; param path/1</li><li>param如果不在router中配置的话，页面刷新，param会丢失</li></ul><h3 id="Vuex数据周期-如何使用-有什么好处"><a href="#Vuex数据周期-如何使用-有什么好处" class="headerlink" title="Vuex数据周期 如何使用 有什么好处"></a>Vuex数据周期 如何使用 有什么好处</h3><p>state – dispatch –&gt; actions – commit –&gt; mutations</p><h3 id="vue-nextTick的原理-如何找到dom-依赖收集过程"><a href="#vue-nextTick的原理-如何找到dom-依赖收集过程" class="headerlink" title="vue.nextTick的原理 如何找到dom 依赖收集过程"></a>vue.nextTick的原理 如何找到dom 依赖收集过程</h3><ul><li>nextTick是Vue的一个全局函数，用于处理dom更新操作。Vue里面有一个watcher，用于观察数据的变化，然后更新dom。Vue里面并不是每次数据变化都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom操作。</li><li>watch的实现，当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</li><li>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</li><li>Vue是异步执行dom更新的</li><li>Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</li></ul><h3 id="virtual-dom-diff算法具体实现过程"><a href="#virtual-dom-diff算法具体实现过程" class="headerlink" title="virtual-dom    diff算法具体实现过程"></a>virtual-dom    diff算法具体实现过程</h3><ul><li>diff算法源于snabbdom，复杂度为O(n)</li><li>只会在同层级比较，不会跨层级比较</li><li>重点是patch方法</li></ul><h3 id="patch方法详解"><a href="#patch方法详解" class="headerlink" title="patch方法详解"></a>patch方法详解</h3><p>注释：vnode：新的虚拟节点 oldVnode：旧的虚拟节点</p><blockquote><blockquote></blockquote><ul><li>vnode不存在但是oldVnode存在，需要销毁oldVnode</li><li>oldVnode不存在但是vnode存在，创建新节点</li><li>oldVnode和vnode都存在<br>3.1 oldVnode和vnode是同一个节点 执行patchVnode方法<br>3.2 vnode创建真实dom并替换oldVnode.elm</li></ul></blockquote><h3 id="patchVnode方法详解"><a href="#patchVnode方法详解" class="headerlink" title="patchVnode方法详解"></a>patchVnode方法详解</h3><blockquote><blockquote></blockquote><ul><li>oldVnode和vnode完全一致，则不需要做任何事情</li><li>oldVnode和vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上即可</li><li>vnode不是文本节点或注释节点<br>3.1 如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行updateChildren方法<br>3.2 只有oldVnode有子节点，那就把这些节点都删除<br>3.3 如果只有vnode有子节点，那就创建这些子节点<br>3.4 如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串</li><li>vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</li></ul></blockquote><h3 id="updateChildren方法详解"><a href="#updateChildren方法详解" class="headerlink" title="updateChildren方法详解"></a>updateChildren方法详解</h3><blockquote><blockquote></blockquote><ul><li>oldStartIdx&gt;oldEndIdx<br>oldCh已经遍历完了，但是newCh还没有，把newStartIdx-newEndIdx之间的vnode都是新增的，把这些vnode添加到oldCh末尾</li><li>newStartIdx&gt;newEndIdx<br>newCh已经遍历完了，但是oldCh还没有，把oldCh中oldStartIdx-oldEndIdx之间的vnode删除</li><li>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx<br>3.1 oldVnode第一个child不存在，oldStart索引右移<br>3.2 oldVnode最后一个child不存在，oldEnd索引左移<br>3.3 oldStartVnode和newStartVnode是同一个节点，patchVnode两个节点，索引右移<br>3.4 oldEndVnode和newEndVnode是同一个节点，patchVnode两个节点，索引左移<br>3.5 oldStartVnode和newEndVnode是同一个节点，移动oldStartVnode到oldEndVnode节点后面<br>3.6 oldEndVnode和newStartVnode是同一个节点，移动oldEndVnode到oldStartVnode前面<br>3.7 oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点<br>3.8 如果找到了相同key的节点，比较两个节点是否属于同一个节点，如果属于同一节点，就patchVnode，否则新创建节点</li></ul></blockquote><h3 id="为什么要使用key？"><a href="#为什么要使用key？" class="headerlink" title="为什么要使用key？"></a>为什么要使用key？</h3><p>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p><h3 id="Vue-React-Angular区别"><a href="#Vue-React-Angular区别" class="headerlink" title="Vue,React,Angular区别"></a>Vue,React,Angular区别</h3><h3 id="Vue多端框架"><a href="#Vue多端框架" class="headerlink" title="Vue多端框架"></a>Vue多端框架</h3><ul><li>uni-app</li></ul><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul><li><p>M:Model层<br>数据模型</p></li><li><p>V:View层<br>视图层</p></li><li><p>VM:<br>是Model和Controller之间的一座桥梁。</p></li></ul><p>MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来。</p><h3 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h3><ul><li>axios.interceptors.request.use</li><li>axios.interceptors.response.use</li><li>axios.default.header</li></ul><h2 id="Wepack以及项目优化"><a href="#Wepack以及项目优化" class="headerlink" title="Wepack以及项目优化"></a>Wepack以及项目优化</h2><h3 id="webpack打包原理"><a href="#webpack打包原理" class="headerlink" title="webpack打包原理"></a>webpack打包原理</h3><h3 id="module和chunk的区别"><a href="#module和chunk的区别" class="headerlink" title="module和chunk的区别"></a>module和chunk的区别</h3><h3 id="loader和plugin的区别"><a href="#loader和plugin的区别" class="headerlink" title="loader和plugin的区别"></a>loader和plugin的区别</h3><ul><li>loader<br>loaders是在打包构建过程中用来处理源文件的(JSX,Scss,Less)，一次处理一个；</li><li>plugin<br>plugins并不直接操作单个文件，它直接对整个构建过程起作用。</li></ul><h3 id="webpack-4相比3有什么变化"><a href="#webpack-4相比3有什么变化" class="headerlink" title="webpack 4相比3有什么变化"></a>webpack 4相比3有什么变化</h3><h3 id="webpack构建速度优化有哪些方式-这个能扯半个小时"><a href="#webpack构建速度优化有哪些方式-这个能扯半个小时" class="headerlink" title="webpack构建速度优化有哪些方式(这个能扯半个小时)"></a>webpack构建速度优化有哪些方式(这个能扯半个小时)</h3><h3 id="tree-shaking-scope-hoisting-code-spliting-都有什么作用"><a href="#tree-shaking-scope-hoisting-code-spliting-都有什么作用" class="headerlink" title="tree-shaking/scope-hoisting/code-spliting 都有什么作用"></a>tree-shaking/scope-hoisting/code-spliting 都有什么作用</h3><h3 id="webpack热更新的模块"><a href="#webpack热更新的模块" class="headerlink" title="webpack热更新的模块"></a>webpack热更新的模块</h3><ul><li>HotModuleReplacementPlugin</li><li>该模块是如何做到监听代码修改然后刷新页面的</li></ul><h3 id="webpack配置压缩一个js如何配置"><a href="#webpack配置压缩一个js如何配置" class="headerlink" title="webpack配置压缩一个js如何配置"></a>webpack配置压缩一个js如何配置</h3><ul><li>webpack.base.conf.js     entry output module loaders</li></ul><h3 id="webpack编译后图片名为什么会改变"><a href="#webpack编译后图片名为什么会改变" class="headerlink" title="webpack编译后图片名为什么会改变"></a>webpack编译后图片名为什么会改变</h3><h2 id="浏览器及安全"><a href="#浏览器及安全" class="headerlink" title="浏览器及安全"></a>浏览器及安全</h2><h3 id="浏览器中支持最大的请求并发数"><a href="#浏览器中支持最大的请求并发数" class="headerlink" title="浏览器中支持最大的请求并发数"></a>浏览器中支持最大的请求并发数</h3><p>chrome中是6</p><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><ul><li>stopPropagation   </li><li>cancelBubble</li></ul><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><h3 id="chrome跨标签通信"><a href="#chrome跨标签通信" class="headerlink" title="chrome跨标签通信"></a>chrome跨标签通信</h3><ul><li>获取句柄 postMessage</li><li>localStorage</li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul><li>jsonp </li><li>CORS </li><li>WebSocket </li><li>Nginx代理 </li><li>Node中间件代理 <code>http-proxy-middleware</code> <code>proxy-middleware</code></li></ul><h3 id="输入网址回车之后浏览器做了什么"><a href="#输入网址回车之后浏览器做了什么" class="headerlink" title="输入网址回车之后浏览器做了什么"></a>输入网址回车之后浏览器做了什么</h3><h3 id="Chrome是多进程吗，为什么是多进程而不是多线程"><a href="#Chrome是多进程吗，为什么是多进程而不是多线程" class="headerlink" title="Chrome是多进程吗，为什么是多进程而不是多线程"></a>Chrome是多进程吗，为什么是多进程而不是多线程</h3><ul><li>浏览器是多进程的。一个tab页相当一个进行</li></ul><h3 id="Chrome-render进程包含哪些线程"><a href="#Chrome-render进程包含哪些线程" class="headerlink" title="Chrome render进程包含哪些线程"></a>Chrome render进程包含哪些线程</h3><h3 id="Chrome是如何实现setTimout的"><a href="#Chrome是如何实现setTimout的" class="headerlink" title="Chrome是如何实现setTimout的"></a>Chrome是如何实现setTimout的</h3><h3 id="如何监控前端性能"><a href="#如何监控前端性能" class="headerlink" title="如何监控前端性能"></a>如何监控前端性能</h3><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><ul><li>强制缓存</li><li>协商缓存</li><li>先判断是否命中强缓存，如果命中，则不请求服务器，直接从缓存中返回数据；</li><li>如果未命中，则向服务器发送一个请求，再判断是否命中协商缓存，如果命中，更新缓存，然后缓存中返回数据</li><li>如果均未命中，则向服务器发送请求，服务器返回数据。</li></ul><h3 id="浏览器进程相关"><a href="#浏览器进程相关" class="headerlink" title="浏览器进程相关"></a>浏览器进程相关</h3><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li><li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li><li>进程是一个工厂，拥有独立的资源（独立的一块内存），进程之间相互独立，工厂中有一个或者多个工人（一个进程由一个或者多个线程组成）。</li><li>线程是工厂中的工人，工人共享空间（同一进程下的各个线程之间共享程序的内存空间）</li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h3><ul><li>1**    信息类</li><li>2**    成功</li><li>3**    重定向类    301永久重定向 302临时重定向</li><li>4**    客户端出错</li><li>5**    服务器出错</li><li>302/304/401/403/405/500/502/503/504</li></ul><h3 id="Http常见请求方法以及简单描述"><a href="#Http常见请求方法以及简单描述" class="headerlink" title="Http常见请求方法以及简单描述"></a>Http常见请求方法以及简单描述</h3><p><code>get</code> <code>post</code> <code>head</code> <code>options</code> <code>delete</code> <code>put</code></p><h3 id="Http-header中都有哪些信息"><a href="#Http-header中都有哪些信息" class="headerlink" title="Http header中都有哪些信息"></a>Http header中都有哪些信息</h3><p><code>Accept</code>，<code>Connection</code>，<code>Content-Type</code>，<code>Expires</code>，<code>Server</code>，<code>Etag</code>，<code>Last-Modified</code>，<code>Server</code>，<code>Date</code>，<code>Cache-Control</code>，<code>User-Agent</code>等。</p><h3 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h3><p>Http主要有三点不足。</p><ul><li>通信使用明文，未加密。导致内容可能会被窃听。</li><li>不验证通讯方的身份。有可能遭遇伪装。</li><li>无法证明报文的完整性。有可能已遭篡改。</li></ul><p>Https的出现也是为了解决上述问题。因此：<br>Http+加密+认证+完整新保护 = Https。<br>Https是身披SSL外壳的Http。SSL协议在Http和Tcp协议之间。</p><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><h3 id="TCP三次握手-四次挥手区别"><a href="#TCP三次握手-四次挥手区别" class="headerlink" title="TCP三次握手/四次挥手区别"></a>TCP三次握手/四次挥手区别</h3><h3 id="为什么TCP建立连接是三次而关闭连接要多一次"><a href="#为什么TCP建立连接是三次而关闭连接要多一次" class="headerlink" title="为什么TCP建立连接是三次而关闭连接要多一次"></a>为什么TCP建立连接是三次而关闭连接要多一次</h3><h3 id="Https认证过程"><a href="#Https认证过程" class="headerlink" title="Https认证过程"></a>Https认证过程</h3><h3 id="HTTP2相比HTTP1多了什么"><a href="#HTTP2相比HTTP1多了什么" class="headerlink" title="HTTP2相比HTTP1多了什么"></a>HTTP2相比HTTP1多了什么</h3><h3 id="HTTP2的多路复用和HTTP-1-1的keep-alive有什么区别"><a href="#HTTP2的多路复用和HTTP-1-1的keep-alive有什么区别" class="headerlink" title="HTTP2的多路复用和HTTP 1.1的keep-alive有什么区别"></a>HTTP2的多路复用和HTTP 1.1的keep-alive有什么区别</h3><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li>expires    过期时间</li><li>domain    域名</li><li>path    路径</li><li>security    安全情况下才传输给服务器 https</li><li>httponly    js是否可以操作</li><li>如何防止js访问cookie，如何限制只能在https中才能访问cookie(set-cookie相关字段)</li></ul><h3 id="websocket是如何建立连接的"><a href="#websocket是如何建立连接的" class="headerlink" title="websocket是如何建立连接的"></a>websocket是如何建立连接的</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h3><h3 id="快排的时间复杂度和空间复杂度"><a href="#快排的时间复杂度和空间复杂度" class="headerlink" title="快排的时间复杂度和空间复杂度"></a>快排的时间复杂度和空间复杂度</h3><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;a.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;a.length-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">      [a[j],a[j+<span class="number">1</span>]] = [a[j+<span class="number">1</span>],a[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给个数组和n，找到数组里的三个数相加是n，复杂度要求O-n-2-logn"><a href="#给个数组和n，找到数组里的三个数相加是n，复杂度要求O-n-2-logn" class="headerlink" title="给个数组和n，找到数组里的三个数相加是n，复杂度要求O(n^2*logn)"></a>给个数组和n，找到数组里的三个数相加是n，复杂度要求O(n^2*logn)</h3><h3 id="对数组-2-3-3-2-5-进行多重相邻去重-第一次去重后结果-2-2-5-，然后得到-5-，复杂度要求O-n"><a href="#对数组-2-3-3-2-5-进行多重相邻去重-第一次去重后结果-2-2-5-，然后得到-5-，复杂度要求O-n" class="headerlink" title="对数组[2, 3, 3, 2, 5]进行多重相邻去重(第一次去重后结果[2, 2, 5]，然后得到[ 5 ])，复杂度要求O(n)"></a>对数组[2, 3, 3, 2, 5]进行多重相邻去重(第一次去重后结果[2, 2, 5]，然后得到[ 5 ])，复杂度要求O(n)</h3><h3 id="给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n"><a href="#给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n" class="headerlink" title="给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n"></a>给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n</h3><h3 id="给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层"><a href="#给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层" class="headerlink" title="给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层"></a>给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层</h3><h3 id="二叉树广度优先遍历"><a href="#二叉树广度优先遍历" class="headerlink" title="二叉树广度优先遍历"></a>二叉树广度优先遍历</h3><h3 id="给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止"><a href="#给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止" class="headerlink" title="给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止"></a>给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止</h3><h3 id="给一个二维数组，如-0-0-0-1-0-0-0-1-0-，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径"><a href="#给一个二维数组，如-0-0-0-1-0-0-0-1-0-，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径" class="headerlink" title="给一个二维数组，如[[0, 0, 0], [1, 0, 0], [0, 1, 0]]，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径"></a>给一个二维数组，如[[0, 0, 0], [1, 0, 0], [0, 1, 0]]，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径</h3><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="项目优化的点"><a href="#项目优化的点" class="headerlink" title="项目优化的点"></a>项目优化的点</h3><ul><li>html标签语义化</li><li>高效的css</li><li>图片压缩，尽可能不用图片</li><li>js等代码优化</li><li>减少http请求</li><li>打包后的代码压缩</li><li>PWA</li><li>webpack按需加载</li><li>cdn</li><li>骨架屏</li></ul><h3 id="项目中做过比较复杂的东西如何解决"><a href="#项目中做过比较复杂的东西如何解决" class="headerlink" title="项目中做过比较复杂的东西如何解决"></a>项目中做过比较复杂的东西如何解决</h3><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h3 id="鸡兔同笼-70脚-20头"><a href="#鸡兔同笼-70脚-20头" class="headerlink" title="鸡兔同笼 70脚 20头"></a>鸡兔同笼 70脚 20头</h3><ul><li>20只动物都收起两只脚，这个时候，就剩下了30只脚</li><li>30只脚全是兔子的，这个时候每只兔子只有2只脚，所以有15个兔子</li></ul><h3 id="两个村庄-A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了-这俩村庄的男女比例"><a href="#两个村庄-A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了-这俩村庄的男女比例" class="headerlink" title="两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例"></a>两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例</h3><h3 id="推荐几个链接"><a href="#推荐几个链接" class="headerlink" title="推荐几个链接"></a>推荐几个链接</h3><p><a href="https://juejin.im/post/5c9edb066fb9a05e267026dc" target="_blank" rel="noopener">【前端面试】同学，你会手写代码吗？</a><br><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6" target="_blank" rel="noopener">「中高级前端面试」JavaScript手写代码无敌秘籍</a><br><a href="https://juejin.im/post/5c71434a6fb9a049fa10633c" target="_blank" rel="noopener">前端笔试之手写代码(一)</a></p><p>小米 百度 猿辅导 瓜子 VIPKide 爱奇艺 阿里 滴滴 美团 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS部分&quot;&gt;&lt;a href=&quot;#CSS部分&quot; class=&quot;headerlink&quot; title=&quot;CSS部分&quot;&gt;&lt;/a&gt;CSS部分&lt;/h2&gt;&lt;h3 id=&quot;css三列布局，两边固定宽度，中间自适应&quot;&gt;&lt;a href=&quot;#css三列布局，两边固定宽度，中间自适应&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>diff算法</title>
    <link href="https://caychance.github.io/2019/04/03/diff%E7%AE%97%E6%B3%95/"/>
    <id>https://caychance.github.io/2019/04/03/diff算法/</id>
    <published>2019-04-02T19:08:09.000Z</published>
    <updated>2019-04-04T07:14:46.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><hr><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>因为如果在项目中大量的操作dom会很影响性能，所以Vue和React都尝试使用虚拟dom（virtual dom）。虚拟dom的本质其实就是用一个对象去描述整个dom结构，包括：当前dom的tag标签，data，children子节点，text文本，elm，key等等等，属性很多，就不一一列举了。</p><p>virtual dom真的比DOM操作效率高吗？不一定，那使用virtual dom的优势是什么呢？</p><p>使用虚拟dom的优势：</p><ol><li>不用手动频繁操作dom</li><li>框架跨平台</li><li>可以更好的实现SSR，同构渲染</li><li>组件的高度抽象化</li></ol><p>总之，<strong>大大的提高了我们的工作效率。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  tag: string | <span class="keyword">void</span>;</span><br><span class="line">  data: VNodeData | <span class="keyword">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: string | <span class="keyword">void</span>;</span><br><span class="line">  elm: Node | <span class="keyword">void</span>;</span><br><span class="line">  ns: string | <span class="keyword">void</span>;</span><br><span class="line">  context: Component | <span class="keyword">void</span>; <span class="comment">// rendered in this component's scope</span></span><br><span class="line">  key: string | number | <span class="keyword">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="keyword">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  raw: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  isStatic: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  isRootInsert: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  isComment: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  isCloned: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  isOnce: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="keyword">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  fnContext: Component | <span class="keyword">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  fnOptions: ?ComponentOptions; <span class="comment">// for SSR caching</span></span><br><span class="line">  devtoolsMeta: ?<span class="built_in">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  fnScopeId: ?string; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><ul><li>Vue的virtual dom的算法是基于Snabbdom库。</li><li>VNode只会同层级比较，不会跨层级比较，因此复杂度为O(n)。</li><li>重点是<code>patch</code>方法。</li></ul><h3 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h3><p>注释：vnode：新的虚拟节点 oldVnode：旧的虚拟节点</p><ol><li>vnode不存在但是oldVnode存在，需要销毁oldVnode</li><li>oldVnode不存在但是vnode存在，创建新节点</li><li>oldVnode和vnode都存在<br>3.1 oldVnode和vnode是同一个节点 执行<code>patchVnode</code>方法<br>3.2 vnode创建真实dom并替换oldVnode.elm</li></ol><h3 id="patchVnode方法"><a href="#patchVnode方法" class="headerlink" title="patchVnode方法"></a>patchVnode方法</h3><ol><li>oldVnode和vnode完全一致，则不需要做任何事情</li><li>vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</li><li>oldVnode和vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上即可</li><li>vnode不是文本节点或注释节点<br>4.1 如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行<code>updateChildren</code>方法<br>4.2 只有oldVnode有子节点，那就把这些节点都删除<br>4.3 如果只有vnode有子节点，那就创建这些子节点<br>4.4 如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串</li></ol><h3 id="updateChildren方法"><a href="#updateChildren方法" class="headerlink" title="updateChildren方法"></a>updateChildren方法</h3><ol><li>oldStartIdx&gt;oldEndIdx<br>oldCh已经遍历完了，但是newCh还没有，把newStartIdx-newEndIdx之间的vnode都是新增的，把这些vnode添加到oldCh末尾</li><li>newStartIdx&gt;newEndIdx<br>newCh已经遍历完了，但是oldCh还没有，把oldCh中oldStartIdx-oldEndIdx之间的vnode删除</li><li>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx<br>一直循环判断<br>3.1 oldVnode第一个child不存在，oldStart索引右移<br>3.2 oldVnode最后一个child不存在，oldEnd索引左移<br>3.3 oldStartVnode和newStartVnode是同一个节点，<code>patchVnode</code>两个节点，索引右移<br>3.4 oldEndVnode和newEndVnode是同一个节点，<code>patchVnode</code>两个节点，索引左移<br>3.5 oldStartVnode和newEndVnode是同一个节点，移动oldStartVnode到oldEndVnode节点后面<br>3.6 oldEndVnode和newStartVnode是同一个节点，移动oldEndVnode到oldStartVnode前面<br>3.7 oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点<br>3.8 如果找到了相同key的节点，比较两个节点是否属于同一个节点，如果属于同一节点，就<code>patchVnode</code>，否则新创建节点</li></ol><h3 id="什么要设置key"><a href="#什么要设置key" class="headerlink" title="什么要设置key"></a>什么要设置key</h3><p>如果不设置key的话，newCh和oldCh只会头尾两端比较，并且交叉比较。<br>如果设置key的话，除了上述的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>virtual dom是vue 2.0以后增加的，那么2.0之前vue这一块是怎么处理的呢？</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.zhihu.com/question/271485214" target="_blank" rel="noopener">Vue采用虚拟DOM的目的是什么?</a><br><a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js" target="_blank" rel="noopener">Vue中virtual dom算法源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;diff-算法&quot;&gt;&lt;a href=&quot;#diff-算法&quot; class=&quot;headerlink&quot; title=&quot;diff 算法&quot;&gt;&lt;/a&gt;diff 算法&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;Virtual-DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM&quot; clas
      
    
    </summary>
    
    
      <category term="diff算法" scheme="https://caychance.github.io/tags/diff%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vuex笔记</title>
    <link href="https://caychance.github.io/2019/03/29/Vuex%E7%AC%94%E8%AE%B0/"/>
    <id>https://caychance.github.io/2019/03/29/Vuex笔记/</id>
    <published>2019-03-28T16:21:30.000Z</published>
    <updated>2019-03-28T11:10:45.859Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex学习笔记</p><hr><h3 id="Vuex概述"><a href="#Vuex概述" class="headerlink" title="Vuex概述"></a>Vuex概述</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理</strong>模式。</p><p>简单来说，就是存储页面中的各种数据。</p><h3 id="为什么要用Vuex"><a href="#为什么要用Vuex" class="headerlink" title="为什么要用Vuex"></a>为什么要用Vuex</h3><p>Vuex的使用并不是必要的。</p><p>Vue.js中，数据之间都是在组件之间进行传递的，但是当你的应用变的很大或者很复杂的时候，会有两个问题。</p><p>1、当组件嵌套很深的时候，数据的传递，修改，其实都不太方便，很容易导致出错。</p><p>2、这些状态可能会在任何组件中被修改，不方便统一管理。尤其是多人合作开发的时候。</p><p>Vuex也是为了解决这两个问题而生的。</p><p>当然，有人可能会想到使用一个全局对象，再去上层封装了一些数据存取的接口来解决。Vuex和单纯的全局对象有以下两点不同：</p><ul><li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p></li><li><p>不能直接改变store中的状态。改变store中的状态的唯一途径就是显式地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p></li></ul><h3 id="Vuex详细介绍"><a href="#Vuex详细介绍" class="headerlink" title="Vuex详细介绍"></a>Vuex详细介绍</h3><p>Vuex中有五个核心的概念：</p><ul><li>State<blockquote><p>用于存储数据</p></blockquote></li><li><p>Getter</p><blockquote><p>可理解为store的（computed）计算属性</p></blockquote><blockquote><p>Getter可接受state和getter两个参数。</p></blockquote></li><li><p>Mutation</p><blockquote><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p></blockquote><blockquote><p>mutation 都是同步事务</p></blockquote></li><li><p>Action</p><blockquote><p>Action类似mutation。</p></blockquote><blockquote><p>区别有两点：1.Action可以包含异步操作；2.Action 提交的是 mutation，而不是直接变更状态。</p></blockquote></li><li>Module<blockquote><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。Vuex 允许我们将 store 分割成模块（module,每个模块拥有自己的state、mutation、action、getter以及嵌套子模块。</p></blockquote></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>每一个 Vuex 应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态(state)。</li><li>想修改state只能提交（commit）mutation。</li><li>mutation中只能进行同步操作。</li><li>异步操作可以分发（dispatch）action，当然，action的实质还是提交（commit）mutation。</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1io1c6idkj30jh0fbwef.jpg" alt></p><p>Vuex的数据流向：<br>State 渲染到Vue Components,分发(Dispatch) Actions,提交(Commit) Mutations，修改(Mutate) State。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vuex学习笔记&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Vuex概述&quot;&gt;&lt;a href=&quot;#Vuex概述&quot; class=&quot;headerlink&quot; title=&quot;Vuex概述&quot;&gt;&lt;/a&gt;Vuex概述&lt;/h3&gt;&lt;p&gt;Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="Vuex" scheme="https://caychance.github.io/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue原理解析笔记</title>
    <link href="https://caychance.github.io/2019/03/28/Vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
    <id>https://caychance.github.io/2019/03/28/Vue原理解析笔记/</id>
    <published>2019-03-27T19:09:06.000Z</published>
    <updated>2019-04-23T09:24:35.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue原理学习笔记"><a href="#Vue原理学习笔记" class="headerlink" title="Vue原理学习笔记"></a>Vue原理学习笔记</h2><hr><h2 id="Vue-js-运行机制"><a href="#Vue-js-运行机制" class="headerlink" title="Vue.js 运行机制"></a>Vue.js 运行机制</h2><h3 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue()"></a>new Vue()</h3><h3 id="init初始化"><a href="#init初始化" class="headerlink" title="_init初始化"></a>_init初始化</h3><pre><code>&gt; 合并配置、初始化生命周期、事件中心、渲染、data、 props、 methods、 computed 与 watcher 等* 通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」* 如果有el属性，就调用vm.$mount方法挂载vm</code></pre><h3 id="mount-挂载组件"><a href="#mount-挂载组件" class="headerlink" title="$mount 挂载组件"></a>$mount 挂载组件</h3><pre><code>- 挂载的目标就是把模板渲染成最终的 DOM* 限制el，Vue不能挂载在body或者html这样的根节点上。* 如果没有render方法，会把el或template转换成render方法。* 核心方法 **vm._render**和**vm._update**</code></pre><ul><li><p>compile 编译  </p><blockquote><p>把模板解析为ast语法数</p></blockquote><ul><li>parse</li><li>optimize</li><li>generate</li></ul></li><li><p>render 渲染函数</p><blockquote><p>把实例渲染成一个虚拟DOM 映射到真实的dom，需要经历VNode的create,diff,patch等过程。</p></blockquote></li><li><p>update 方法</p><blockquote><p>把VNode渲染成真实的DOM</p></blockquote><ul><li>被调用的时机有两个。1首次渲染；2数据更新的时候</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue原理学习笔记&quot;&gt;&lt;a href=&quot;#Vue原理学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Vue原理学习笔记&quot;&gt;&lt;/a&gt;Vue原理学习笔记&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;Vue-js-运行机制&quot;&gt;&lt;a href=&quot;#Vue-js-运行
      
    
    </summary>
    
      <category term="Vue" scheme="https://caychance.github.io/categories/Vue/"/>
    
    
      <category term="Vue原理" scheme="https://caychance.github.io/tags/Vue%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>为什么要用框架</title>
    <link href="https://caychance.github.io/2019/03/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    <id>https://caychance.github.io/2019/03/23/为什么要用框架/</id>
    <published>2019-03-22T23:14:00.000Z</published>
    <updated>2019-03-26T02:56:57.535Z</updated>
    
    <content type="html"><![CDATA[<hr><p>一直在用Vue，但是也没有想过框架的出现是为了解决什么痛点？</p><h4 id="实现一个点赞功能"><a href="#实现一个点赞功能" class="headerlink" title="实现一个点赞功能"></a>实现一个点赞功能</h4><p>首先，实现一个简单的点赞功能，不考虑使用任何框架。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">'like-btn'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'like-text'</span>&gt;</span>点赞<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 实现一个简单的点赞按钮，点击按钮的同时按钮的文字会变换。demo1难以复用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'.like-btn'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> buttonText = button.querySelector(<span class="string">'.like-text'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> isLiked = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">    button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="undefined">      isLiked = !isLiked</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (isLiked) &#123;</span></span><br><span class="line"><span class="javascript">        buttonText.innerHTML = <span class="string">'取消'</span></span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        buttonText.innerHTML = <span class="string">'点赞'</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码实现了点赞的功能，但是有一个问题——难以复用。</p><h4 id="结构复用"><a href="#结构复用" class="headerlink" title="结构复用"></a>结构复用</h4><p>经过改造，我们也仅仅只能复用html部分，并且没有添加事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 仅仅可以复用html部分，没有添加事件</span></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">      render()&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'like-btn'</span>&gt;</span></span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;赞&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton1 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.innerHTML = likeButton1.render()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton2 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.innerHTML += likeButton2.render()</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h4><p>虽然添加了click事件，但是只能输出固定的click。我们需要点击按钮，改变文字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加了click事件，但是只能打印固定的click</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">      render()&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-button'</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;点赞&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'click'</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton1 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.appendChild(likeButton1.render())</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton2 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.appendChild(likeButton2.render())</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改文字"><a href="#修改文字" class="headerlink" title="修改文字"></a>修改文字</h4><p>点击按钮，会修改文字，但是changeLikeText方法频繁的操作dom，影响性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击按钮会执行changeLikeText方法，但是changeLikeText方法里面在不停的操作dom，影响性能</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123; <span class="attr">isLiked</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      changeLikeText () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> likeText = <span class="keyword">this</span>.el.querySelector(<span class="string">'.like-text'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state.isLiked = !<span class="keyword">this</span>.state.isLiked</span></span><br><span class="line"><span class="javascript">        likeText.innerHTML = <span class="keyword">this</span>.state.isLiked ? <span class="string">'取消'</span> : <span class="string">'点赞'</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render()&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-button'</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;点赞&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeLikeText.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton1 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.appendChild(likeButton1.render())</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton2 = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="undefined">    wrapper.appendChild(likeButton2.render())</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>到这一步骤，基本已经大体形成，我们可以做更进一步的优化。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击按钮执行changeLikeText方法，该方法值会调用setState方法，setState方法会重新给satate赋值，并且修改虚拟html。最终只会操作一次dom</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123; <span class="attr">isLiked</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      setState (state) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> oldEl = <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = state</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = <span class="keyword">this</span>.render()</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onStateChange) <span class="keyword">this</span>.onStateChange(oldEl, <span class="keyword">this</span>.el)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      changeLikeText () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">          isLiked: !<span class="keyword">this</span>.state.isLiked</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-btn'</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;$&#123;<span class="keyword">this</span>.state.isLiked ? <span class="string">'取消'</span> : <span class="string">'点赞'</span>&#125;&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeLikeText.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> likeButton = <span class="keyword">new</span> LikeButton()</span></span><br><span class="line"><span class="javascript">    wrapper.appendChild(likeButton.render()) <span class="comment">// 第一次插入 DOM 元素</span></span></span><br><span class="line"><span class="javascript">    likeButton.onStateChange = <span class="function">(<span class="params">oldEl, newEl</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      wrapper.insertBefore(newEl, oldEl) <span class="comment">// 插入新的元素</span></span></span><br><span class="line"><span class="javascript">      wrapper.removeChild(oldEl) <span class="comment">// 删除旧的元素</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h4><p>setState和_renderDOM封装成Component类，便于其他组件使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把setState和_renderDOM方法进行抽离，修改dom的操作封装成方法</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> mount = <span class="function">(<span class="params">component, wrapper</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">      wrapper.appendChild(component._renderDOM())</span></span><br><span class="line"><span class="javascript">      component.onStateChange = <span class="function">(<span class="params">oldEl, newEl</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">        wrapper.insertBefore(newEl, oldEl)</span></span><br><span class="line"><span class="undefined">        wrapper.removeChild(oldEl)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">      setState (state) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> oldEl = <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = state</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>._renderDOM()</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onStateChange) <span class="keyword">this</span>.onStateChange(oldEl, <span class="keyword">this</span>.el)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      _renderDOM () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="keyword">this</span>.render())</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onClick) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">super</span>()</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123; <span class="attr">isLiked</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      onClick () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">          isLiked: !<span class="keyword">this</span>.state.isLiked</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-btn'</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;$&#123;<span class="keyword">this</span>.state.isLiked ? <span class="string">'取消'</span> : <span class="string">'点赞'</span>&#125;&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    mount(<span class="keyword">new</span> LikeButton(), wrapper)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h4><p>组件可通过props传参来自定义配置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 组件可以自定义配置 通过props</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ::String =&gt; ::Document</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> createDOMFromString = <span class="function">(<span class="params">domString</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">      div.innerHTML = domString</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> mount = <span class="function">(<span class="params">component, wrapper</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">      wrapper.appendChild(component._renderDOM())</span></span><br><span class="line"><span class="javascript">      component.onStateChange = <span class="function">(<span class="params">oldEl, newEl</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">        wrapper.insertBefore(newEl, oldEl)</span></span><br><span class="line"><span class="undefined">        wrapper.removeChild(oldEl)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> (props = &#123;&#125;) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.props = props</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      setState (state) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> oldEl = <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = state</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>._renderDOM()</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onStateChange) <span class="keyword">this</span>.onStateChange(oldEl, <span class="keyword">this</span>.el)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      _renderDOM () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.el = createDOMFromString(<span class="keyword">this</span>.render())</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.onClick) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.el.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.el</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> (props) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">super</span>(props)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123; <span class="attr">isLiked</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      onClick () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">          isLiked: !<span class="keyword">this</span>.state.isLiked</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`</span></span></span><br><span class="line"><span class="javascript">          &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-btn'</span> style=<span class="string">"background-color: $&#123;this.props.bgColor&#125;"</span>&gt;</span></span><br><span class="line"><span class="javascript">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">'like-text'</span>&gt;</span></span><br><span class="line"><span class="javascript">              $&#123;<span class="keyword">this</span>.state.isLiked ? <span class="string">'取消'</span> : <span class="string">'点赞'</span>&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>👍<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">RedBlueButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span> (props) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">super</span>(props)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.state = &#123;</span></span><br><span class="line"><span class="javascript">          color: <span class="string">'red'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      onClick () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">          color: <span class="string">'blue'</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      render () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'color: $&#123;this.state.color&#125;;'</span>&gt;</span>$&#123;this.state.color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        `</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    mount(<span class="keyword">new</span> LikeButton(&#123; <span class="attr">bgColor</span>: <span class="string">'red'</span> &#125;), wrapper)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样子循序渐进的看下来，就能体会到一个框架的诞生的个中缘由——并不是平白无故做出来的，而是为了解决一些问题，然后一点一点的优化，最终诞生的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;一直在用Vue，但是也没有想过框架的出现是为了解决什么痛点？&lt;/p&gt;
&lt;h4 id=&quot;实现一个点赞功能&quot;&gt;&lt;a href=&quot;#实现一个点赞功能&quot; class=&quot;headerlink&quot; title=&quot;实现一个点赞功能&quot;&gt;&lt;/a&gt;实现一个点赞功能&lt;/h4&gt;&lt;p&gt;首先，
      
    
    </summary>
    
      <category term="框架" scheme="https://caychance.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="https://caychance.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JSX in Vue</title>
    <link href="https://caychance.github.io/2019/03/09/JSX-in-Vue/"/>
    <id>https://caychance.github.io/2019/03/09/JSX-in-Vue/</id>
    <published>2019-03-08T23:53:26.000Z</published>
    <updated>2019-03-31T14:50:04.387Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="使用Vue的template遇到的问题"><a href="#使用Vue的template遇到的问题" class="headerlink" title="使用Vue的template遇到的问题"></a>使用Vue的template遇到的问题</h4><p>前几天接了一个需求-APP首页配置化。大体思路就是，后台做一个页面，这个页面上提供了N个模板，然后运营人员可以动态的添加模板，并且给每个模板进行不同的配置。比如，轮播图模板，轮播图模板可以配置一个标题，以及描述，模板可以配置多张图片，图片可以调整顺序，点击图片跳转的链接等。</p><p>我们第一期提供了10个模板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='SCOELL_IMG_01'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-scroll-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-scroll-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='TWO_IMG_01'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-two-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-two-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='TWO_IMG_02'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-two-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-two-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='THREE_IMG_01'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-three-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-three-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"templateCode==='THREE_IMG_02'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c-three-img</span>&gt;</span><span class="tag">&lt;/<span class="name">c-three-img</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我举例说明，先写5个说明一下问题。有一个比较严重的问题，就是<code>v-if</code>用的太多了。这里面不能嵌入js，如果以后提供20个模板甚至更多呢？template这种方式肯定会写的很痛苦！</p><h4 id="可以尝试使用JSX解决"><a href="#可以尝试使用JSX解决" class="headerlink" title="可以尝试使用JSX解决"></a>可以尝试使用JSX解决</h4><p>所以，我们可以试试用另一种方式去写组件-JSX，在Vue中使用JSX。JSX是React的核心组成部分。Vue2.0以后才开始支持JSX的。</p><h4 id="JSX介绍"><a href="#JSX介绍" class="headerlink" title="JSX介绍"></a>JSX介绍</h4><p>JSX其实就是使用JavaScript去表示dom元素结构。</p><p><strong>所谓的 JSX 其实就是 JavaScript 对象。</strong></p><ol><li>JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML。</li><li>React.js 可以用 JSX 来描述你的组件长什么样的。</li><li>JSX 在编译的时候会变成相应的 JavaScript 对象描述。</li><li>react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上。</li></ol><p>从 JSX 到页面到底经过了什么样的过程</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g11dfngojkj30hm075aaq.jpg" alt></p><h5 id="JSX基本语法"><a href="#JSX基本语法" class="headerlink" title="JSX基本语法"></a>JSX基本语法</h5><p>在Vue中使用JSX首先需要保证Vue的版本大于2.0，然后官方的<a href="https://github.com/vuejs/jsx" target="_blank" rel="noopener">jsx</a>包,这个包支持的是Babel 7+；<br>如果是Babel 6，则需要安装<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx" target="_blank" rel="noopener">babel-plugin-transform-vue-jsx</a>包。</p><p>然后根据文档安装完以后。</p><h4 id="JSX-VS-Template"><a href="#JSX-VS-Template" class="headerlink" title="JSX VS Template"></a>JSX VS Template</h4><ol><li>JSX其实就是JavaScript对象，Template是Vue组件中render方法的输入。</li><li>JSX特别利于理解，相比较Template而言。（虽然写惯了Template，JSX的语法还需要慢慢适应。）</li><li>Tempplate对初学者比较友好。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h4 id=&quot;使用Vue的template遇到的问题&quot;&gt;&lt;a href=&quot;#使用Vue的template遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;使用Vue的template遇到的问题&quot;&gt;&lt;/a&gt;使用Vue的template遇到的问题&lt;/h4&gt;
      
    
    </summary>
    
      <category term="JSX" scheme="https://caychance.github.io/categories/JSX/"/>
    
    
      <category term="JSX" scheme="https://caychance.github.io/tags/JSX/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记</title>
    <link href="https://caychance.github.io/2019/03/07/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caychance.github.io/2019/03/07/docker学习笔记/</id>
    <published>2019-03-06T19:26:50.000Z</published>
    <updated>2019-03-12T05:56:14.728Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="引子-环境配置的难题"><a href="#引子-环境配置的难题" class="headerlink" title="引子-环境配置的难题"></a>引子-环境配置的难题</h4><p>软件开发最大的麻烦事之一就是环境配置。解决的思路就是软件带环境安装，即安装的时候，把原始环境一模一样的复制过来。</p><h4 id="初始的尝试解决方案-虚拟机"><a href="#初始的尝试解决方案-虚拟机" class="headerlink" title="初始的尝试解决方案-虚拟机"></a>初始的尝试解决方案-虚拟机</h4><p>虚拟机就是带环境安装的一种解决方案。</p><p>缺点:</p><ol><li><p>资源占用多<br>虚拟机会独占一部分内存和硬盘空间。</p></li><li><p>冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，无法跳过。</p></li><li><p>启动慢<br>启动虚拟机的时间和启动操作系统的时间一样长。</p></li></ol><h4 id="另一种解决方案-Linux容器"><a href="#另一种解决方案-Linux容器" class="headerlink" title="另一种解决方案-Linux容器"></a>另一种解决方案-Linux容器</h4><p>由于以上缺点，Linux有另一种虚拟化技术:Linux容器。</p><p><strong>Linux容器不是模拟一个完整的操作系统，而且对进程进行隔离。</strong><br>或者说在正常的进程外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的。</p><p>由于容器是进程级别的，相比虚拟机有以下优势:</p><ol><li><p>启动快<br>启动进程肯定比启动操作系统快太多了。</p></li><li><p>资源占用少<br>容器只占用需要的资源。另外，多个容器可以共享资源。</p></li><li><p>体积小<br>容器只要包含用到的组件即可。</p></li></ol><p>结论:容器有点类似轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h4 id="噔噔噔～主角登场-Docker是个啥"><a href="#噔噔噔～主角登场-Docker是个啥" class="headerlink" title="噔噔噔～主角登场-Docker是个啥"></a>噔噔噔～主角登场-Docker是个啥</h4><p><strong>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。</strong></p><p>Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。(有了 Docker，妈妈再也不用担心环境问题。)</p><p>此外，容器还可以进行版本管理、复制、分享、修改，类似代码的管理。</p><h4 id="Docker的用途"><a href="#Docker的用途" class="headerlink" title="Docker的用途"></a>Docker的用途</h4><p>Docker 的主要用途，目前有三大类。</p><ol><li><p>提供一次性的环境。<br>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p></li><li><p>提供弹性的云服务。<br>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p></li><li><p>组建微服务架构。<br>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p></li></ol><h4 id="咦？Docker中的image是个啥"><a href="#咦？Docker中的image是个啥" class="headerlink" title="咦？Docker中的image是个啥"></a>咦？Docker中的image是个啥</h4><p><strong>Docker把应用程序及其依赖，打包在image文件里面。</strong></p><p>我们通过image文件，可以生成Docker容器。</p><p>image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</p><p>image是二进制文件。image文件可以继承别的image文件，一般来讲，尽量使用别人制作好的docker，或者基于别人的image文件进行加工。</p><h4 id="容器文件又是个啥？"><a href="#容器文件又是个啥？" class="headerlink" title="容器文件又是个啥？"></a>容器文件又是个啥？</h4><p>image文件能够生成的容器实例，这个容器实例本身也是一个文件，称为容器文件。</p><p>所以说，一旦容器生成，会同时有两个文件:image文件和容器文件。</p><p>关闭容器，并不会删除容器文件，只是容器停止运行而已。</p><h4 id="我也想做一个Docker容器，肿么办？"><a href="#我也想做一个Docker容器，肿么办？" class="headerlink" title="我也想做一个Docker容器，肿么办？"></a>我也想做一个Docker容器，肿么办？</h4><ol><li><p>编写Dockerfile<br>在项目的根目录下，新建一个文本文件.dockerignore和Dockerfile。前者是docker打包要忽略的路径;后者是docker打包的代码</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span> . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></li><li><p>创建image文件<br>在dockerfile文件的基础上使用docker image build 命令创建image文件。</p></li><li><p>生成容器<br>docker container run 命令会从image文件生成容器。</p></li></ol><h4 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h4><h5 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker version //docker客户端和服务端的版本号</span><br><span class="line">docker info //docker更加详尽的信息</span><br></pre></td></tr></table></figure><h5 id="image相关"><a href="#image相关" class="headerlink" title="image相关"></a>image相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker image ls //列出所有的docker image</span><br><span class="line">docker image rm [imageId] //删除指定image</span><br><span class="line">docker image build -t koa-demo . //创建 image 文件</span><br><span class="line">docker image prune //清除所有image</span><br></pre></td></tr></table></figure><h5 id="运行一个image并启动容器"><a href="#运行一个image并启动容器" class="headerlink" title="运行一个image并启动容器"></a>运行一个image并启动容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world //将image文件从仓库抓取到本地</span><br><span class="line">docker container run hello-world //运行image文件生成容器，每运行一次，就会新建一个容器。</span><br><span class="line">docker container start [containerID] //重复使用容器</span><br><span class="line">docker container kill [containID] //终止指定容器运行  相当于向容器里面的主进程发出 SIGKILL 信号</span><br><span class="line">docker container stop [containID] //终止指定容器运行  相当于向容器里面的主进程发出 SIGTERM 信号</span><br><span class="line">这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</span><br></pre></td></tr></table></figure><h5 id="container相关"><a href="#container相关" class="headerlink" title="container相关"></a>container相关</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container ls //列出正在运行的容器</span><br><span class="line">docker container ls -a //列出所有的容器，包括终止运行的容器</span><br><span class="line">docker container kill [containID] //终止指定容器运行</span><br><span class="line">docker container rm [containerID] //删除指定容器文件</span><br><span class="line">docker container prune //清除所有container</span><br><span class="line">docker system prune //清除所有</span><br></pre></td></tr></table></figure><h5 id="发布image"><a href="#发布image" class="headerlink" title="发布image"></a>发布image</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker login //登录</span><br><span class="line">docker image tag [imageName] [username]/[repository]:[tag] // 为本地的 image 标注用户名和版本。docker image tag koa-demos:0.0.1 cc/koa-demos:0.0.1</span><br><span class="line">docker image build -t [username]/[repository]:[tag] . //重新构建image文件</span><br><span class="line">docker image push [username]/[repository]:[tag] //发布image文件</span><br></pre></td></tr></table></figure><p>以上都是简单介绍。</p><p>详细请移步<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮老师的教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h4 id=&quot;引子-环境配置的难题&quot;&gt;&lt;a href=&quot;#引子-环境配置的难题&quot; class=&quot;headerlink&quot; title=&quot;引子-环境配置的难题&quot;&gt;&lt;/a&gt;引子-环境配置的难题&lt;/h4&gt;&lt;p&gt;软件开发最大的麻烦事之一就是环境配置。解决的思路就是软件带环境安装
      
    
    </summary>
    
      <category term="工具" scheme="https://caychance.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="https://caychance.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="https://caychance.github.io/2019/02/27/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://caychance.github.io/2019/02/27/原型与原型链/</id>
    <published>2019-02-26T17:10:20.000Z</published>
    <updated>2019-04-25T07:39:10.141Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每个函数都有一个特殊的属性叫作原型（<code>prototype</code>）<br>每个实例对象（<code>object</code>）都有一个私有属性（称之为<code>__proto__</code>）指向它的原型对象（<code>prototype</code>）<br>该原型对象也有一个自己的原型对象(<code>__proto__</code>) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p><p>构造函数，原型和实例三者之间的关系</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0jzrv2ditj30zk0puq4y.jpg" style="    width: 400px;    height: 300px;"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Father();</span><br><span class="line">Father.prototype === f.__proto__ <span class="comment">//true</span></span><br><span class="line">Father.prototype.constructor === Father <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0l17qcp6vj30zk0pugn7.jpg" style="    height: 500px;"></p><p>1、原型链的最顶端是<code>null</code><br>2、所有的原型的<code>_proto_</code>都是Object的原型<br>3、所有的构造函数的<code>_proto_</code>都是Function的原型<br>4、Function的<code>_proto_</code>和<code>prototype</code>都是Function的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ <span class="comment">//null 1</span></span><br><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__ <span class="comment">//true 4</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Father.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true 3</span></span><br><span class="line">Father.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true 2</span></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true 3</span></span><br><span class="line"><span class="built_in">String</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true 2</span></span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>理解，每个函数（构造函数，或者普通函数）都有一个属性叫做原型（prototype）,<br>每个实例对象都有一个私有属性（<code>__proto__</code>），每个实例对象之间的<code>__proto__</code>指向就是原型链。</p><p>最后贴一张更全的图</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0l0c6dx6cj30u011c7ci.jpg" style="    height: 600px;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h3&gt;&lt;p&gt;每个函数都有一个特殊的属性叫作原型（&lt;code&gt;prototype&lt;/code&gt;）&lt;br&gt;每个实例对象（&lt;code&gt;object&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="https://caychance.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基础入门</title>
    <link href="https://caychance.github.io/2019/02/01/MongoDB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://caychance.github.io/2019/02/01/MongoDB基础入门/</id>
    <published>2019-02-01T10:23:29.000Z</published>
    <updated>2019-02-14T06:17:49.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB基础入门（基础篇）"><a href="#MongoDB基础入门（基础篇）" class="headerlink" title="MongoDB基础入门（基础篇）"></a>MongoDB基础入门（基础篇）</h2><p>最新心血来潮，准备在网上学习一下Vue+Node+MongoDB。之前接触过MySQL，但是MongoDB跟MySQL还是有区别的。话不多说：</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>一个mongodb中可以建立多个数据库。</p><p>每个数据库里面有多个表（也叫做集合）。</p><p>表里面存储的数据格式就是一个json，这也是区别于SQL的地方。</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>这一步就省略了，自己Google去吧。我在mac下用的homebrew</p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>在命令行中输入mongo就会连接到数据库</p><h4 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h4><p><code>show dbs</code>           查看所有数据库<br><code>use DATABASE_NAME</code>  创建数据库或者切换到该数据库<br><code>db.dropDatabase()</code>  删除数据库</p><h4 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h4><p><code>show tables</code>                           查看已有表<br><code>show collections</code>                      查看已有集合<br><code>db.createCollection(name, options)</code>    创建集合<br><code>db.COLLECTION_NAME.drop()</code>             删除集合</p><p><strong>PS：show tables 和 show collections 的区别，网上还么有搜到，但是实际操作了一下，发现两者是一样的。</strong></p><p>直接在COLLECTION_NAME集合中插入数据的时候，会自动创建COLLECTION_NAME集合<br><code>db.COLLECTION_NAME.insert({&quot;name&quot; : &quot;Chance&quot;})</code></p><p><strong>情况1：如果没有新建一个数据库的话，会默认在test数据库中新建一个COLLECTION_NAME集合（表）</strong><br><strong>情况2：在该命令之前新建了一个数据库的话，会在该数据库下新建一个COLLECTION_NAME集合（表）</strong></p><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>增删改查的操作是基于集合来的，所有统一的格式都是db.COLLECTION_NAME.***</p><p>增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(document)</span><br></pre></td></tr></table></figure><p>删<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(query, projection)</span><br></pre></td></tr></table></figure></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>解释/说明</th></tr></thead><tbody><tr><td>show dbs</td><td>查看所有数据库</td></tr><tr><td>db</td><td>显示当前数据库对象或集合</td></tr><tr><td>use DATABASE_NAME</td><td>如果数据库不存在，则创建数据库，否则切换到指定数据库。</td></tr><tr><td>show tables</td><td>查看该数据库下的所有表</td></tr><tr><td>show collections</td><td>查看该数据库下的所有集合</td></tr><tr><td>db.dropDatabase()</td><td>删除数据库</td></tr><tr><td>db.COLLECTION_NAME.insert({“name”:”Chance”})</td><td>创建集合并向其中插入一些数据</td></tr><tr><td>db.createCollection(name, options)</td><td>创建集合</td></tr><tr><td>db.COLLECTION_NAME.drop()</td><td>删除当前集合</td></tr><tr><td>db.COLLECTION_NAME.insert(document)</td><td>增</td></tr><tr><td>db.COLLECTION_NAME.remove()</td><td>删</td></tr><tr><td>db.COLLECTION_NAME.update()</td><td>改</td></tr><tr><td>db.COLLECTION_NAME.insert(document)</td><td>查</td></tr></tbody></table><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>正常情况下，node中不会直接使用mongo的语法，会使用mongoose<br><a href="https://mongoosejs.com/" target="_blank" rel="noopener">mongoose官网</a><br><a href="https://www.bilibili.com/video/av41033371" target="_blank" rel="noopener">mongoose教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MongoDB基础入门（基础篇）&quot;&gt;&lt;a href=&quot;#MongoDB基础入门（基础篇）&quot; class=&quot;headerlink&quot; title=&quot;MongoDB基础入门（基础篇）&quot;&gt;&lt;/a&gt;MongoDB基础入门（基础篇）&lt;/h2&gt;&lt;p&gt;最新心血来潮，准备在网上学习
      
    
    </summary>
    
      <category term="工具" scheme="https://caychance.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MongoDB" scheme="https://caychance.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目的整体认识</title>
    <link href="https://caychance.github.io/2019/01/26/Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86/"/>
    <id>https://caychance.github.io/2019/01/26/Vue项目的整体认识/</id>
    <published>2019-01-25T21:08:20.000Z</published>
    <updated>2019-02-16T15:55:27.103Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Vue项目的一些整体认识"><a href="#Vue项目的一些整体认识" class="headerlink" title="Vue项目的一些整体认识"></a>Vue项目的一些整体认识</h4><hr><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>其实从16年11月28日进公司实习至今，已经两年多了。刚去公司的时候，我们当时前端就3个人，那会也是第一次接触Vue的。刚接触的感觉，就是，这玩意，这么神奇。然后平时做需求也是，能把需求做了就行。至今还记得第一次前后端联调，第一次项目上线。</p><p>虽然很早就接触了，但是我们项目的很多东西，我都没有认真的静下来去看。导致很多东西都是一知半解的。直到自己有一天幡然醒悟。</p><p>我们的项目是我们前端小组长搭建的一个脚手架,包括vue cli+webpack配置+node(express)。使用 node 代替 NGINX 提供请求代理、WebViewJavaScriptbridge 与客户端交互、Vue 全家桶作为开发框架，并且用 express 搭建了 mock 框架。</p><h4 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h4><p>首先，Vue没有什么神奇的，最后上线的东西就是一个dist文件，里面一个入口文件index.html+一个static文件，static文件里面是打包后的图片，css和js。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzj6d8fhqvj30hk0k40ue.jpg" alt></p><p>以本地开发为例，<code>npm run dev</code> 以后，正常情况下会启动一个本地服务，然后当用户访问<code>localhost:8080/login</code>，本地服务器会返回打包后的<code>index.html</code>文件，index文件里面引入了main.js即js代码的主入口文件。</p><p>这部分是Vue项目中的node服务器处理的，这也是node服务器的第一个作用，方便本地调试。服务器会把收到的请求转到index.html。具体可参考作用1。</p><p>main.js文件里面其实会实例化一个Vue对象，并挂载在某个dom元素下。实例化的Vue对象里面有Vue Router和Vuex。Vuex按需要来决定要不要引用。Vue Router会在你访问某个路径的时候，比对当前的location.pathname和Vue Router中的某一个path是否可以匹配上，能够匹配上的话，会渲染对应的组件页面。</p><p>以上就是对Vue整个项目的一个认识。Vue项目中用到了node，说一下node的作用吧。</p><h5 id="作用1"><a href="#作用1" class="headerlink" title="作用1"></a>作用1</h5><p>服务器会把收到的请求转到index.html。（PS：test环境和production环境是这样处理的。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendFile(webpackConfig.output.path + <span class="string">'/index.html'</span>, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/html; charset=UTF-8'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中，dev环境下使用webpack-dev-middleware中间件来做。这么做的其中一个好处是，不在磁盘中存储文件，而是直接生成在内存中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> devMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)(compiler, &#123;</span><br><span class="line">  publicPath: webpackConfig.output.publicPath,</span><br><span class="line">  stats: &#123;</span><br><span class="line">    colors: <span class="literal">true</span>,</span><br><span class="line">    chunks: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve webpack bundle output</span></span><br><span class="line">app.use(devMiddleware)</span><br></pre></td></tr></table></figure></p><h5 id="作用2"><a href="#作用2" class="headerlink" title="作用2"></a>作用2</h5><p>使用中间件代理解决跨域问题，我们用了一个proxy-middleware的中间件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy api requests</span></span><br><span class="line"><span class="built_in">Object</span>.keys(apiMap).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> api = apiMap[key];</span><br><span class="line">  app.use(api.path, proxy(api.proxy));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="作用3"><a href="#作用3" class="headerlink" title="作用3"></a>作用3</h5><p>请求一些静态资源，或者本地不经过webpack编译的图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serve pure static assets</span></span><br><span class="line"><span class="keyword">var</span> staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory);</span><br><span class="line">app.use(staticPath, express.static(path.resolve(__dirname, <span class="string">'../static'</span>)))</span><br></pre></td></tr></table></figure><h5 id="作用4"><a href="#作用4" class="headerlink" title="作用4"></a>作用4</h5><p>本地调试的时候mock数据 else部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv.proxy) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(apiMap).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> api = apiMap[key];</span><br><span class="line">    app.use(api.path, proxy(api.proxy));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mock api requests</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mockDir = path.resolve(__dirname, <span class="string">'../mock'</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">setMock</span>(<span class="params">mockDir</span>) </span>&#123;</span><br><span class="line">    fs.readdirSync(mockDir).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> filePath = path.resolve(mockDir, file);</span><br><span class="line">      <span class="keyword">var</span> mock;</span><br><span class="line">      <span class="keyword">if</span> (fs.statSync(filePath).isDirectory()) &#123;</span><br><span class="line">        setMock(filePath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(file)) &#123;</span><br><span class="line">          mock = <span class="built_in">require</span>(filePath);</span><br><span class="line">          app.use(mock.api, mock.response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(mockDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>这些话是说给自己的。</p><p>首先鼓励的话，从最开始看到项目那一堆代码时的一脸懵逼，到现在基本都明白了。（不说全部都明白了，但是就算有不知道的，也知道去搜索然后了解对应的部分是做什么的）。当然，这个经历的时间有些长，包括自己学习node，koa+express。这个过程也是很美好的，收获也不少。</p><p>然后警钟的话，</p><p><strong>爱一行，干一行；干一行，爱一行。</strong>最开始虽然说是为了互联网行业的高薪来的，但是起码当时选的是你感兴趣的前端，（PS：这话说得可能就不对，因为真正的程序员眼里是不分前后端的），所以，爱一行，干一行。</p><p><strong>时刻保持着对知识的好奇以及极强的求知欲。</strong> 这句话，自己好好反思。</p><p>最后，没有最后。加油！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Vue项目的一些整体认识&quot;&gt;&lt;a href=&quot;#Vue项目的一些整体认识&quot; class=&quot;headerlink&quot; title=&quot;Vue项目的一些整体认识&quot;&gt;&lt;/a&gt;Vue项目的一些整体认识&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; cl
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://caychance.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vuex存储的时候遇到的问题及解决方案</title>
    <link href="https://caychance.github.io/2019/01/23/Vuex%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://caychance.github.io/2019/01/23/Vuex存储的时候遇到的问题及解决方案/</id>
    <published>2019-01-22T19:40:06.000Z</published>
    <updated>2019-01-22T12:19:06.464Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex使用心得</p><hr><h5 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h5><p>使用Vuex遇到过两个问题。<br>1.页面刷新或者跳转到第三方再回来，数据是会丢掉的。即Vuex持久化存储问题。<br>2.在Vuex中存储一个Falsey值（PS：false,’’,null,undefined,NaN）的时候，Vuex中存储不了。</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>第一个问题，网上有很多解决方案。使用<a href="https://github.com/robinvdvleuten/vuex-persistedstate" target="_blank" rel="noopener">vuex-persistedstate</a>。具体看文档，我就不细说了，可以使用localStorage,也可以使用cookie。</p><p>第二个问题，其实并不是Vuex本身的问题，而是因为我们项目中统一为每一个state字段生成了mutations方法。</p><p>generate方法中的语句<code>state[name] = value || state[name];</code>判断，value为false的时候，确实存不进来。</p><p>然后自己重新写了一个<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateToken(state,newToken)&#123;</span><br><span class="line">  state.token = newToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多页面共享数据</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    aaa: <span class="string">''</span>,</span><br><span class="line">    bbb:<span class="string">''</span>,</span><br><span class="line">    ccc: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据变更</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    updateToken(state,newToken)&#123;</span><br><span class="line">      state.token = newToken;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 mutations 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, value</span>) </span>&#123;</span><br><span class="line">    state[name] = value || state[name];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个 state 字段生成对应的 mutations 方法</span></span><br><span class="line"><span class="built_in">Object</span>.keys(options.state).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  options.mutations[key] = generate(key);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vuex使用心得&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h5&gt;&lt;p&gt;使用Vuex遇到过两个问题。&lt;br&gt;1.页面刷新或者跳转到第三方再回来，数据是会丢掉的。即Vuex
      
    
    </summary>
    
    
      <category term="Vuex" scheme="https://caychance.github.io/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>find-记一次生产的bug排查</title>
    <link href="https://caychance.github.io/2019/01/19/find-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E7%9A%84bug%E6%8E%92%E6%9F%A5/"/>
    <id>https://caychance.github.io/2019/01/19/find-记一次生产的bug排查/</id>
    <published>2019-01-18T21:14:12.000Z</published>
    <updated>2019-01-18T13:54:29.023Z</updated>
    
    <content type="html"><![CDATA[<h4 id="记一次生产的bug排查"><a href="#记一次生产的bug排查" class="headerlink" title="记一次生产的bug排查"></a>记一次生产的bug排查</h4><hr><h5 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h5><p>上线一周，最近的用户量增加了一些，今天下午的时候，群里一直被@，有一部分用户打开产品流程首页的时候白屏。</p><h5 id="bug复现"><a href="#bug复现" class="headerlink" title="bug复现"></a>bug复现</h5><p>借了用户的账号密码登录以后发现，我手机上是可以打开的。然后看了用户的手机系统是安卓5.0，不是很高的系统。然后找了一个测试的5.0的手机试了一下，还是可以打开的。反映出问题的用户中，vivo的机型比较多。然鹅，我们这边vivo的测试机没有5.0以下版本的。后来接到了一个魅族和小米的手机，分别是5.0和4.4的系统。登录账号，发现bug复现了。</p><h5 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h5><p>1.装了生产的包，打开chrome的调试功能(chrome://inspect/#devices);发现webpack打包以后的main文件里面的1行3000多列出现的报错。去代码中定位了一下，发现了这段代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stepObj = allStep.find(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.routeName === currentName;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2.chrome模拟打开页面的时候，在控制台输入<code>navigator.userAgent</code>，发现这个浏览器的是chrome 43。chrome43支持find语法吗？</p><p>3.去<a href="https://caniuse.com/#search=find" target="_blank" rel="noopener">caniuse</a>中搜索find的兼容性，发现chrome44以后的版本才支持find语法。</p><p>至此，问题已经定位到了。我们使用了find语法，但是用户的浏览器版本太低不支持。但是我们项目中使用了babel了呀?</p><h5 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h5><p>但是我们项目中使用了babel了呀?</p><p>虽然使用了babel，但是没有配置转换find语法。</p><p>google搜索babel find然后找到一条Stack Overflow的<a href="https://stackoverflow.com/questions/32401513/array-find-doesnt-work-with-babel" target="_blank" rel="noopener">帖子</a>。解决方法也列出来了。</p><p>至此，结束。</p><h5 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h5><p>当然了，还没有结束呢。</p><p>页面可以打开了，但是又出现另一个问题了。等着下周客户端一起检查一下。</p><h5 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h5><p>1.遇到bug心态一定要保持好，用我同事的话，你不觉得这样子一步步的去定位bug，跟侦探破案一样刺激吗？（PS：感谢他，以上有很多都是他发现的，受益匪浅）。</p><p>2.用好google搜索，Stack Overflow,github等这些国外技术社区，真的会收益良多。（PS：百度是真的垃圾，此处略去一万字）</p><p>3.英语好真的很重要啊。那天看了一篇文章，英语对一个程序员来说重要吗？回答是，如果英语不好不影响你做一个程序员；但是你想学好一门编程语言，那英语实在是太重要了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;记一次生产的bug排查&quot;&gt;&lt;a href=&quot;#记一次生产的bug排查&quot; class=&quot;headerlink&quot; title=&quot;记一次生产的bug排查&quot;&gt;&lt;/a&gt;记一次生产的bug排查&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;前提概要&quot;&gt;&lt;a href=&quot;#前提概要&quot; cl
      
    
    </summary>
    
      <category term="bug排查" scheme="https://caychance.github.io/categories/bug%E6%8E%92%E6%9F%A5/"/>
    
    
      <category term="find bug" scheme="https://caychance.github.io/tags/find-bug/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="https://caychance.github.io/2019/01/16/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caychance.github.io/2019/01/16/git学习笔记/</id>
    <published>2019-01-16T13:52:57.000Z</published>
    <updated>2019-01-18T13:02:15.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>git是14年才接触的，然后也没有系统的学习过。都是平时遇到一点问题，去搜一搜。</p><p>安装部分就不说了。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz9dildkoxj30cq06iaa8.jpg" alt><br>1.工作区<br>就是电脑上写代码部分<br>2.版本库<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><blockquote><p>mkdir learngit            新建一个文件夹<br>  cd learngit               并进入该文件夹<br>  git init                  初始化，把该文件夹变成git可以管理的仓库（会产生一个.git文件）<br>  git add <file>            把文件修改添加到暂存区（Stage）<br>  git commit -m <message>   把暂存区的所有内容提交到当前分支</message></file></p></blockquote><h5 id="查看状态及回退"><a href="#查看状态及回退" class="headerlink" title="查看状态及回退"></a>查看状态及回退</h5><blockquote><p>git status                  查看当前仓库状态<br>  git diff                    查看详细的修改内容<br>  git diff HEAD – readme.txt 查看工作区和版本库里面最新版本的区别<br>  git log                     查看从最近到最远的提交日志<br>  git log –pretty=oneline    查看从最近到最远的简洁版提交日志<br>  git log –graph             查看分支合并图<br>  git reflog                  查看历史命令<br>  git reset –hard HEAD^      回退到上一个版本<br>  git reset –hard HEAD^^     回退到上上一个版本<br>  git reset –hard HEAD~10    回退到往上10个版本<br>  git reset –hard commit_id  回退到固定某个版本</p></blockquote><h5 id="放弃修改"><a href="#放弃修改" class="headerlink" title="放弃修改"></a>放弃修改</h5><blockquote><p>git checkout – <file>      丢弃工作区的修改<br>  git reset HEAD <file>       丢弃暂存区的修改，回到工作区<br>  git rm <file>               从版本库中删除掉某文件</file></file></file></p></blockquote><h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><blockquote><p>git remote add origin git@server-name:path/repo-name.git  关联一个远程仓库<br>  git push -u origin <name>   关联后，第一次推送master分支的所有内容<br>  git push origin <name>      以后的正常提交<br>  git checkout -b <name>      新建dev分支并切换到dev分支<br>  相当于<br>  git branch <name>           新建dev分支<br>  git checkout <name>         切换到dev分支</name></name></name></name></name></p></blockquote><h5 id="合并删除分支"><a href="#合并删除分支" class="headerlink" title="合并删除分支"></a>合并删除分支</h5><blockquote><p>git branch                  查看当前分支<br>  git merge <name>            合并某个分支到当前分支<br>  git branch -d <name>        删除分支<br>  git branch -D <name>        强制删除分支</name></name></name></p></blockquote><h5 id="临时存储"><a href="#临时存储" class="headerlink" title="临时存储"></a>临时存储</h5><blockquote><p>git stash                   把当前工作现场存储起来<br>  git stash list              查看已存储<br>  git stash apply             把已存储的内容恢复，内容不删除<br>  git stash drop              删除已存储的内容<br>  git stash pop               恢复内容以后同时删除内容</p></blockquote><h5 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h5><blockquote><p>git remote                  查看远程库信息<br>  git remote -v               查看远程库详细信息<br>  git push origin <name>      把该分支上的所有本地提交推送到远程库<br>  git checkout -b <name> origin/<name>  在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致<br>  git branch –set-upstream <name> origin/<name>  建立本地分支和远程分支的关联<br>  git pull                    从远程合并<br>  如果提示no tracking information<br>  则说明本地分支和远程分支的链接关系没有创建，可以使用<br>  git branch –set-upstream-to <name> origin/<name></name></name></name></name></name></name></name></p></blockquote><h5 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h5><blockquote><p>标签总是和某个commit挂钩。<br>  git tag <tagname>           用于新建一个标签，默认为HEAD，也可以指定一个commit id<br>  git tag <tagname> commit_id 给指定一个commit_id新建一个标签<br>  git tag                     查看所有标签<br>  git show <tagname>          查看标签信息<br>  git tag -d <tagname>        删除一个本地标签<br>  git push origin <tagname>   推送某个标签到远程（PS：创建的标签都只存储在本地）<br>  git push origin –tags      一次性推送全部尚未推送到远程的本地标签<br>  如果标签已经推送到远程，要删除远程标签就麻烦一点<br>  git tag -d <tagname>                   删除一个本地标签<br>  git push origin :refs/tags/<tagname>   删除一个远程标签</tagname></tagname></tagname></tagname></tagname></tagname></tagname></p></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>git是Linux之父linus创造的，属于一种分布式版本控制系统。（PS：区别于集中式的版本控制系统）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;p&gt;git是14年才接触的，然后也没有系统的学习过。都是平时遇到一点问题，去搜一搜。&lt;/p&gt;
&lt;p&gt;安装部分就不说了。&lt;/p&gt;
&lt;h4 id=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="https://caychance.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="https://caychance.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="https://caychance.github.io/2019/01/12/BFC/"/>
    <id>https://caychance.github.io/2019/01/12/BFC/</id>
    <published>2019-01-11T20:31:59.000Z</published>
    <updated>2019-01-18T13:03:31.352Z</updated>
    
    <content type="html"><![CDATA[<h4 id="BFC是什么"><a href="#BFC是什么" class="headerlink" title="BFC是什么"></a>BFC是什么</h4><p>前几天被人问到了BFC，一脸懵逼。赶紧看看，简单总结一下。</p><ul><li><a href="#概念">概念</a></li><li><a href="#BFC的特性">BFC的特性</a></li><li><a href="#如何触发BFC">如何触发BFC</a></li></ul><p>简单总结一下：</p><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><blockquote><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流。</p></blockquote><p>PS:区别于普通流，常见的还有浮动（float），绝对定位（absolute）</p><p><strong>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</strong></p><h5 id="BFC的特性："><a href="#BFC的特性：" class="headerlink" title="BFC的特性："></a>BFC的特性：</h5><p>1.同一个BFC中的margin会重叠<br>2.浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。<br>3.BFC可以阻止元素被浮动元素覆盖。</p><h5 id="如何触发BFC：-PS：满足一下任一条件即可触发"><a href="#如何触发BFC：-PS：满足一下任一条件即可触发" class="headerlink" title="如何触发BFC：(PS：满足一下任一条件即可触发)"></a>如何触发BFC：(PS：满足一下任一条件即可触发)</h5><p>1.body根元素<br>2.浮动元素：float除none以外的值<br>3.绝对定位元素：position 等于absolute或者fixed<br>4.display等于 inline-block、table-cells、flex<br>5.overflow等于除了 visible 以外的值 (hidden、auto、scroll)<br>类似函数作用域。</p><p><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;BFC是什么&quot;&gt;&lt;a href=&quot;#BFC是什么&quot; class=&quot;headerlink&quot; title=&quot;BFC是什么&quot;&gt;&lt;/a&gt;BFC是什么&lt;/h4&gt;&lt;p&gt;前几天被人问到了BFC，一脸懵逼。赶紧看看，简单总结一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概
      
    
    </summary>
    
    
      <category term="css" scheme="https://caychance.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>如何使用七牛云</title>
    <link href="https://caychance.github.io/2019/01/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    <id>https://caychance.github.io/2019/01/06/如何使用七牛云/</id>
    <published>2019-01-05T23:59:38.000Z</published>
    <updated>2019-01-13T10:45:17.217Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一个需求，使用七牛云的sdk来上传图片。  七牛云的文档写的可以更好一点。</p><p>html部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">'imageUrl'</span> <span class="attr">type</span>=<span class="string">"file"</span> @<span class="attr">click</span>=<span class="string">"uploadImage('imageUrl')"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个用的是vue做的，所以会有一个ref标签，直接用原生html写的可以忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上传图片</span></span><br><span class="line">uploadImage(ref) &#123;</span><br><span class="line">  <span class="comment">//选中input元素</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span>(ref === <span class="string">'imageUrl'</span>)&#123;</span><br><span class="line">    input = <span class="keyword">this</span>.$refs[ref];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    input = <span class="keyword">this</span>.$refs[ref][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//input在onchange的时候触发</span></span><br><span class="line">  input.onchange = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//localFileName 文件的本地名，一般是一个绝对地址的路径</span></span><br><span class="line">    <span class="keyword">let</span> localFileName = input.value;</span><br><span class="line">    <span class="comment">//文件名</span></span><br><span class="line">    <span class="keyword">let</span> suffix = localFileName.substring(localFileName.lastIndexOf(<span class="string">"."</span>),localFileName.length);<span class="comment">//后缀名</span></span><br><span class="line">    <span class="keyword">let</span> fileName = localFileName.substring(localFileName.lastIndexOf(<span class="string">"\\"</span>)+<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> file = input.files[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要先获取上传七牛云的token</span></span><br><span class="line">    axios.get(<span class="string">`<span class="subst">$&#123;GET_UPLOAD_TOKEN&#125;</span>?fileName=<span class="subst">$&#123;fileName&#125;</span>`</span>).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(response.code === <span class="number">2000</span>)&#123;</span><br><span class="line">        <span class="comment">//七牛云token</span></span><br><span class="line">        <span class="keyword">const</span> token = response.data;</span><br><span class="line">        <span class="keyword">const</span> observer = &#123;</span><br><span class="line">          next(response)&#123;</span><br><span class="line">            <span class="keyword">let</span> process = <span class="built_in">Math</span>.floor(response.total.percent)+<span class="string">'%'</span>;</span><br><span class="line">            <span class="keyword">if</span>(process === <span class="string">'100%'</span>)&#123;</span><br><span class="line">              <span class="comment">//这里可以写上传成功的处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          error(err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">          &#125;,</span><br><span class="line">          complete(res1)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res1);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> key = fileName;<span class="comment">//上传文件名</span></span><br><span class="line">        <span class="keyword">const</span> putExtra = &#123;</span><br><span class="line">            fname: fileName,</span><br><span class="line">            params: &#123;&#125;,</span><br><span class="line">            mimeType:[<span class="string">"image/png"</span>, <span class="string">"image/jpeg"</span>, <span class="string">"image/gif"</span>]</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> config = &#123;</span><br><span class="line">          useCdnDomain: <span class="literal">true</span>,</span><br><span class="line">          region: qiniu.region.z0</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> observable = qiniu.upload(file, key, token, putExtra, config);</span><br><span class="line">        observable.subscribe(observer) <span class="comment">// 上传开始</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>以上结束。当然了，七牛云的存储那边也需要设置一下。具体查看文档就好了。其实js部分就是七牛云提供的，html部分，我刚开始很纠结，不知道能不能用form表单的action来操作。</p><p><a href="https://developer.qiniu.com/kodo/sdk/1283/javascript" target="_blank" rel="noopener">七牛云的文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做了一个需求，使用七牛云的sdk来上传图片。  七牛云的文档写的可以更好一点。&lt;/p&gt;
&lt;p&gt;html部分&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="工具" scheme="https://caychance.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="七牛云" scheme="https://caychance.github.io/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>js继承方法总结</title>
    <link href="https://caychance.github.io/2018/12/14/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://caychance.github.io/2018/12/14/js继承方法总结/</id>
    <published>2018-12-13T20:31:20.000Z</published>
    <updated>2019-04-19T07:13:42.204Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="js继承方法"><a href="#js继承方法" class="headerlink" title="js继承方法"></a>js继承方法</h3><ul><li><a href="#1原型链继承">原型链继承</a></li><li><a href="#2借用构造函数继承">借用构造函数继承</a></li><li><a href="#3组合继承">组合继承</a></li><li><a href="#4原型式继承">原型式继承</a></li><li><a href="#5寄生式继承">寄生式继承</a></li><li><a href="#6寄生组合式继承">寄生组合式继承</a></li><li><a href="#7混入方式继承多个对象">混入方式继承多个对象</a></li><li><a href="#8ES6类继承extends">ES6类继承extends</a></li><li><a href="#总结">总结</a></li></ul><h4 id="1原型链继承"><a href="#1原型链继承" class="headerlink" title="1原型链继承"></a>1原型链继承</h4><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p><blockquote><p>继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里是关键，创建Father的实例，并将该实例赋值给Son.prototype</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy5eirt2pxj30m80bldjb.jpg" alt><br>原型链方案存在的缺点：</p><ul><li><strong>多个实例对引用类型的操作会被篡改。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure><h4 id="2借用构造函数继承"><a href="#2借用构造函数继承" class="headerlink" title="2借用构造函数继承"></a>2借用构造函数继承</h4><blockquote><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自Father</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.color.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//"red,green,blue,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance2.color);<span class="comment">//"red,green,blue"</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>Father.call(this)</code>，创建子类实例时调用<code>Father</code>构造函数，于是<code>Son</code>的每个实例都会将<code>Father</code>中的属性复制一份。</p><p>借用构造函数继承的缺点：</p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h4 id="3组合继承"><a href="#3组合继承" class="headerlink" title="3组合继承"></a>3组合继承</h4><blockquote><p>组合上述两种方法就是组合继承。用<strong>原型链实现对原型属性和方法的继承</strong>，用<strong>借用构造函数技术来实现实例属性的继承</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用Father()</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用Father()</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 重写Son.prototype的constructor属性，指向自己的构造函数Son</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>组合继承的缺点：</p><ul><li>第一次调用Father()：给Son.prototype写入两个属性name，color。</li><li>第二次调用Father()：给instance1写入两个属性name，color。</li></ul><p>实例对象instance1上的两个属性就屏蔽了其原型对象Son.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p><h4 id="4原型式继承"><a href="#4原型式继承" class="headerlink" title="4原型式继承"></a>4原型式继承</h4><blockquote><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<strong>浅复制</strong>，将构造函数F的原型直接指向传入的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure><p>原型式继承缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数<br>另外，ES5中存在Object.create()的方法，能够代替上面的object方法。</li></ul><h4 id="5寄生式继承"><a href="#5寄生式继承" class="headerlink" title="5寄生式继承"></a>5寄生式继承</h4><blockquote><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">// 通过调用 object() 函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强对象</span></span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure><p>寄生式继承的缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h4 id="6寄生组合式继承"><a href="#6寄生组合式继承" class="headerlink" title="6寄生组合式继承"></a>6寄生组合式继承</h4><blockquote><p>结合借用构造函数(2)传递参数和寄生模式(5)实现继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">son, father</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(father.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = son;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  son.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类原型指向子类</span></span><br><span class="line">inheritPrototype(Son, Father);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"xyc"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son(<span class="string">"lxy"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">"2"</span>); <span class="comment">// ["red", "blue", "green", "2"]</span></span><br><span class="line">instance1.colors.push(<span class="string">"3"</span>); <span class="comment">// ["red", "blue", "green", "3"]</span></span><br></pre></td></tr></table></figure><ul><li>这个例子的高效率体现在它只调用了一次<code>Father</code>构造函数，并且因此避免了在<code>Son.prototype</code>上创建不必要的、多余的属性。<br>于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code>和<code>isPrototypeOf()</code></li><li>这是最成熟的方法，也是现在库实现的方法</li></ul><h4 id="7混入方式继承多个对象"><a href="#7混入方式继承多个对象" class="headerlink" title="7混入方式继承多个对象"></a>7混入方式继承多个对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p><h4 id="8ES6类继承extends"><a href="#8ES6类继承extends" class="headerlink" title="8ES6类继承extends"></a>8ES6类继承extends</h4><p>extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    get area() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    calcArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p>extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">son, father</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">    son.prototype = <span class="built_in">Object</span>.create(father &amp;&amp; father.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: son,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (father) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf</span><br><span class="line">            ? <span class="built_in">Object</span>.setPrototypeOf(son, father)</span><br><span class="line">            : son.__proto__ = father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、ES5继承和ES6继承的区别</p><ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li><li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;js继承方法&quot;&gt;&lt;a href=&quot;#js继承方法&quot; class=&quot;headerlink&quot; title=&quot;js继承方法&quot;&gt;&lt;/a&gt;js继承方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1原型链继承&quot;&gt;原型链继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="js" scheme="https://caychance.github.io/categories/js/"/>
    
    
      <category term="继承" scheme="https://caychance.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="https://caychance.github.io/2018/12/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://caychance.github.io/2018/12/07/浏览器缓存机制/</id>
    <published>2018-12-06T16:43:58.000Z</published>
    <updated>2019-02-15T02:36:29.106Z</updated>
    
    <content type="html"><![CDATA[<hr><p>（PS:这篇文章，就是纯粹的纸上谈兵哈，并没有实践过。所以一定要自己动手试试。）</p><h4 id="浏览器缓存的基本原理"><a href="#浏览器缓存的基本原理" class="headerlink" title="浏览器缓存的基本原理"></a>浏览器缓存的基本原理</h4><p>1）浏览器在加载资源时，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。<br>2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过<code>last-modified</code>和<code>etag</code>验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源<br>3）如果前面两者都没有命中，直接从服务器加载资源</p><h4 id="浏览器缓存类型："><a href="#浏览器缓存类型：" class="headerlink" title="浏览器缓存类型："></a>浏览器缓存类型：</h4><p>浏览器的缓存分为两种：强缓存和协商缓存。</p><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源。</p><p>协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>共同点：两者都是从客户端缓存中读取资源；区别：强缓存不会向服务器发送请求，协商缓存会向服务器发送请求。</p><h4 id="强缓存相关字段"><a href="#强缓存相关字段" class="headerlink" title="强缓存相关字段"></a>强缓存相关字段</h4><p>Expires和Cache-Control</p><p>1）Expires</p><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。<br>Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p><blockquote><p>Expires: Wed, 11 May 2018 07:20:00 GMT</p></blockquote><p>2）Cache-Control</p><p>Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间。</p><p>相对Expires而言，max-age是距离请求发起的时间的秒数。</p><blockquote><p>Cache-Control: max-age=315360000</p></blockquote><h4 id="协商缓存相关字段"><a href="#协商缓存相关字段" class="headerlink" title="协商缓存相关字段"></a>协商缓存相关字段</h4><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p><p>1）Last-Modified，If-Modified-Since</p><p><code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</p><p>但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag</p><p>2）ETag、If-None-Match</p><p><code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的</p><p><code>If-None-Match</code>的header会将上次返回的<code>Etag</code>发送给服务器，询问该资源的<code>Etag</code>是否有更新，有变动就会发送新的资源回来</p><p>3）ETag的优先级比Last-Modified更高</p><p>具体为什么要用<code>ETag</code>，主要出于下面几种情况考虑：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p><a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">参考链接</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226262&amp;idx=1&amp;sn=2128db200b88479face67ed8e095757c&amp;chksm=bd4959128a3ed0041b43a5683c75c4b88c7d35fac909a59c14b4e9fc11e8d408680b171d2706&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;（PS:这篇文章，就是纯粹的纸上谈兵哈，并没有实践过。所以一定要自己动手试试。）&lt;/p&gt;
&lt;h4 id=&quot;浏览器缓存的基本原理&quot;&gt;&lt;a href=&quot;#浏览器缓存的基本原理&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存的基本原理&quot;&gt;&lt;/a&gt;浏览器
      
    
    </summary>
    
      <category term="js" scheme="https://caychance.github.io/categories/js/"/>
    
    
      <category term="缓存" scheme="https://caychance.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>js event loop</title>
    <link href="https://caychance.github.io/2018/12/06/js-event-loop/"/>
    <id>https://caychance.github.io/2018/12/06/js-event-loop/</id>
    <published>2018-12-06T15:45:40.000Z</published>
    <updated>2019-03-29T11:48:33.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><hr><p>JavaScript是单线程的，这与它的用途有关。</p><h4 id="为什么JavaScript是单线程的？"><a href="#为什么JavaScript是单线程的？" class="headerlink" title="为什么JavaScript是单线程的？"></a>为什么JavaScript是单线程的？</h4><p>假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><h4 id="任务分类"><a href="#任务分类" class="headerlink" title="任务分类"></a>任务分类</h4><h5 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h5><p>因为JavaScript是单线程的，如果加载一个图片，需要很久，那么网页就会阻塞。因此，从广义上来讲任务分为两类：</p><ul><li>同步任务<blockquote><p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</p></blockquote></li><li>异步任务<blockquote><p>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p></blockquote></li></ul><p>执行顺序：</p><pre><code>（1）所有同步任务都在主线程上执行，形成一个执行栈。（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。</code></pre><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1jrpu6q3ij30g50boq3q.jpg" alt></p><h5 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h5><p>对任务进行更精细的定义的话，也可以分为两类：</p><ul><li>宏任务（macro-task）<blockquote><p>包括整体代码script、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI Rendering</p></blockquote></li><li>微任务（micro-task）<blockquote><p>new Promise().then(回调)、Process.nextTick、Object.observe、MutationObserver</p></blockquote></li></ul><h4 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h4><p>执行顺序：</p><pre><code>1.当某个宏任务执行完后,会查看是否有微任务队列。2-1.如果有，先执行微任务队列中的所有任务，2-2.如果没有，会读取宏任务队列中排在最前的任务，3.执行宏任务的过程中，遇到微任务，依次加入微任务队列。4.栈空后，再次读取微任务队列里的任务，依次类推。</code></pre><h4 id="Node中的Event-Loop"><a href="#Node中的Event-Loop" class="headerlink" title="Node中的Event Loop"></a>Node中的Event Loop</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1js5cwo3wj30m808saad.jpg" alt></p><p>Node中的Event Loop不同于浏览器。Node运行机制如下：</p><ul><li>V8引擎解析JavaScript脚本。</li><li>解析后的代码，调用Node API。</li><li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ul><p>其中libuv引擎中的事件循环分为6个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1js4x78vxj30lg0jm76o.jpg" alt></p><p>node中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）</p><ul><li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li><li>I/O callbacks阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅node内部使用</li><li>poll 阶段：获取新的I/O事件,适当的条件下node将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close事件回调</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p><ul><li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li><li>Node端，microtask 在事件循环的各个阶段之间执行</li><li>Node11版本中，Event Loop运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这点就跟浏览器端一致。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>浏览器端：</p><p>先执行宏任务，宏任务执行完以后，执行当前的微任务。然后再依次往后执行，循环。</p><p>Node端：</p><p>1.Node版本11 同浏览器端</p><p>2.Node版本10及以下</p><p>按照poll=&gt;check=&gt;close callbacks=&gt;timers=&gt;I/O callbacks=&gt;idle,prepare的顺序执行，微任务会在每个阶段执行完以后执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Event-Loop&quot;&gt;&lt;a href=&quot;#Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;Event Loop&quot;&gt;&lt;/a&gt;Event Loop&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;JavaScript是单线程的，这与它的用途有关。&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
      <category term="js" scheme="https://caychance.github.io/categories/js/"/>
    
    
      <category term="event loop" scheme="https://caychance.github.io/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="https://caychance.github.io/2018/12/05/markdown/"/>
    <id>https://caychance.github.io/2018/12/05/markdown/</id>
    <published>2018-12-05T14:13:45.000Z</published>
    <updated>2018-12-06T05:11:01.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="markdown常用语法"><a href="#markdown常用语法" class="headerlink" title="markdown常用语法"></a>markdown常用语法</h3><hr><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#1">标题</a></li><li><a href="#2">引入代码</a></li><li><a href="#3">外链</a></li><li><a href="#4">引入图片</a></li><li><a href="#5">引用</a></li><li><a href="#6">缩进</a></li><li><a href="#7">斜体</a></li><li><a href="#8">加粗</a></li><li><a href="#9">分割线</a></li><li><a href="#10">待办</a></li><li><a href="#11目录锚点">目录锚点</a></li><li><a href="#12引入单句代码">引入单句代码</a><br><h4 id="1">1、标题</h4><br>井号#后面空一格<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p></p><h4 id="2">2、引入代码</h4><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h4 id="3">3、外链</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">参考链接</span>](<span class="link">https://caychance.github.io/</span>)</span><br></pre></td></tr></table></figure><p></p><p><a href="https://caychance.github.io/">参考链接</a></p><p></p><h4 id="4">4、引入图片</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwly1fxq7h427d7j30780c7t9o.jpg)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxq7h427d7j30780c7t9o.jpg" alt></p><p></p><h4 id="5">5、引用</h4><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;一段引用的话</span><br><span class="line">换行了</span><br></pre></td></tr></table></figure><p></p><blockquote><p>一段引用的话<br>换行了</p></blockquote><p></p><h4 id="6">6、缩进</h4><br>三种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不带缩进的一行</span><br><span class="line">&amp;nbsp;不断行的空白格或&amp;#160;</span><br><span class="line">&amp;ensp;半方大的空白或&amp;#8194;</span><br><span class="line">&amp;emsp;全方大的空白或&amp;#8195;</span><br></pre></td></tr></table></figure><p></p><p>不带缩进的一行<br>&nbsp;不断行的空白格或&#160;<br>&ensp;半方大的空白或&#8194;<br>&emsp;全方大的空白或&#8195;</p><p></p><h4 id="7">7、斜体</h4><br>两种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_这是斜体_</span></span><br><span class="line"><span class="emphasis">*这是斜体*</span></span><br></pre></td></tr></table></figure><p></p><p><em>这是斜体</em><br><em>这是斜体</em></p><p></p><h4 id="8">8、加粗</h4><br>两种方法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">__这是斜体__</span></span><br><span class="line"><span class="strong">**这是斜体**</span></span><br></pre></td></tr></table></figure><p></p><p><strong>这是斜体</strong><br><strong>这是斜体</strong></p><p></p><h4 id="9">9、分割线</h4><br>分割线只能标题下使用<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">##### 华丽的分割线</span></span><br><span class="line">---</span><br><span class="line">华丽的分割线</span><br></pre></td></tr></table></figure><p></p><h5 id="华丽的分割线"><a href="#华丽的分割线" class="headerlink" title="华丽的分割线"></a>华丽的分割线</h5><hr><p>华丽的分割线</p><p></p><h4 id="10">10、待办</h4><br>[ ] 前后都要有空格<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[ ] 不勾选</span><br><span class="line"><span class="bullet">- </span>[x] 勾选</span><br></pre></td></tr></table></figure><p></p><ul><li style="list-style: none"><input type="checkbox"> 不勾选</li><li style="list-style: none"><input type="checkbox" checked> 勾选</li></ul><h4 id="11目录锚点"><a href="#11目录锚点" class="headerlink" title="11目录锚点"></a>11目录锚点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>[<span class="string">中国</span>](<span class="link">#中国</span>)</span><br><span class="line">  * [<span class="string">北京</span>](<span class="link">#北京</span>)</span><br><span class="line">  * [<span class="string">陕西</span>](<span class="link">#陕西</span>)</span><br><span class="line"><span class="code">    * [西安](#西安_1)</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">美国</span>](<span class="link">#美国</span>)</span><br><span class="line">  * [<span class="string">纽约</span>](<span class="link">#纽约</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">俄罗斯</span>](<span class="link">#俄罗斯</span>)</span><br><span class="line">  * [<span class="string">莫斯科</span>](<span class="link">#莫斯科</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">希腊</span>](<span class="link">#希腊</span>)</span><br><span class="line">  * [<span class="string">有些尴尬</span>](<span class="link">#有些尴尬</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="#中国">中国</a><ul><li><a href="#北京">北京</a></li><li><a href="#陕西">陕西</a><ul><li><a href="#西安_1">西安</a></li></ul></li></ul></li><li><a href="#美国">美国</a><ul><li><a href="#纽约">纽约</a></li></ul></li><li><a href="#俄罗斯">俄罗斯</a><ul><li><a href="#莫斯科">莫斯科</a></li></ul></li><li><a href="#希腊">希腊</a><ul><li><a href="#有些尴尬">有些尴尬</a></li></ul></li></ul><p></p><h4 id="西安_1">西安</h4><br>方法一：以标题西安为例。标题加一个id等于目录上西安的锚点西安_1。这种方式锚点中可以有特殊字符。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">id</span>=<span class="string">西安_1</span>&gt;</span></span>西安<span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p></p><h4 id="纽约"><a href="#纽约" class="headerlink" title="纽约"></a>纽约</h4><p>方法二：以纽约为例。markdown的标题会自动加上锚点。例如下面的锚点自动就是纽约。不过这种方式设置的锚点中不能设置特殊字符。打开开发者模式查看一下元素就明白了。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 纽约</span></span><br></pre></td></tr></table></figure></p><h4 id="12引入单句代码"><a href="#12引入单句代码" class="headerlink" title="12引入单句代码"></a>12引入单句代码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="code">`hexo server`</span>启动服务，使用<span class="code">`hexo g`</span>和<span class="code">`hexo d`</span>发布</span><br></pre></td></tr></table></figure><p>使用<code>hexo server</code>启动服务，使用<code>hexo g</code>和<code>hexo d</code>发布</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;markdown常用语法&quot;&gt;&lt;a href=&quot;#markdown常用语法&quot; class=&quot;headerlink&quot; title=&quot;markdown常用语法&quot;&gt;&lt;/a&gt;markdown常用语法&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; cl
      
    
    </summary>
    
      <category term="工具" scheme="https://caychance.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="markdown" scheme="https://caychance.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
